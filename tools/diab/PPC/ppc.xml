
<!--	Implementation module : ppc.xml						-->
<!--	Copyright 2005-2008 WindRiver Systems, Inc. All Rights Reserved		-->
<!--	Description :								-->
<!--	PowerPC architecture description.					-->

<!-- TODO TOFIX:								-->
<!--   The following simplified mnemonics have trouble after translation.	-->
<!--	    mfpmr  r3,pmc1							-->
<!--	    mfpmr  r3,upmc1							-->
<!--	    mtpmr  pmc1,r4							-->
<!--	    mtpmr  upmc1,r4							-->

<!-- Firefox/Explorer:								-->
<!-- 	To parse and display this XML file using these browsers you must	-->
<!-- 	change some of the characters found in the strings.  Replace:		-->
<!--		AND with ~							-->
<!-- 		LESS-THAN-EQUAL with ^						-->
<!-- 		SHIFT-LEFT with {						-->
<!-- 	Change them back when finished.						-->
<!-- 	You must also add a tag at the start/end of the file.			-->

<?xml version="1.0"?>
<RequireXmlFile file="../defs.xml" />

<AttributeDefinitions>

    <!-- atable Processor created by llopt.cc::setProcessorAttribute as $$ directives are processed -->

    <atable name="ProcessorOptions">
	<idef name="valuefollowing"	ivalue="KVF.INHIBIT_NOTHING" />
	<idef name="callLiveness"	ivalue="1" />
	<idef name="blockLiveness"	ivalue="1" />
	<idef name="instructionsCompleteEarly"	ivalue="1" />	<!-- Multiplies early out -->
    </atable>

    <!-- PPC Parse Class formats  contain modifiers to indicate	 -->
    <!-- which	portion of  the	 GPR is being addresses.   E500	 -->
    <!-- variants contain an  additional register  bank to hold	 -->
    <!-- the upper 32-bits.  Some instructions touch both banks	 -->
    <!--							 -->
    <!--  b - both upper/lower bank touched			 -->
    <!--  h - upper bank only					 -->
    <!--  l - lower bank only (default)				 -->
    <!--							 -->
    <atable name="PpcParseClass" prefix="PPC_PC_" cgen="define">
	<adef name="NOPARSE"		ivalue="0" />
	<adef name="EMPTY"		ivalue="1"	format="" />
	<adef name="BRANCH"		ivalue="2"	format="%tS" />
	<adef name="DST"		ivalue="3"	format="%D" />
	<adef name="SRC"		ivalue="4"	format="%S" />
	<adef name="UNARY"		ivalue="5"	format="%D,%S" />
	<adef name="BINARY"		ivalue="6"	format="%D,%S,%S" />
	<adef name="COMPARE"		ivalue="7"	format="%S,%S,%S,%S|%S,%S,%S|%S,%S" />
	<adef name="SRC3"		ivalue="8"	format="%S,%S,%S" />
	<adef name="ROTATE"		ivalue="9"	format="%D,%S,%S,%S,%S" />
	<adef name="INSERT"		ivalue="10"	format="%mS,%S,%S,%S,%S" />
	<adef name="STORE"		ivalue="11"	format="%S,%D" />
	<adef name="BCLR"		ivalue="12"	format="%S,%S" />
	<adef name="STSW"		ivalue="13"	format="%S,%S,%S" />
	<adef name="FMADD"		ivalue="14"	format="%D,%S,%S,%S" />
	<adef name="FCMP"		ivalue="15"	format="%S,%S,%S" />
	<adef name="SRC2"		ivalue="16"	format="%S,%S" />
	<adef name="COMPARE2"		ivalue="17"	format="%S,%S,%S" />
	<adef name="ISEL"		ivalue="18"	format="%D,%S,%S,%S" />
	<adef name="EV64HI"		ivalue="19"	format="%bD,%hS,%hS" />
	<adef name="EV64HILO"		ivalue="20"	format="%bD,%hS,%lS" />
	<adef name="EV64LO"		ivalue="21"	format="%bD,%lS,%lS" />
	<adef name="EV64LOHI"		ivalue="22"	format="%bD,%lS,%hS" />
	<adef name="EV64BINARY"		ivalue="23"	format="%bD,%bS,%bS" />
	<adef name="EV64UNARY"		ivalue="24"	format="%bD,%bS" />
	<adef name="EV64COMPARE2"	ivalue="25"	format="%S,%bS,%bS" />
	<adef name="EV64ISEL"		ivalue="26"	format="%bD,%bS,%bS,%S" />
	<adef name="EV64UNARY2"		ivalue="27"	format="%bD,%S" />
	<adef name="EV64BINARY2"	ivalue="28"	format="%bD,%S" />
	<adef name="EV64STORE"		ivalue="29"	format="%bS,%D" />
	<adef name="EV64UNARY3"		ivalue="30"	format="%D,%bS" />
	<adef name="EV64DST"		ivalue="31"	format="%bD" />
	<adef name="EV64BDBSIMM"	ivalue="32"	format="%bD,%bS,%S" />
	<adef name="EV64BDBSI1I2"	ivalue="33"	format="%bD,%bS,%S,%S" />
	<adef name="SRCOPT"		ivalue="34"	format="|%S" />
	<adef name="SRC23"		ivalue="35"	format="%S,%S,%S|%S,%S" />
	<adef name="MSRC12"		ivalue="36"	format="%mS,%S" />
	<adef name="MSRC1"		ivalue="37"	format="%mS" />
	<adef name="MAC3"		ivalue="38"	format="%mS,%S,%S" />
	<adef name="D_SEA"		ivalue="39"	format="%D,%eS" />
	<adef name="SRC3OPT"		ivalue="40"	format="|%S,%S,%S" />
	<adef name="DSTSRCOPT"		ivalue="41"	format="%D|%D,%S" />
	<adef name="VAFORM"		ivalue="42"	format="%D,%S,%S,%S" />
	<adef name="VXFORM"		ivalue="43"	format="%D,%S,%S" />
	<adef name="VXFORMD"		ivalue="44"	format="%D" />
	<adef name="VXFORMS"		ivalue="45"	format="%S" />
	<adef name="VXFORMDS"		ivalue="46"	format="%D,%S" />
	<adef name="XFORMS34"		ivalue="47"	format="%S,%S,%S,%S|%S,%S,%S" />
	<adef name="XFORMS012"		ivalue="48"	format="|%S|%S,%S" />
	<adef name="SRC4"		ivalue="49"	format="%S,%S,%S,%S" />
	<adef name="SRC45"		ivalue="50"	format="%S,%S,%S,%S,%S|%S,%S,%S,%S" />
	<adef name="EV64SAVEM"		ivalue="51"	format="%bS,%S" />
	<adef name="EVMAC3"		ivalue="52"	format="%mbS,%bS,%bS" />
	<adef name="TERNARY"    ivalue="53" format="%D,%S,%S,%S" />
    </atable>

    <itable name="PpcRelocation" prefix="PPC_RELOC_" cgen="define">
	<!-- NOTE - "0" is used to mean no relocation -->
	<idef name="code"	ivalue="0x0001" />
	<idef name="data"	ivalue="0x0002" />
	<idef name="gotoff"	ivalue="0x0004" />
	<idef name="got"	ivalue="0x0008" />
	<idef name="plt"	ivalue="0x0010" />
	<idef name="imt"	ivalue="0x0020" />
	<idef name="imto"	ivalue="0x0040" />
	<idef name="local"	ivalue="0x0080" />
	<idef name="sdarx"	ivalue="0x0100" />
	<idef name="sdax"	ivalue="0x0200" />
	<idef name="sda"	ivalue="0x0400" />
	<idef name="vtbl"	ivalue="0x0800" />
	<idef name="ha"		ivalue="0x1000" />
	<idef name="ha16"	ivalue="0x1000" />
	<idef name="hiadj"	ivalue="0x1000" />
	<idef name="h"		ivalue="0x2000" />
	<idef name="hi"		ivalue="0x2000" />
	<idef name="hi16"	ivalue="0x2000" />
	<idef name="l"		ivalue="0x4000" />
	<idef name="lo"		ivalue="0x4000" />
	<idef name="lo16"	ivalue="0x4000" />
    </itable>


    <itable name="PpcOpCost" alias="POC">
	<idef name="ARITH"	ivalue="1" />
	<idef name="FLOATOP"	ivalue="2" />
	<idef name="MEM"	ivalue="2" />
	<idef name="MUL"	ivalue="3" />
	<idef name="BRANCH"	ivalue="4" />
	<idef name="ALTIVEC"	ivalue="2" />
	<idef name="VMEM"	ivalue="3" />
    </itable>

    <itable name="EXPORT">
	<idef name="SPE1"	ivalue="0x01" />	<!-- Freescale SPE version 1 -->
	<idef name="SPE2"	ivalue="0x02" />	<!-- Freescale SPE version 2 -->
	<idef name="ISEL"	ivalue="0x04" />	<!-- Freescale integer select -->
	<idef name="WAIT"	ivalue="0x08" />	<!-- Freescale wait for interrupt -->
	<idef name="ASM1"	ivalue="0x10" />
	<idef name="REO"	ivalue="0x20" />
    </itable>

    <!-- TODO: add more targets as needed. Can ppc_tbl.cc use this? -->
    <atable name="Cpu">
	<adef name="E500V1"		svalue="0"	/>
	<adef name="E500V2"		svalue="0"	/>
	<adef name="E500"		svalue="0"	/>
	<cond when="Processor.CPUID == 500 || Processor.CPUID == 5554 || (Processor.CPUID >= 8540 && Processor.CPUID <= 8560) || Processor.CPUID == 5001">
		<adef name="E500"		svalue="1"	/>
		<adef name="E500V1"		svalue="1"	/>
	</cond>
	<cond when="Processor.CPUID==5002">
		<adef name="E500"		svalue="1"	/>
		<adef name="E500V2"		svalue="1"	/>
	</cond>
    </atable>

    <atable name="AltiVec">
	<adef name="VEC"	svalue="VIU"	/>
	<adef name="VFP"	svalue="VFPU^2"	/>
	<adef name="VCI"	svalue="VIU2^4"	/>
    </atable>

    <atable name="Codefar">
	<adef name="CTR"	svalue=""	/>
      <cond when="Processor.FARCTR">
	<adef name="CTR"	svalue="ctr"	/>	<!-- code-absolute-far uses CTR indirect calls -->
      </cond>
    </atable>

    <!-- Documentation: PowerPC e500 Core Family Reference Manual, E500CORERM.pdf, Table 4-8 -->
    <atable name="SpeE500">
        <adef name="MU"         svalue="MU1 MU2 MU3 MU4"  />
        <adef name="MU2"        svalue="MU1 PREDIV^26 DIV MU4" />
        <adef name="MU3"        svalue="MU1 PREDIV^32 DIV MU4" />
        <adef name="SU1"        svalue="SU1"    />
        <adef name="DEF1"       svalue="(SU1|SU2)"    />
        <adef name="MU6"        svalue="MU1 MU2 MU3 MU4 MU5 MU6" />
        <adef name="SPEDIV"     svalue="MU1 PREDIV^29 DIV MU6" />
    </atable>

    <!-- TODO: Keep for now. Replace with e200 SPE descriptions. This will involve SPE instruction classes specific to e200's. -->
    <atable name="SpeV1">
	<adef name="MU"		svalue="SPE^4"	/>
	<adef name="MU2"	svalue="SPE^12"	/>
	<adef name="MU3"	svalue="SPE^12"	/>
	<adef name="SU1"	svalue="SPE"	/>
	<adef name="DEF1"	svalue="SPE"	/>
	<adef name="MU4"	svalue="SPE^12"	/>
	<adef name="MU6"	svalue="SPE^12"	/>
    </atable>

    <atable name="Pipe601">
        <!-- Documentation: MPC601UM/AD PowerPC 601 RISC Microprocessor User's Manual -->
	<!-- The 601 has no feed-forwarding capability (p7-84). Therefore, Complete and Writeback stages (CWB) are modelled. --> 
	<!--  The documentation shows a combination of multiple resources used that is more complex than the description modelled here and also more complex than the other targets. -->
	<adef name="NOTI"	svalue="FD*3 CWB*3"	/>
	<adef name="DEF"	svalue="FD*3 IU CWB*3"	/>
	<adef name="BR"		svalue="FD*3 BPU CWB*3"	/>
	<adef name="LD"		svalue="FD*3 CARB CACC CWB*3"	/>
	<adef name="ST"		svalue="FD*3 CARB CACC CWB*3"	/>
	<adef name="CMP"	svalue="FD*3 IU CWB*3"	/>
	<adef name="COND"	svalue="FD*3 IU CWB*3"	/>
	<adef name="DIV"	svalue="FD*3 IU^36 CWB*3" />
	<adef name="FLT"	svalue="FD*3 FPM FPA CWB*3"	/>
	<adef name="FLT4"	svalue="FD*3 FPM FPA CWB*3"	/>
	<adef name="FCMP"	svalue="FD*3 FPM FPA CWB*3"	/>
	<adef name="FDIVS"	svalue="FD*3 (FPM+FPA)^17 CWB*3"	/>
	<adef name="FDIV"	svalue="FD*3 (FPM+FPA)^33 CWB*3"	/>
	<adef name="MULI"	svalue="FD*3 IU^5 CWB*3" />
	<adef name="MUL"	svalue="FD*3 IU^10 CWB*3"/>
	<adef name="FSPR"	svalue="FD*3 IU CWB*3"	/>
	<adef name="TSPR"	svalue="FD*3 IU CWB*3"	/>
	<adef name="VLD"	svalue="FD*3 CARB CACC CWB*3"	/>
	<!-- A 601 has no AltiVec unit -->
	<adef name="VEC"	svalue="Pipe601.NOTI" />
	<adef name="VFP"	svalue="Pipe601.NOTI" />
	<adef name="VCI"	svalue="Pipe601.NOTI" />
	<!-- A 601 has no SPE unit -->
	<adef name="MU"		svalue="Pipe601.NOTI" />
	<adef name="MU2"	svalue="Pipe601.NOTI" />
	<adef name="MU3"	svalue="Pipe601.NOTI" />
	<adef name="SU1"	svalue="Pipe601.NOTI" />
	<adef name="DEF1"	svalue="Pipe601.NOTI" />
	<adef name="MU4"	svalue="Pipe601.NOTI" />
	<adef name="MU6"	svalue="Pipe601.NOTI" />
    </atable>
    <atable name="Pipe603">
        <!-- Documentation: PowerPC 603 RISC Microprocessor Technical Summary, MPC603/D, 6/94, REV 3 -->
    	<!-- Pipeline is always FETCH DECODE EXECUTE COMPLETE WRITEBACK	-->
    	<!-- FD stands for the common prefix FETCH DECODE.		-->
        <!-- Fetch, Dispatch: Only one of each unit
        exists but maximum two-instruction throughput per clock cycle. --> 
	<adef name="NOTI"	svalue="FD*2"	/>
	<adef name="DEF"	svalue="FD*2 IU"	/>
	<adef name="BR"		svalue="FD*2 BPU"	/>
	<adef name="LD"		svalue="FD*2 LSU1 LSU2"	/>
	<adef name="ST"		svalue="FD*2 LSU1 LSU2"	/>
	<adef name="CMP"	svalue="FD*2 IU"	/>
	<adef name="COND"	svalue="FD*2 IU"	/>
	<adef name="DIV"	svalue="FD*2 IU^12"	/>
	<adef name="FLT"	svalue="FD*2 FPU1 FPU2 FPU3"	/>
	<adef name="FLT4"	svalue="FD*2 FPU1 FPU2 FPU3"	/>
	<adef name="FCMP"	svalue="FD*2 FPU1 FPU2 FPU3"	/>
	<adef name="FDIVS"	svalue="FD*2 (FPU1+FPU2+FPU3)^18"	/>
	<adef name="FDIV"	svalue="FD*2 (FPU1+FPU2+FPU3)^33"	/>
	<adef name="MULI"	svalue="FD*2 IU^3"	/>
	<adef name="MUL"	svalue="FD*2 IU^4"	/>
	<adef name="FSPR"	svalue="FD*2 SRU"	/>
	<adef name="TSPR"	svalue="FD*2 SRU"	/>
	<adef name="VLD"	svalue="FD*2 LSU1 LSU2"	/>
	<!-- A 603 does	not have an AltiVec unit but define a default anyway -->
	<adef name="VEC"	svalue="FD*2 AltiVec.VEC"	/>
	<adef name="VFP"	svalue="FD*2 AltiVec.VFP"	/>
	<adef name="VCI"	svalue="FD*2 AltiVec.VCI"	/>
	<!-- A 603 has no SPE unit but define a default anyway	-->
	<adef name="MU"		svalue="FD*2 SpeV1.MU"	/>
	<adef name="MU2"	svalue="FD*2 SpeV1.MU2"	/>
	<adef name="MU3"	svalue="FD*2 SpeV1.MU3"	/>
	<adef name="SU1"	svalue="FD*2 SpeV1.SU1"	/>
	<adef name="DEF1"	svalue="FD*2 SpeV1.DEF1"	/>
	<adef name="MU4"	svalue="FD*2 SpeV1.MU4"	/>
	<adef name="MU6"	svalue="FD*2 SpeV1.MU6"	/>
	<!-- factor into groups for DFA compression -->
	<adef name="GROUP0"	svalue="FD*2"	/>
	<adef name="GROUP1"	svalue="IU FPU1 FPU2 FPU3 BPU SRU LSU1 LSU2"	/>
	<!-- The rest of the functional units will be automatically gathered into another group -->
    </atable>

    <atable name="Pipe604">
        <!-- Documentation: -->
	<!-- 1) AI: MPC604.pdf: Advance Information, PowerPC 604 RISC Microprocessor Technical Summary, 5/94 REV 1, Freescale Semiconductor, Inc. -->
	<!-- 2) UM: PowerPc 604, RISC Microprocessor User's Manual, MPC604MU/AD 11/94 IBM Microelectronics PowerPC Motorola -->
    	<!-- FD stands for the common prefix FETCH DECODE DISPATCH.	-->
	<!-- Integer divide instructions iterate in stage two of multiplier (AI, p31) -->
	<!--  fres, mtbsf0, mtfsb1, mtfsfi, mrrs, mtfsf, unlike the other instructions with ic=IC.FLT, block the floating-point unit pipeline until they complete execution, thereby inhibiting the dispatch of additional floating-point instructions (Doc p6-24). However they are not used in comp/target/power/power.nd -->
	<adef name="NOTI"	svalue="FD*4"	/>
	<adef name="DEF"	svalue="FD*4 (SCIU0|SCIU1)" />
	<adef name="BR"		svalue="FD*4 BPU"	/>
	<adef name="LD"		svalue="FD*4 LSU1 LSU2"	/>
	<adef name="ST"		svalue="FD*4 LSU1 LSU2"	/>
	<adef name="CMP"	svalue="FD*4 (SCIU0|SCIU1)"	/>
	<adef name="COND"	svalue="FD*4 BPU"	/>
	<!-- Integer divide instructions iterate on stage two of the multiplier pipeline (AI, p31) -->
	<adef name="DIV"	svalue="FD*4 MCIU0 MCIU1^18 MCIU2"	/>
	<adef name="FLT"	svalue="FD*4 FPU1 FPU2 FPU3"	/>
	<adef name="FLT4"	svalue="FD*4 FPU1 FPU2 FPU3"	/>
	<adef name="FCMP"	svalue="FD*4 FPU1 FPU2 FPU3"	/>
	<adef name="FDIVS"	svalue="FD*4 (FPU1+FPU2+FPU3)^18"	/>
	<adef name="FDIV"	svalue="FD*4 (FPU1+FPU2+FPU3)^32"	/>
	<adef name="MULI"	svalue="FD*4 MCIU0 MCIU1 MCIU2"	/>
	<!-- Integer multiplies that cannot exit early (UM, p6-46) stall for one cycle in the first stage of the pipeline.-->
	<adef name="MUL"	svalue="FD*4 MCIU0^2 MCIU1 MCIU2"	/>
	
	<!-- mfspr and mtspr can execute in parallel with multiplies and divides (AI, p31) -->
	<adef name="FSPR"	svalue="FD*4 MCIUSPR^3"	/>
	<adef name="TSPR"	svalue="FD*4 MCIUSPR"	/>
	<adef name="VLD"	svalue="FD*4 LSU1 LSU2"	/>
	<!-- A 604 has no AltiVec unit -->
	<adef name="VEC"	svalue="Pipe604.NOTI" />
	<adef name="VFP"	svalue="Pipe604.NOTI" />
	<adef name="VCI"	svalue="Pipe604.NOTI" />
	<!-- A 604 has no SPE unit -->
	<adef name="MU"		svalue="Pipe604.NOTI" />
	<adef name="MU2"	svalue="Pipe604.NOTI" />
	<adef name="MU3"	svalue="Pipe604.NOTI" />
	<adef name="SU1"	svalue="Pipe604.NOTI" />
	<adef name="DEF1"	svalue="Pipe604.NOTI" />
	<adef name="MU4"	svalue="Pipe604.NOTI" />
	<adef name="MU6"	svalue="Pipe604.NOTI" />
    </atable>

    <atable name="Pipe750">
	<!-- Documentation:  MPC750 RISC Microprocessor User’s Manual, MPC750UM/AD 8/97, PowerPc Motorola -->
	<!-- Integer multiply instructions range from 2 to 6 cycles. The highest is modelled below. -->
	<!-- Decode can dispatch a third instruction if it is a branch (Doc p6-7). -->
	<!-- Maximum latency for SRU instructions ranges from 1 to 3 cycles. The highest latency is modelled here. -->
	<!--  Unlike other IC.FLT isntructions, fres, mtbsf0, mtfsb1, mtfsfi, mrrs, mtfsf, block the floating-point unit pipeline until they complete execution, thereby inhibiting the dispatch of additional floating-point instructions (Doc p6-24). However these instructions are not used in comp/target/power/power.nd -->
	<!-- TODO: Model branch's better once we schedule across basic blocks. It looks like branch prediction occurs before dispatch. (See AI p6-10) -->
	<adef name="NOTI"	svalue="FD*2"	/>
	<adef name="DEF"	svalue="FD*2 (IU1|IU2)"	/>
	<adef name="BR"		svalue="FD*2 BPU"	/>
	<adef name="LD"		svalue="FD*2 LSU1 LSU2"	/>
	<adef name="ST"		svalue="FD*2 LSU1 LSU2"	/>
	<adef name="CMP"	svalue="FD*2 (IU1|IU2)"	/>
	<adef name="COND"	svalue="FD*2 SRU"	/>
	<adef name="MULI"	svalue="FD*2 IU1^3"	/>
	<adef name="MUL"	svalue="FD*2 IU1^6"	/>
	<adef name="DIV"	svalue="FD*2 IU1^19"	/>
	<adef name="FLT"	svalue="FD*2 FPU1 FPU2 FPU3"	/>
	<!-- Some FLT4 instructions have FPU latency of 4 with 2 iterations in 1st unit (Doc Table 6-7). FIXME: Some FLT4 instructions do not. Recategorize instructions for ppc750. -->
	<adef name="FLT4"	svalue="FD*2 FPU1^2 FPU2 FPU3"	/>
	<adef name="FCMP"	svalue="FD*2 FPU1 FPU2 FPU3"	/>
	<adef name="FDIVS"	svalue="FD*2 (FPU1+FPU2+FPU3)^17"	/>
	<adef name="FDIV"	svalue="FD*2 (FPU1+FPU2+FPU3)^31"	/>
	<adef name="FSPR"	svalue="FD*2 SRU^3"	/>
	<adef name="TSPR"	svalue="FD*2 SRU^2"	/>
	<adef name="VLD"	svalue="FD*2 LSU1 LSU2"	/>
	<!-- A 750 has no AltiVec unit -->
	<adef name="VEC"	svalue="Pipe750.NOTI" />
	<adef name="VFP"	svalue="Pipe750.NOTI" />
	<adef name="VCI"	svalue="Pipe750.NOTI" />
	<!-- A 750 has no SPE unit -->
	<adef name="MU"		svalue="Pipe750.NOTI" />
	<adef name="MU2"	svalue="Pipe750.NOTI" />
	<adef name="MU3"	svalue="Pipe750.NOTI" />
	<adef name="SU1"	svalue="Pipe750.NOTI" />
	<adef name="DEF1"	svalue="Pipe750.NOTI" />
	<adef name="MU4"	svalue="Pipe750.NOTI" />
	<adef name="MU6"	svalue="Pipe750.NOTI" />
    </atable>

    <atable name="Pipe7400">
        <!-- Documentation: Freescale MPC7400UM.pdf: MPC7400 Risc Microprocessor User's Manual, Rev. 0, 3/2000 -->
    	<!-- Pipeline is always FETCH DECODE EXECUTE COMPLETE WRITEBACK	-->
    	<!-- FD stands for the common prefix FETCH DECODE.		-->
	<adef name="NOTI"	svalue="FD*2 CWB*2"	/>
	<adef name="DEF"	svalue="FD*2 IU1|IU2 CWB*2"	/>
	<adef name="BR"		svalue="FD*2 BPU CWB*2"	/>
	<adef name="LD"		svalue="FD*2 LSU1 LSU2 CWB*2"	/>
	<adef name="ST"		svalue="FD*2 LSU1 LSU2 CWB*2"	/>
	<adef name="CMP"	svalue="FD*2 IU1|IU2 IL CWB*2"	/>
	<adef name="COND"	svalue="FD*2 SRU CWB*2"	/>
	<adef name="MULI"	svalue="FD*2 IU1^3 CWB*2"	/>
	<adef name="MUL"	svalue="FD*2 IU1^6 CWB*2"	/>
	<adef name="DIV"	svalue="FD*2 IU1^19 CWB*2"	/>
	<adef name="FLT"	svalue="FD*2 FPU1 FPU2 FPU3 CWB*2"	/>
	<adef name="FLT4"	svalue="FD*2 FPU1 FPU2 FPU3 CWB*2"	/>
	<adef name="FCMP"	svalue="FD*2 FPU1 FPU2 FPU3 CWB*2"	/>
	<adef name="FDIVS"	svalue="FD*2 (FPU1+FPU2+FPU3)^17 CWB*2"	/>
	<adef name="FDIV"	svalue="FD*2 (FPU1+FPU2+FPU3)^31 CWB*2"	/>
	<adef name="FSPR"	svalue="FD*2 SRU CWB*2"	/>
	<adef name="TSPR"	svalue="FD*2 SRU CWB*2"	/>
	<adef name="VLD"	svalue="FD*2 LSU1 LSU2 CWB*2"	/>
	<adef name="VEC"	svalue="FD*2 AltiVec.VEC CWB*2"	/>
	<adef name="VFP"	svalue="FD*2 AltiVec.VFP CWB*2"	/>
	<adef name="VCI"	svalue="FD*2 AltiVec.VCI CWB*2"	/>
	<!-- A 7400 has no SPE unit -->
	<adef name="MU"		svalue="Pipe7400.NOTI"	/>
	<adef name="MU2"	svalue="Pipe7400.NOTI"	/>
	<adef name="MU3"	svalue="Pipe7400.NOTI"	/>
	<adef name="SU1"	svalue="Pipe7400.NOTI"	/>
	<adef name="DEF1"	svalue="Pipe7400.NOTI"	/>
	<adef name="MU4"	svalue="Pipe7400.NOTI"	/>
	<adef name="MU6"	svalue="Pipe7400.NOTI"	/>

	<!-- factor into groups for DFA compression -->
	<adef name="GROUP0"	svalue="FD*2"	/>
	<!-- The rest of the functional units will be automatically gathered into another group -->
    </atable>

    <atable name="PipeG4e">
	<!-- Documentation: MPC7450 RISC Microprocessor Family Reference Manual Rev. 5, 1/2005-->
	<!-- The 7450 can dispatch three instructions simultaneously. -->
    	<!-- Pipeline is always FETCH DECODE EXECUTE COMPLETE WRITEBACK	-->
    	<!-- FD stands for the common prefix FETCH DECODE.		-->
        <!-- TODO: Put two-cycle IU instructions (currently of IC.DEF) into a separate instruction class. Doc p6-4: Note that all IU1 instructions execute in 1 cycle, except for some instructions like tw[i] and sraw[i][.], which take 2 cycles. See Table 6-5 for details.-->
	<adef name="NOTI"	svalue="FD*3"	/>
	<adef name="DEF"	svalue="FD*3 (IU1a|IU1b|IU1c)"	/>
	<adef name="BR"		svalue="FD*3 BPU"	/>
	<adef name="LD"		svalue="FD*3 LSU1 LSU2 LSU3"	/>
	<adef name="ST"		svalue="FD*3 LSU1 LSU2 LSU3"	/>
	<adef name="CMP"	svalue="FD*3 (IU1a|IU1b|IU1c)"	/>
	<adef name="COND"	svalue="FD*3 IU2E0 IU2E1 IU2E2 FIN"	/>
	<adef name="DIV"	svalue="FD*3 (IU2E0+IU2E1+IU2E2)^23 FIN"	/>
	<adef name="FLT"	svalue="FD*3 FPU1 FPU2 FPU3 FPU4 FPU5 FIN"	/>
	<adef name="FLT4"	svalue="FD*3 FPU1 FPU2 FPU3 FPU4 FPU5 FIN"	/>
	<adef name="FCMP"	svalue="FD*3 FPU1 FPU2 FPU3 FPU4 FPU5 FIN"	/>
	<adef name="FDIVS"	svalue="FD*3 (FPU1+FPU2+FPU3+FPU4+FPU5)^21 FIN"	/>
	<adef name="FDIV"	svalue="FD*3 (FPU1+FPU2+FPU3+FPU4+FPU5)^35 FIN"	/>
	<adef name="MULI"	svalue="FD*3 IU2E0 IU2E1 IU2E2 FIN"	/>
	<adef name="MUL"	svalue="FD*3 (IU2E0+IU2E1+IU2E2)^4 FIN"	/>
	<adef name="FSPR"	svalue="FD*3 IU2E0 IU2E1 IU2E2 FIN"	/>
	<adef name="TSPR"	svalue="FD*3 IU2E0 IU2E1 IU2E2 FIN"	/>
	<adef name="VLD"	svalue="FD*3 LSU1 LSU2 LSU3"	/>
	<adef name="VEC"	svalue="FD*3 AltiVec.VEC"	/>
	<adef name="VFP"	svalue="FD*3 AltiVec.VFP"	/>
	<adef name="VCI"	svalue="FD*3 AltiVec.VCI"	/>
	<!-- A G4 has no SPE unit -->
	<adef name="MU"		svalue="PipeG4e.NOTI" />
	<adef name="MU2"	svalue="PipeG4e.NOTI" />
	<adef name="MU3"	svalue="PipeG4e.NOTI" />
	<adef name="SU1"	svalue="PipeG4e.NOTI" />
	<adef name="DEF1"	svalue="PipeG4e.NOTI" />
	<adef name="MU4"	svalue="PipeG4e.NOTI" />
	<adef name="MU6"	svalue="PipeG4e.NOTI" />

	<!-- factor into groups for DFA compression -->
	<adef name="GROUP0"	svalue="FD*3"	/>
	<adef name="GROUP1"	svalue="BPU IU*2 IU1a IU1b IU1c IU2E0 IU2E1 IU2E2"	/>
	<adef name="GROUP2"	svalue="LSU1 LSU2 LSU3 FPU1 FPU2 FPU3 FPU4 FPU5 FIN"	/>
	<!-- The rest of the functional units will be automatically gathered into another group -->
    </atable>

<!-- ====================================================================== -->
<!-- Notes on E200 Core Descriptions -->
<!-- ====================================================================== -->

<!-- --------------------------------------------------------------------- -->
<!-- Information for e200z0, e200z1, e200z3, and e200z6. -->

<!-- These cores are single-issue.  -->

<!-- Fetch unit can process one 32-bit instruction or up to two 16-bit instruction per cycle, but their Decode unit can decode only one instruction per cycle. -->

<!-- Pipeline is always FETCH DECODE EXECUTE WRITEBACK	-->
<!-- FD stands for the common prefix FETCH DECODE.		-->
<!-- Complete and Writeback stages are not modelled because they do not constain when results are ready. -->
<!-- For integer divide instructions and for e200z0 multiply instructions, cycles required in IU vary and depend on operand data. In below E200 core descriptions, DIV,MUL, and MULI are given the pessimistic assumption of highest number of cycles in the IU. -->

<!-- --------------------------------------------------------------------- -->
<!-- Information for e200z4 and e200z7 -->

<!-- These cores are dual issue -->

<!-- TODO: In doc, Section 4.3, there is a FeedForward pipeline stage for DEF and other instruction classes which takes a cycle. Is this a resource to model? -->
<!--  Up to two 32-bit instructions or four 16-bit instructions are fetched
each cycle. A pair of instructions can be decoded each cycle. Up to 3 results can be simultaneously written depending on the size of the result. --> 

<!-- In e200z7, FD stands for the common prefix for Fetch0 Fetch1 Fetch2 Decode0 Decode1. In e200z4, FD stands for the common prefix for Fetch Decode. -->

<!-- There are two Integer Execution pipes, each consisting of two stages (in e200z4) or four stages (in e200z7). We assume a blocking divide occupies both of these pipes. -->

<!-- --------------------------------------------------------------------- -->
<!-- Load/Store Pipeline Information for e200z0, e200z1, e200z3, e200z4, e200z6: -->
<!--  If Effective Address calculation of LD/ST depends on preceding instruction, then there is a stall at D/EA, so LD/ST waits for the preceding instruction in order to do its EA calculation.  All e200 LD/ST pipelines are modelled in the most optimistic case, that is, with no stall. TODO: model this more accurately by modelling where in the pipeline inputs are needed and where outputs are ready. -->

<!-- --------------------------------------------------------------------- -->
<!-- FSPR/TSPR Execution Units for e200z0, e200z1, e200z3, e200z4, e200z6 e200z7 -->
<!-- In z0,z1,z3,z6, there is one "unit" that supports all these instructions. In z4,z7, there are two "units" that support all these instructions. Although more complex than this, you could view this "unit" as the Integer Unit. (Jeff Scott, Freescale, 08/14/2009) -->

<!-- --------------------------------------------------------------------- -->
<!-- Execution Unit Use for Blocking Divide in e200z0, e200z1, e200z3, e200z4, e200z6 e200z7 -->
<!-- -->
<!-- While a divide is in progress, Fetch and Decode proceed, but nothing issues to the execute stages of the pipe. This includes the Integer, Multiply, Memory and Branch Units. (Jeff Scott, Freescale, 08/14/2009)-->

<!-- --------------------------------------------------------------------- -->
<!-- Branch Unit Latencies for e200z0, e200z1, e200z3, e200z6, e200z4, e200z7: -->
<!-- Branches range from 1 to 6 cycles, depending on architecture. In each case, the highest value is modelled. -->

<!-- ====================================================================== -->


    <atable name="PipeE200z0">
        <!-- Documentation: Freescale e200z0RM.pdf: e200z0 Power Architecture Core Reference Manual, e200z0coreRM, Rev. 0, 4/2008, Freescale Semiconductor, Inc. -->
	<!-- See 'Notes on E200 Core Descriptions' in this file. -->
	<!-- Integer divide instructions require between 5 to 34 execution unit cycles . Multiply instructions require from 1 to 4 execution unit cycles -->
	<adef name="NOTI"	svalue="FD"	/>
	<adef name="DEF"	svalue="FD IU"	/>
	<adef name="BR"		svalue="FD BPU^2"	/>
	<adef name="LD"		svalue="FD MEM"	/>
	<adef name="ST"		svalue="FD MEM"	/>
	<adef name="CMP"	svalue="FD IU"	/>
	<adef name="COND"	svalue="FD IU"	/>
	<adef name="DIV"	svalue="FD (IU+MEM+BPU)^34"	/>
	<adef name="FLT"	svalue="PipeE200z0.NOTI"	/>
	<adef name="FLT4"	svalue="PipeE200z0.NOTI"	/>
	<adef name="FCMP"	svalue="PipeE200z0.NOTI"	/>
	<adef name="FDIVS"	svalue="PipeE200z0.NOTI"	/>
	<adef name="FDIV"	svalue="PipeE200z0.NOTI"	/>
	<adef name="MULI"	svalue="FD IU^4"	/>
	<adef name="MUL"	svalue="FD IU^4"	/>
	<adef name="FSPR"	svalue="FD IU"	/>
	<adef name="TSPR"	svalue="FD IU"	/>
	<adef name="VLD"	svalue="FD MEM"	/>
	<adef name="VEC"	svalue="FD AltiVec.VEC"	/>
	<adef name="VFP"	svalue="FD AltiVec.VFP"	/>
	<adef name="VCI"	svalue="FD AltiVec.VCI"	/>
	<adef name="MU"		svalue="FD SpeV1.MU"	/>
	<adef name="MU2"	svalue="FD SpeV1.MU2"	/>
	<adef name="MU3"	svalue="FD SpeV1.MU3"	/>
	<adef name="SU1"	svalue="FD SpeV1.SU1"	/>
	<adef name="DEF1"	svalue="FD SpeV1.DEF1"	/>
	<adef name="MU4"	svalue="FD SpeV1.MU4"	/>
	<adef name="MU6"	svalue="FD SpeV1.MU6"	/>
	<adef name="SPED"	svalue="PipeE200z0.NOTI"	/>
	<!-- Everything in 1 group -->
    </atable>

    <atable name="PipeE200z1">
        <!-- Documentation: Freescale e200z1RM.pdf: e200z1 Power Architecture Core Reference Manual, e200z1RM,  Rev. 0, 9/2008, Freescale Semiconductor, Inc. -->
	<!-- See 'Notes on E200 Core Descriptions' in this file. -->
	<!-- Integer divide instructions require between 6 to 16 execution unit cycles . -->
	<adef name="NOTI"	svalue="FD"	/>
	<adef name="DEF"	svalue="FD IU"	/>
	<adef name="BR"		svalue="FD BPU^2"	/>
	<adef name="LD"		svalue="FD MEM"	/>
	<adef name="ST"		svalue="FD MEM"	/>
	<adef name="CMP"	svalue="FD IU"	/>
	<adef name="COND"	svalue="FD IU"	/>
	<adef name="DIV"	svalue="FD (IU+MEM+BPU)^16"	/>
	<adef name="FLT"	svalue="PipeE200z1.NOTI"	/>
	<adef name="FLT4"	svalue="PipeE200z1.NOTI"	/>
	<adef name="FCMP"	svalue="PipeE200z1.NOTI"	/>
	<adef name="FDIVS"	svalue="PipeE200z1.NOTI"	/>
	<adef name="FDIV"	svalue="PipeE200z1.NOTI"	/>
	<adef name="MULI"	svalue="FD IU"	/>
	<adef name="MUL"	svalue="FD IU"	/>
	<adef name="FSPR"	svalue="FD IU"	/>
	<adef name="TSPR"	svalue="FD IU"	/>
	<adef name="VEC"	svalue="FD AltiVec.VEC"	/>
	<adef name="VFP"	svalue="FD AltiVec.VFP"	/>
	<adef name="VCI"	svalue="FD AltiVec.VCI"	/>
	<adef name="VLD"	svalue="FD MEM"	/>
	<adef name="MU"		svalue="FD SpeV1.MU"	/>
	<adef name="MU2"	svalue="FD SpeV1.MU2"	/>
	<adef name="MU3"	svalue="FD SpeV1.MU3"	/>
	<adef name="SU1"	svalue="FD SpeV1.SU1"	/>
	<adef name="DEF1"	svalue="FD SpeV1.DEF1"	/>
	<adef name="MU4"	svalue="FD SpeV1.MU4"	/>
	<adef name="MU6"	svalue="FD SpeV1.MU6"	/>
	<adef name="SPED"	svalue="PipeE200z1.NOTI"	/>
	<!-- Everything in 1 group -->
    </atable>

    <atable name="PipeE200z3">
        <!-- Documentation: Freescale e200z3RM.pdf: e200z3 Power Architecture Core Reference Manual, e200z3coreRM, Rev. 2, 6/2008, Freescale Semiconductor, Inc. -->
	<!-- See 'Notes on E200 Core Descriptions' in this file. -->
	<!-- Integer divide instructions require between 6 to 16 execution unit cycles . -->
	<adef name="NOTI"	svalue="FD"	/>
	<adef name="DEF"	svalue="FD IU"	/>
	<adef name="BR"		svalue="FD BPU^2"	/>
	<adef name="LD"		svalue="FD MEM"	/>
	<adef name="ST"		svalue="FD MEM"	/>
	<adef name="CMP"	svalue="FD IU"	/>
	<adef name="COND"	svalue="FD IU"	/>
	<adef name="DIV"	svalue="FD (IU+MEM+BPU)^16"	/>
	<adef name="FLT"	svalue="PipeE200z3.NOTI"	/>
	<adef name="FLT4"	svalue="PipeE200z3.NOTI"	/>
	<adef name="FCMP"	svalue="PipeE200z3.NOTI"	/>
	<adef name="FDIVS"	svalue="PipeE200z3.NOTI"	/>
	<adef name="FDIV"	svalue="PipeE200z3.NOTI"	/>
	<adef name="MULI"	svalue="FD IU"	/>
	<adef name="MUL"	svalue="FD IU"	/>
	<adef name="FSPR"	svalue="FD IU"	/>
	<adef name="TSPR"	svalue="FD IU"	/>
	<adef name="VEC"	svalue="FD AltiVec.VEC"	/>
	<adef name="VFP"	svalue="FD AltiVec.VFP"	/>
	<adef name="VCI"	svalue="FD AltiVec.VCI"	/>
	<adef name="VLD"	svalue="FD MEM"	/>
	<adef name="MU"		svalue="FD SpeV1.MU"	/>
	<adef name="MU2"	svalue="FD SpeV1.MU2"	/>
	<adef name="MU3"	svalue="FD SpeV1.MU3"	/>
	<adef name="SU1"	svalue="FD SpeV1.SU1"	/>
	<adef name="DEF1"	svalue="FD SpeV1.DEF1"	/>
	<adef name="MU4"	svalue="FD SpeV1.MU4"	/>
	<adef name="MU6"	svalue="FD SpeV1.MU6"	/>
	<adef name="SPED"	svalue="PipeE200z3.NOTI"	/>
    </atable>

    <atable name="PipeE200z6">
        <!-- Documentation: Freescale e200z6_RM.pdf: e200z6 PowerPC Core Reference Manual, e200z6RM, Rev. 0, 6/2004, Freescale Semiconductor, Inc.-->
	<!-- See 'Notes on E200 Core Descriptions' in this file. -->
	<!-- Integer divide instructions require between 4 to 14 execution unit cycles . -->
	<!-- FD stands for the common prefix FETCH0 FETCH1 DECODE.		-->
	<adef name="NOTI"	svalue="FD"	/>
	<adef name="DEF"	svalue="FD IU"	/>
	<adef name="BR"		svalue="FD BPU^3"	/>
	<adef name="LD"		svalue="FD MEM"	/>
	<adef name="ST"		svalue="FD MEM"	/>
	<adef name="CMP"	svalue="FD IU"	/>
	<adef name="COND"	svalue="FD IU"	/>
	<adef name="DIV"	svalue="FD (IU+MEM+BPU)^16"	/>
	<adef name="FLT"	svalue="PipeE200z6.NOTI"	/>
	<adef name="FLT4"	svalue="PipeE200z6.NOTI"	/>
	<adef name="FCMP"	svalue="PipeE200z6.NOTI"	/>
	<adef name="FDIVS"	svalue="PipeE200z6.NOTI"	/>
	<adef name="FDIV"	svalue="PipeE200z6.NOTI"	/>
	<adef name="MULI"	svalue="FD IU"	/>
	<adef name="MUL"	svalue="FD IU"	/>
	<adef name="FSPR"	svalue="FD IU"	/>
	<adef name="TSPR"	svalue="FD IU"	/>
	<adef name="VEC"	svalue="FD AltiVec.VEC"	/>
	<adef name="VFP"	svalue="FD AltiVec.VFP"	/>
	<adef name="VCI"	svalue="FD AltiVec.VCI"	/>
	<adef name="VLD"	svalue="FD MEM"	/>
	<adef name="MU"		svalue="FD SpeV1.MU"	/>
	<adef name="MU2"	svalue="FD SpeV1.MU2"	/>
	<adef name="MU3"	svalue="FD SpeV1.MU3"	/>
	<adef name="SU1"	svalue="FD SpeV1.SU1"	/>
	<adef name="DEF1"	svalue="FD SpeV1.DEF1"	/>
	<adef name="MU4"	svalue="FD SpeV1.MU4"	/>
	<adef name="MU6"	svalue="FD SpeV1.MU6"	/>
	<adef name="SPED"	svalue="PipeE200z6.NOTI"	/>

    </atable>

    <atable name="PipeE200z4">
	<!-- Documentation: Freescale Zen z446n3 Embedded Processor Implementation Definition, Rev. 0.61, Sept. 19, 2008, Freescale Semiconductor, Inc. -->
	<!-- See 'Notes on E200 Core Descriptions' in this file. -->
	<!-- Integer divide instructions require between 4 to 14 execution unit cycles . -->
	<adef name="NOTI"	svalue="FD*2"	/>
	<adef name="DEF"	svalue="FD*2 (IU0E0|IU1E0)"	/>
	<adef name="BR"		svalue="FD*2 BPU^3"	/>
	<adef name="LD"		svalue="FD*2 MEM0 MEM1"	/>
	<adef name="ST"		svalue="FD*2 MEM0 MEM1"	/>
	<adef name="CMP"	svalue="FD*2 (IU0E0|IU1E0)"	/>
	<adef name="COND"	svalue="FD*2 (IU0E0|IU1E0)"	/>
	<adef name="DIV"	svalue="FD*2 (IU0E0+IU0E1+IU1E0+IU1E1+MEM0+MEM1+BPU)^14"	/>
	<adef name="FLT"	svalue="PipeE200z4.NOTI"	/>
	<adef name="FLT4"	svalue="PipeE200z4.NOTI"	/>
	<adef name="FCMP"	svalue="PipeE200z4.NOTI"	/>
	<adef name="FDIVS"	svalue="PipeE200z4.NOTI"	/>
	<adef name="FDIV"	svalue="PipeE200z4.NOTI"	/>
	<adef name="MULI"	svalue="FD*2 (IU0E0|IU1E0) (IU0E1|IU1E1)"	/>
	<adef name="MUL"	svalue="FD*2 (IU0E0|IU1E0) (IU0E1|IU1E1)"	/>
	<adef name="FSPR"	svalue="FD*2 (IU0E0|IU1E0)"	/>
	<adef name="TSPR"	svalue="FD*2 (IU0E0|IU1E0)"	/>
	<adef name="VEC"	svalue="FD*2 AltiVec.VEC"	/>
	<adef name="VFP"	svalue="FD*2 AltiVec.VFP"	/>
	<adef name="VCI"	svalue="FD*2 AltiVec.VCI"	/>
	<adef name="VLD"	svalue="FD*2 MEM0 MEM1"	/>
	<adef name="MU"		svalue="FD*2 SpeV1.MU"	/>
	<adef name="MU2"	svalue="FD*2 SpeV1.MU2"	/>
	<adef name="MU3"	svalue="FD*2 SpeV1.MU3"	/>
	<adef name="SU1"	svalue="FD*2 SpeV1.SU1"	/>
	<adef name="DEF1"	svalue="FD*2 SpeV1.DEF1"	/>
	<adef name="MU4"	svalue="FD*2 SpeV1.MU4"	/>
	<adef name="MU6"	svalue="FD*2 SpeV1.MU6"	/>
	<adef name="SPED"	svalue="PipeE200z4.NOTI"	/>
    </atable>

    <atable name="PipeE200z7">
	<!-- Documentation: Zen z760n3 Embedded Processor Implementation Definition Rev 1.71 - July 17, 2009, PRELIMINARY DRAFT, Freescale Semiconductor, Inc.-->
	<!-- See 'Notes on E200 Core Descriptions' in this file. -->
	<!-- Integer divide instructions require between 4 to 15 execution unit cycles. -->
	<adef name="NOTI"	svalue="FD*2"	/>
	<adef name="DEF"	svalue="FD*2 (IU0E0|IU1E0)"	/>
	<adef name="BR"		svalue="FD*2 BPU^6"	/>
	<adef name="LD"		svalue="FD*2 MEM0 MEM1 MEM2"	/>
	<adef name="ST"		svalue="FD*2 MEM0 MEM1 MEM2"	/>
	<adef name="CMP"	svalue="FD*2 (IU0E0|IU1E0)"	/>
	<adef name="COND"	svalue="FD*2 (IU0E0|IU1E0)"	/>
	<adef name="DIV"	svalue="FD*2 (IU0E0+IU0E1+IU0E2+IU0E3+IU1E0+IU1E1+IU1E2+IU1E3+MEM0+MEM1+MEM2+BPU)^15"	/>
	<adef name="FLT"	svalue="PipeE200z7.NOTI"	/>
	<adef name="FLT4"	svalue="PipeE200z7.NOTI"	/>
	<adef name="FCMP"	svalue="PipeE200z7.NOTI"	/>
	<adef name="FDIVS"	svalue="PipeE200z7.NOTI"	/>
	<adef name="FDIV"	svalue="PipeE200z7.NOTI"	/>
	<adef name="MULI"	svalue="FD*2 (IU0E0|IU1E0) (IU0E1|IU1E1) (IU0E2|IU1E2) (IU0E3|IU1E3)"	/>
	<adef name="MUL"	svalue="FD*2 (IU0E0|IU1E0) (IU0E1|IU1E1) (IU0E2|IU1E2) (IU0E3|IU1E3)"	/>
	<adef name="FSPR"	svalue="FD*2 (IU0E0|IU1E0)"	/>
	<adef name="TSPR"	svalue="FD*2 (IU0E0|IU1E0)"	/>
	<adef name="VEC"	svalue="FD*2 AltiVec.VEC"	/>
	<adef name="VFP"	svalue="FD*2 AltiVec.VFP"	/>
	<adef name="VCI"	svalue="FD*2 AltiVec.VCI"	/>
	<adef name="VLD"	svalue="FD*2 MEM0 MEM1 MEM2"	/>
	<adef name="MU"		svalue="FD*2 SpeV1.MU"	/>
	<adef name="MU2"	svalue="FD*2 SpeV1.MU2"	/>
	<adef name="MU3"	svalue="FD*2 SpeV1.MU3"	/>
	<adef name="SU1"	svalue="FD*2 SpeV1.SU1"	/>
	<adef name="DEF1"	svalue="FD*2 SpeV1.DEF1"	/>
	<adef name="MU4"	svalue="FD*2 SpeV1.MU4"	/>
	<adef name="MU6"	svalue="FD*2 SpeV1.MU6"	/>
	<adef name="SPED"	svalue="PipeE200z7.NOTI"	/>
    </atable>

<!-- ====================================================================== -->
<!-- Notes on E500v1,E500v2 Core Descriptions -->
<!-- ====================================================================== -->
<!-- Documentation: PowerPC e500 Core Family Reference Manual: Supports e500v1 e500v2, E500CORERM, Rev. 1, 4/2005, Freescale Semiconductor, Inc. -->

<!-- --------------------------------------------------------------------- -->
<!-- Pipeline Information: -->
	<!-- The e500v1 and e500v2 cores are dual-issue and have a seven-stage master pipeline. -->
	<!-- FD stands for the common prefix for Fetch0 Fetch1 Decode -->
	<!-- Complete and Writeback stages are not modelled because they do not constrain when results are ready. -->
	<!-- General Issue Queue and Branch Issue Queue are pipeline stages but not really model-able because each issues to a different SU. Also, modelling them may be redundant because Instruction Queues are constrained by number of Execution Units to which the Instruction Queues issue. -->
	<!-- e500v1 DIV, MU2, MU3 instructions have a divide bypass which is outside the four-stage MU (Multiple Unit) pipeline. Explanation is in documentation p4-27 & 4-28. -->

<!-- --------------------------------------------------------------------- -->
<!-- Execution Unit Latencies: -->
	<!-- Integer divide instructions have execution unit latency of 4, 11, 19 or 35. Below we assume highest (35). -->
	<!-- Latency of MU2 instructions in MU can be 4 or 29.  Below we assume highest (29). -->
	<!-- mfspr instructions execute in either SU1 only or [ either SU1 or SU2 ]. Below we assume SU1 only. mfspr instructions have execution latency of 1 or 4. Below we assume highest (4). -->
<!-- --------------------------------------------------------------------- -->
<!-- Double-precision scalar floating point instructions (e500v2 only) use divide bypass partially outside an additional six-stage MU pipeline. (Doc p4-27) -->

<!-- ====================================================================== --> 
    <atable name="PipeE500v1">
	<!-- See 'Notes on E500v1, E500v2 Core Descriptions' in this file. -->
	<adef name="NOTI"	svalue="FD*2"	/>
	<adef name="DEF"	svalue="FD*2 (SU1|SU2)" />
	<adef name="BR"		svalue="FD*2 BU1 BU2"	/>
	<adef name="LD"		svalue="FD*2 LSU1 LSU2 LSU3"	/>
	<adef name="ST"		svalue="FD*2 LSU1 LSU2 LSU3"	/>
	<adef name="CMP"	svalue="FD*2 (SU1|SU2)"	/>
	<adef name="COND"	svalue="FD*2 BU1 BU2" />
	<!-- Divide bypass: See 'Notes on E500v1, E500v2 Core Descriptions' in this file. -->
	<adef name="DIV"	svalue="FD*2 MU1 PREDIV^32 DIV MU4"	/>
	<adef name="FLT"	svalue="PipeE500v1.NOTI"	/>
	<adef name="FLT4"	svalue="PipeE500v1.NOTI"	/> 
	<adef name="FCMP"	svalue="PipeE500v1.NOTI"	/>
	<adef name="FDIVS"	svalue="PipeE500v1.NOTI"	/>
	<adef name="FDIV"	svalue="PipeE500v1.NOTI"	/>
	<adef name="MULI"	svalue="FD*2 MU1 MU2 MU3 MU4"	/>
	<adef name="MUL"	svalue="FD*2 MU1 MU2 MU3 MU4"	/>
	<adef name="FSPR"	svalue="FD*2 SU1^4"	/>
	<adef name="TSPR"	svalue="FD*2 SU1"	/>
	<adef name="VEC"	svalue="FD*2 AltiVec.VEC"	/>
	<adef name="VFP"	svalue="FD*2 AltiVec.VFP"	/>
	<adef name="VCI"	svalue="FD*2 AltiVec.VCI"	/>
	<adef name="VLD"	svalue="FD*2 LSU1 LSU2 LSU3"	/>
	<adef name="MU"		svalue="FD*2 SpeE500.MU"	/>
	<adef name="MU2"	svalue="FD*2 SpeE500.MU2"	/>
	<adef name="MU3"	svalue="FD*2 SpeE500.MU3"	/>
	<adef name="SU1"	svalue="FD*2 SpeE500.SU1"	/>
	<adef name="DEF1"	svalue="FD*2 SpeE500.DEF1"	/>
	<adef name="MU4"	svalue="PipeE500v1.NOTI"	/>
	<adef name="MU6"	svalue="PipeE500v1.NOTI"	/>
	<adef name="SPED"	svalue="PipeE500v1.NOTI"	/>
    </atable>

    <atable name="PipeE500v2">
	<!-- See 'Notes on E500v1, E500v2 Core Descriptions' in this file. -->
	<adef name="NOTI"	svalue="FD*2"	/>
	<adef name="DEF"	svalue="FD*2 (SU1|SU2)" />
	<adef name="BR"		svalue="FD*2 BU1 BU2"	/>
	<adef name="LD"		svalue="FD*2 LSU1 LSU2 LSU3"	/>
	<adef name="ST"		svalue="FD*2 LSU1 LSU2 LSU3"	/>
	<adef name="CMP"	svalue="FD*2 (SU1|SU2)"	/>
	<adef name="COND"	svalue="FD*2 BU1 BU2" />
	<!-- Divide bypass: See 'Notes on E500v1, E500v2 Core Descriptions' in this file. -->
	<adef name="DIV"	svalue="FD*2 MU1 PREDIV^32 DIV MU4"	/>
	<adef name="FLT"	svalue="PipeE500v2.NOTI"	/>
	<adef name="FLT4"	svalue="PipeE500v2.NOTI"	/>
	<adef name="FCMP"	svalue="PipeE500v2.NOTI"	/>
	<adef name="FDIVS"	svalue="PipeE500v2.NOTI"	/>
	<adef name="FDIV"	svalue="PipeE500v2.NOTI"	/>
	<adef name="MULI"	svalue="FD*2 MU1 MU2 MU3 MU4"	/>
	<adef name="MUL"	svalue="FD*2 MU1 MU2 MU3 MU4"	/>
	<adef name="FSPR"	svalue="FD*2 SU1^4"	/>
	<adef name="TSPR"	svalue="FD*2 SU1"	/>
	<adef name="VEC"	svalue="FD*2 AltiVec.VEC"	/>
	<adef name="VFP"	svalue="FD*2 AltiVec.VFP"	/>
	<adef name="VCI"	svalue="FD*2 AltiVec.VCI"	/>
	<adef name="VLD"	svalue="FD*2 LSU1 LSU2 LSU3"	/>
	<adef name="MU"		svalue="FD*2 SpeE500.MU"	/>
	<adef name="MU2"	svalue="FD*2 SpeE500.MU2"	/>
	<adef name="MU3"	svalue="FD*2 SpeE500.MU3"	/>
	<adef name="SU1"	svalue="FD*2 SpeE500.SU1"	/>
	<adef name="DEF1"	svalue="FD*2 SpeE500.DEF1"	/>
	<adef name="MU4"	svalue="PipeE500v2.NOTI"	/>
	<adef name="MU6"	svalue="FD*2 SpeE500.MU6"	/>
	<adef name="SPED"	svalue="FD*2 SpeE500.SPEDIV"	/>
    </atable>

    <atable name="PipeE500mc">
	<!-- Documentation: e500mc Core Reference Manual: Programming Model 
	E500MCRM, Rev. D, 03/2009 
	-->
	<!-- FD stands for the common prefix for Fetch0 Fetch1 Decode -->
	<!-- Complete and Writeback stages are not modelled because they do 
	not constrain when results are ready. -->
	<!-- Integer divide instructions have execution unit latency of 4, 11, 
	19 or 35. Below we assume the highest. -->
	<!-- TODO: Verify/Revise when we can get a document with information on 
	the latencies and execution units per instruction. 
	Things we don't know:		
		+ FSPR,TSPR: latencies and execution unit.
		+ FDIV: latency; do they block? which units are blocked?
		+ MULI: 3 or 4 cycle latency?
	-->
	<adef name="NOTI"	svalue="FD*2"	/>
	<adef name="DEF"	svalue="FD*2 (SU1|SU2)" />
	<adef name="BR"		svalue="FD*2 BU1 BU2"	/>
	<adef name="LD"		svalue="FD*2 LSU1 LSU2 LSU3"	/>
	<adef name="ST"		svalue="FD*2 LSU1 LSU2 LSU3"	/>
	<adef name="CMP"	svalue="FD*2 (SU1|SU2)"	/>
	<adef name="COND"	svalue="FD*2 BU1 BU2" />
	<!-- Divide bypass (p1-14): -->
	<adef name="DIV"	svalue="FD*2 MU1 DIV^32 POSTDIV MU4"	/>
	<adef name="FLT"	svalue="FPU1 FPU2 FPU3"	/>
	<adef name="FLT4"	svalue="FPU1 FPU2 FPU3"	/>
	<adef name="FCMP"	svalue="FPU1 FPU2 FPU3"	/>
	<!-- Guessing on FDIV* latency and blocking status. Need updated doc.-->
	<adef name="FDIVS"	svalue="(FPU1+FPU2+FPU3)^18"	/>
	<adef name="FDIV"	svalue="(FPU1+FPU2+FPU3)^32"	/>
	<adef name="MULI"	svalue="FD*2 MU1 MU2 MU3 MU4"	/>
	<adef name="MUL"	svalue="FD*2 MU1 MU2 MU3 MU4"	/>
	<!-- Guessing on *SPR latency and exec-unit. Need updated doc.-->
	<adef name="FSPR"	svalue="FD*2 SU1^4"	/>
	<adef name="TSPR"	svalue="FD*2 SU1"	/>
	<!-- E500mc has no AltiVec unit but define a default. -->
	<adef name="VEC"	svalue="FD*2 AltiVec.VEC"	/>
	<adef name="VFP"	svalue="FD*2 AltiVec.VFP"	/>
	<adef name="VCI"	svalue="FD*2 AltiVec.VCI"	/>
	<adef name="VLD"	svalue="FD*2 LSU1 LSU2 LSU3"	/>
	<!-- E500mc has no SPE unit but define a default.-->
	<adef name="MU"		svalue="FD*2 SpeV1.MU"	/>
	<adef name="MU2"	svalue="FD*2 SpeV1.MU2"	/>
	<adef name="MU3"	svalue="FD*2 SpeV1.MU3"	/>
	<adef name="SU1"	svalue="FD*2 SpeV1.SU1"	/>
	<adef name="DEF1"	svalue="FD*2 SpeV1.DEF1"	/>
	<adef name="MU4"	svalue="FD*2 SpeV1.MU4"	/>
	<adef name="MU6"	svalue="FD*2 SpeV1.MU6"	/>
    </atable>

    <atable name="PipeTitan">
    	<!-- Documentation: Titan CPU Core Optimization Guide, Rev. 1 -->
	<!-- Complete and Writeback stages are not modelled because they 
	do not constrain when results are ready. -->
	<!-- FD stands for the common seven-stage prefix: Fetch 
	Instruction-L0-Cache-Access Decode0 Decode1 Dispatch 
	Reservation-Stations Schedule -->
	<!-- Most DEF instructions have one-cycle execution latency, the case 
	which is modelled below. But rlwimi[.], rlw[i]nm[.], slw[.], sraw[i][.],
	srw[.] have two-cycle execution latency (p13). -->
	<!-- Integer divide instructions have execution unit latency of 10, 18, 
	26 or 34. Below we assume highest. -->
 	<!-- We modelled the simplest case for load/store, that of the L0 cache 
	hit. An L0 cache miss would be modelled: "AG dL0 AC dL1a dL1b DA" -->
	<!-- Single-precision multiply-accumulate instructions have 12-cycle 
	latency. The other mac instructions have 10-cycle latency (p22). Since 
	both belong to FLT4, FLT4 is modelled with 12-cycle. -->
	<adef name="NOTI"	svalue="FD*2"	/>
	<adef name="DEF"	svalue="FD*2 AD" />
	<adef name="BR"		svalue="FD*2 BEX BR"	/>
	<adef name="LD"		svalue="FD*2 AG dL0 DA"	/>
	<adef name="ST"		svalue="FD*2 AG dL0 DA"	/>
	<adef name="CMP"	svalue="FD*2 BEX"	/>
	<adef name="COND"	svalue="FD*2 BEX BR" />
	<adef name="DIV"	svalue="FD*2 (FX0+FX1+FX2+FX3)^34"	/>
	<adef name="FLT"	svalue="FP0^2 FP1^2 FP2^2 FP3^2 FP4^2" />
	<adef name="FLT4"	svalue="FP0^2 FP1^2 FP2^2 FP3^2 FP4^2 FP5^2" />
	<adef name="FCMP"	svalue="FP0^2 FP1^2 FP2^2 FP3^2 FP4^2" />
	<adef name="FDIVS"	svalue="(FP0+FP1+FP2+FP3+FP4+FP5)^46"	/>
	<adef name="FDIV"	svalue="(FP0+FP1+FP2+FP3+FP4+FP5)^72"	/>
	<adef name="MULI"	svalue="FD*2 FX0^2 FX1 FX2 FX3"	/>
	<adef name="MUL"	svalue="FD*2 FX0^2 FX1 FX2 FX3"	/>
	<adef name="FSPR"	svalue="FD*2 FX0 FX1 FX2 FX3"	/>
	<adef name="TSPR"	svalue="FD*2 FX0 FX1 FX2 FX3"	/>
	<!-- It appears Titan has no AltiVec unit but define a default. -->
	<adef name="VEC"	svalue="FD*2 AltiVec.VEC"	/>
	<adef name="VFP"	svalue="FD*2 AltiVec.VFP"	/>
	<adef name="VCI"	svalue="FD*2 AltiVec.VCI"	/>
	<adef name="VLD"	svalue="FD*2 AG dL0 DA"	/>
	<!-- It appears has no SPE unit but define a default. -->
	<adef name="MU"		svalue="FD*2 SpeV1.MU"	/>
	<adef name="MU2"	svalue="FD*2 SpeV1.MU2"	/>
	<adef name="MU3"	svalue="FD*2 SpeV1.MU3"	/>
	<adef name="SU1"	svalue="FD*2 SpeV1.SU1"	/>
	<adef name="DEF1"	svalue="FD*2 SpeV1.DEF1"	/>
	<adef name="MU4"	svalue="FD*2 SpeV1.MU4"	/>
	<adef name="MU6"	svalue="FD*2 SpeV1.MU6"	/>
    </atable>

    <!-- Resource Abbreviations: -->
    <!-- AC = Address Compare-->
    <!-- AG = Address Generate -->
    <!-- BEX = Branch Execute -->
    <!-- BPU = Branch Unit -->
    <!-- BR = Branch Resolve -->
    <!-- BU = Branch Unit -->
    <!-- CARB = Cache Arbitration -->
    <!-- CACC = Cache Access -->
    <!-- DA = Data Align -->
    <!-- dL0 = Data L0 Cache Access -->
    <!-- dL1 = Data L1 Cache Access -->
    <!-- FPA = Floating Point Add	-->
    <!-- FPM = Floating Point Multiply	-->
    <!-- FPU = Floating point unit	-->
    <!-- FXU = Fixed point unit	-->
    <!-- FXn = Fixed point unit	pipeline stage n -->
    <!-- IU 1&2 simple single cycle integer units	-->
    <!-- CIU complex multiple cycle integer units	-->
    <!-- LSU = Load store unit	-->
    <!--	EA=AddressCalc CACHE	-->
    <!-- MEM = Memory Access -->
    <!-- MU = Multiple Instruction Unit -->
    <!-- MUL = Multiply Unit -->
    <!-- VCIU = vector complex integer unit	-->
    <!-- VFPU = vector floating point unit	-->
    <!-- VIU = vector integer unit	-->
    <!-- VPU = vector permute unit	-->
    <!-- SPE = Signal processing unit details unknown	-->
    <!-- SRU = system register unit	-->
    <!-- SU = Single Instruction Unit -->
  

    <atable name="PpcInstructionClass" alias="IC" prefix="PPC_" cgen="define">
	<adef name="NOTI"	ivalue="0"	svalue="Processor.Pipeline.NOTI"	/>
	<adef name="DEF"	ivalue="1"	svalue="Processor.Pipeline.DEF"	/>
	<adef name="BR"		ivalue="2"	svalue="Processor.Pipeline.BR"	/>
	<adef name="LD"		ivalue="3"	svalue="Processor.Pipeline.LD"	/>
	<adef name="ST"		ivalue="4"	svalue="Processor.Pipeline.ST"	/>
	<adef name="CMP"	ivalue="5"	svalue="Processor.Pipeline.CMP"	/>
	<adef name="COND"	ivalue="6"	svalue="Processor.Pipeline.COND"	/>
	<adef name="DIV"	ivalue="7"	svalue="Processor.Pipeline.DIV"	/>
	<adef name="FLT"	ivalue="8"	svalue="Processor.Pipeline.FLT"	/>
	<adef name="FLT4"	ivalue="9"	svalue="Processor.Pipeline.FLT4"	/>
	<adef name="FCMP"	ivalue="10"	svalue="Processor.Pipeline.FCMP"	/>
	<adef name="FDIVS"	ivalue="11"	svalue="Processor.Pipeline.FDIVS"	/>
	<adef name="FDIV"	ivalue="12"	svalue="Processor.Pipeline.FDIV"	/>
	<adef name="MULI"	ivalue="13"	svalue="Processor.Pipeline.MULI"	/>
	<adef name="MUL"	ivalue="14"	svalue="Processor.Pipeline.MUL"	/>
	<adef name="FSPR"	ivalue="15"	svalue="Processor.Pipeline.FSPR"	/>
	<adef name="TSPR"	ivalue="16"	svalue="Processor.Pipeline.TSPR"	/>
	<adef name="VEC"	ivalue="17"	svalue="Processor.Pipeline.VEC"	/>
	<adef name="VFP"	ivalue="18"	svalue="Processor.Pipeline.VFP"	/>
	<adef name="VCI"	ivalue="19"	svalue="Processor.Pipeline.VCI"	/>
	<adef name="VLD"	ivalue="20"	svalue="Processor.Pipeline.VLD"	/>
	<adef name="MU"		ivalue="21"	svalue="Processor.Pipeline.MU"	/>
	<adef name="MU2"	ivalue="22"	svalue="Processor.Pipeline.MU2"	/>
	<adef name="MU3"	ivalue="23"	svalue="Processor.Pipeline.MU3"	/>
	<adef name="SU1"	ivalue="24"	svalue="Processor.Pipeline.SU1"	/>
	<adef name="DEF1"	ivalue="25"	svalue="Processor.Pipeline.DEF1"	/>
	<adef name="MU4"	ivalue="26"	svalue="Processor.Pipeline.MU4"	/>
	<adef name="MU6"	ivalue="27"	svalue="Processor.Pipeline.MU6"	/>
	<adef name="LAST"	ivalue="28"	svalue=""	/>
	<adef name="GROUP0"			svalue="Processor.Pipeline.GROUP0"	/>
	<adef name="GROUP1"			svalue="Processor.Pipeline.GROUP1"	/>
	<adef name="GROUP2"			svalue="Processor.Pipeline.GROUP2"	/>
	<adef name="GROUP3"			svalue="Processor.Pipeline.GROUP3"	/>
	<adef name="GROUP4"			svalue="Processor.Pipeline.GROUP4"	/>
    </atable>


    <!-- Tables to allow instruction class to vary by target -->
   <itable name="Evsubf">
        <idef name="IC"         value="IC.SU1"  />
        <cond when="Cpu.E500">
                <idef name="IC"         value="IC.MU"   />
        </cond>
    </itable>

    <itable name="Efddiv">
        <idef name="IC"         value="IC.DIV"  />
        <cond when="Cpu.E500V2">
                <idef name="IC"         value="IC.SPED" />
        </cond>
    </itable> 

    <itable name="PpcTargetFlags"	alias="PTF" prefix="PTF_" cgen="define" >
	<idef name="CONDITIONAL"	ivalue="0x000001" />
	<idef name="BC"			ivalue="0x000002" />
	<idef name="CMP"		ivalue="0x000004" />
	<idef name="CR2"		ivalue="0x000008" />
	<idef name="CR3"		ivalue="0x000010" />
	<idef name="DEF_CR0"		ivalue="0x000020" />
	<idef name="DEF_CR1"		ivalue="0x000040" />
	<idef name="DEF_CA"		ivalue="0x000080" />
	<idef name="DEF_SO_OV"		ivalue="0x000100" />
	<idef name="SEL"		ivalue="0x000200" />
	<idef name="EV64BY2"		ivalue="0x000400" />
	<idef name="EV64BY4"		ivalue="0x000800" />
	<idef name="EV64BY8"		ivalue="0x001000" />
	<idef name="FLOAT"		ivalue="0x002000" />
	<idef name="FSCVT"		ivalue="0x004000" /> <!-- STFS converts source operand to single -->
	<idef name="ICMP"		ivalue="0x008000" />

 	<!-- TODO handle CLEARUPPER with operand format string -->

	<idef name="CLEARUPPER"		ivalue="0x010000" /> <!-- Clear upper bits of constant source operand -->

	<idef name="FRAMEREQ"		ivalue="0x020000" /> <!-- Stack frame required -->
	<idef name="RFI"		ivalue="0x040000" /> <!-- Return from interrupt -->
	<idef name="D0NOTR0"		ivalue="0x080000" /> <!-- dstOpd(0) cannot be R0 -->
	<idef name="RECOMPUTE"		ivalue="0x100000" /> <!-- Instruction is recomputable -->
	<idef name="D0IS64"		ivalue="0x200000" /> <!-- dstOpd(0) is 64-bits -->
	<idef name="NOREMAT"		ivalue="0x400000" /> <!-- No special rematerialization optimizations -->
    </itable>

    <itable name="LloptPseudoOpcodes" alias="POP" prefix="PPC_POP_" cgen="define">
	<idef name="PPC"	  ivalue="POP.MAXPOP+1" />
	<idef name="CMP"	  ivalue="POP.PPC+1"	comment="Integer compare" />
	<idef name="CMPI"	  ivalue="POP.PPC+2"	comment="Integer compare immediate" />
	<idef name="CMPL"	  ivalue="POP.PPC+3"	comment="Integer compare logical" />
	<idef name="CMPLI"	  ivalue="POP.PPC+4"	comment="Integer compare logical immediate" />
	<idef name="LIS"	  ivalue="POP.PPC+5"	comment="Load immediate shifted" />
	<idef name="ADDIS"	  ivalue="POP.PPC+6"	comment="Add immediate shifted" />
	<idef name="ORIS"	  ivalue="POP.PPC+7"	comment="Or immediate shifted" />
	<idef name="XORIS"	  ivalue="POP.PPC+8"	comment="Xor immediate shifted" />
	<idef name="SUBF"	  ivalue="POP.PPC+9"	comment="Subtraction" />
	<idef name="BLR"	  ivalue="POP.PPC+10"	comment="Branch to LR" />
	<idef name="LSWI"	  ivalue="POP.PPC+11"	comment="Load string word immediate" />
	<idef name="STSWI"	  ivalue="POP.PPC+12"	comment="Store string word immediate" />
	<idef name="ADDC"	  ivalue="POP.PPC+13"	comment="Add carrying" />
	<idef name="ADDIC"	  ivalue="POP.PPC+14"	comment="Add immediate carrying" />
	<idef name="MULHW"	  ivalue="POP.PPC+15"	comment="Multiply high word" />
	<idef name="MULHWU"	  ivalue="POP.PPC+16"	comment="Multiply high word unsigned" />
	<idef name="RLWINM"	  ivalue="POP.PPC+17"	comment="Rotate left word immediate and with mask" />
	<idef name="SUBFC"	  ivalue="POP.PPC+18"	comment="Subtract from carrying" />
	<idef name="SRAW"	  ivalue="POP.PPC+19"	comment="Shift right arithmetic word" />
	<idef name="ANDIX"	  ivalue="POP.PPC+20"	comment="andi." />
	<idef name="ANDISX"	  ivalue="POP.PPC+21"	comment="andis." />
	<idef name="EVMERGEHI"	  ivalue="POP.PPC+22"	comment="evmergehi" />
	<idef name="EVMERGEHILO"  ivalue="POP.PPC+23"	comment="evmergehilo" />
	<idef name="EVMERGELO"	  ivalue="POP.PPC+24"	comment="evmergelo" />
	<idef name="EVMERGELOHI"  ivalue="POP.PPC+25"	comment="evmergelohi" />
	<idef name="MFSPR"	  ivalue="POP.PPC+26"	comment="Move from SPR" />
	<idef name="MTSPR"	  ivalue="POP.PPC+27"	comment="Move from SPR" />
	<idef name="DIAB_BTSTI"	  ivalue="POP.PPC+29"	comment="VLE bit test" />
	<idef name="DIAB_LA_HALO" ivalue="POP.PPC+30"	comment="Load address HA/LO" />
	<idef name="DIAB_SAVEM"	  ivalue="POP.PPC+31"	comment="Call prolog helper function to save registers" />
	<idef name="DIAB_RESTM"	  ivalue="POP.PPC+32"	comment="Call prolog helper function to restore registers" />
	<idef name="DIAB_LI_SPE"  ivalue="POP.PPC+33"	comment="SPE 64-bit load immediate" />
	<idef name="DIAB_LOADLA"  ivalue="POP.PPC+34"	comment="Load link reg" />
	<idef name="BSETI"	  ivalue="POP.PPC+35"	comment="Bit set immediate" />
	<idef name="D2LOCLIST"	  ivalue="POP.PPC+36"	/> <!-- TODO add directives.xml -->
	<idef name="CNTLZW"	  ivalue="POP.PPC+37"	comment="Count leading zeros word" />
	<idef name="ENDPPC"	  ivalue="POP.PPC+38" />
    </itable>

    <atable name="PpcSoRc">
	<adef name="."	def="cr0"	tflag="PTF.DEF_CR0|PTF.RECOMPUTE" />
	<adef name="o"	def="SO,OV"	tflag="PTF.DEF_SO_OV|PTF.RECOMPUTE" />
	<adef name="o." def="SO,OV,cr0" tflag="PTF.DEF_CR0|PTF.DEF_SO_OV|PTF.RECOMPUTE" />
    </atable>

    <atable name="ClassicOnly">
        <adef name="PpcRc"	svalue="PpcRc"  />
	<cond when="Processor.VLE">
	    <adef name="PpcRc"	svalue="NoPpcRc"  />
        </cond>
    </atable> 

    <atable name="NoPpcRc">
    </atable>
    <atable name="PpcRc">
	<adef name="."	def="cr0" tflag="PTF.DEF_CR0|PTF.RECOMPUTE" />
    </atable>
    <atable name="PpcFrc">
	<adef name="."	def="cr1" tflag="PTF.DEF_CR1|PTF.RECOMPUTE" />
    </atable>
    <atable name="PpcVrc">
	<adef name="."	def="cr6" />
    </atable>

    <itable name="PpcRegisterDefines" prefix="PPC_EV64_" cgen="define">
	<idef name="BASE" ivalue="0xd0" />
	<idef name="LAST" ivalue="0xef" />
    </itable>

</AttributeDefinitions>

<!-- PowerPC instruction set architecture -->

<isa arch="PPC">

    <!-- Instruction factory ND like mapping rules -->
    <!-- Nested in the ISA because there may be different rules for Ppc -->

    <popreg name="R" regclass="REGC.GPR" />	<!-- Ppc r0..r31 -->
    <popreg name="T" regclass="REGC.THUMB" />	<!-- VLE small register encodings r0..r7,r24..r31 -->
    <popreg name="F" regclass="REGC.FPR" />	<!-- Ppc f0..f31 -->
    <popreg name="V" regclass="REGC.VPR" />	<!-- Ppc v0..v31 -->
    <popreg name="S" regclass="REGC.SPR" />	<!-- Ppc special purpose (lr,ctr...) -->
    <popreg name="C" regclass="REGC.CRF" />	<!-- Ppc condition register field cr0..cr7 -->

<!-- General purpose registers -->
  <register size="32">
    <register name="r0"	 regclass="REGC.GPR|REGC.THUMB" regid="0x0"  sdb="0x0" usage="saved,temp,allocatable,preferred" />
    <register name="r1"	 regclass="REGC.GPR|REGC.THUMB" regid="0x1"  sdb="0x1" usage="saved,preserved,preferred"	/>
    <register name="sp"	 regclass="REGC.GPR|REGC.THUMB" regid="0x1"  sdb="0x1" usage="saved,preserved,preferred"	/>
    <register name="r2"	 regclass="REGC.GPR|REGC.THUMB" regid="0x2"  sdb="0x2" usage="saved,preserved,preferred" />
    <register name="r3"	 regclass="REGC.GPR|REGC.THUMB" regid="0x3"  sdb="0x3" usage="saved,temp,param,ret,allocated,allocatable,preferred" />
    <register name="r4"	 regclass="REGC.GPR|REGC.THUMB" regid="0x4"  sdb="0x4" usage="saved,temp,param,ret,allocated,allocatable,preferred" />
    <register name="r5"	 regclass="REGC.GPR|REGC.THUMB" regid="0x5"  sdb="0x5" usage="saved,temp,param,allocated,allocatable,preferred" />
    <register name="r6"	 regclass="REGC.GPR|REGC.THUMB" regid="0x6"  sdb="0x6" usage="saved,temp,param,allocated,allocatable,preferred" />
    <register name="r7"	 regclass="REGC.GPR|REGC.THUMB" regid="0x7"  sdb="0x7" usage="saved,temp,param,allocated,allocatable,preferred" />
    <register name="r8"	 regclass="REGC.GPR"		regid="0x8"  sdb="0x8" usage="saved,temp,param,allocated,allocatable" />
    <register name="r9"	 regclass="REGC.GPR"		regid="0x9"  sdb="0x9" usage="saved,temp,param,allocated,allocatable" />
    <register name="r10" regclass="REGC.GPR"		regid="0xa"  sdb="0xa" usage="saved,temp,param,allocated,allocatable" />
    <register name="r11" regclass="REGC.GPR"		regid="0xb"  sdb="0xb" usage="saved,temp,allocated,allocatable" />
    <register name="r12" regclass="REGC.GPR"		regid="0xc"  sdb="0xc" usage="saved,temp,allocated,allocatable" />
    <register name="r13" regclass="REGC.GPR"		regid="0xd"  sdb="0xd" usage="saved,preserved,allocated" />
    <register name="r14" regclass="REGC.GPR"		regid="0xe"  sdb="0xe" usage="saved,preserved,allocated,allocatable" />
    <register name="r15" regclass="REGC.GPR"		regid="0xf"  sdb="0xf" usage="saved,preserved,allocated,allocatable" />
    <register name="r16" regclass="REGC.GPR"		regid="0x10" sdb="0x10" usage="saved,preserved,allocated,allocatable" />
    <register name="r17" regclass="REGC.GPR"		regid="0x11" sdb="0x11" usage="saved,preserved,allocated,allocatable" />
    <register name="r18" regclass="REGC.GPR"		regid="0x12" sdb="0x12" usage="saved,preserved,allocated,allocatable" />
    <register name="r19" regclass="REGC.GPR"		regid="0x13" sdb="0x13" usage="saved,preserved,allocated,allocatable" />
    <register name="r20" regclass="REGC.GPR"		regid="0x14" sdb="0x14" usage="saved,preserved,allocated,allocatable" />
    <register name="r21" regclass="REGC.GPR"		regid="0x15" sdb="0x15" usage="saved,preserved,allocated,allocatable" />
    <register name="r22" regclass="REGC.GPR"		regid="0x16" sdb="0x16" usage="saved,preserved,allocated,allocatable" />
    <register name="r23" regclass="REGC.GPR"		regid="0x17" sdb="0x17" usage="saved,preserved,allocated,allocatable" />
    <register name="r24" regclass="REGC.GPR|REGC.THUMB" regid="0x18" sdb="0x18" usage="saved,preserved,allocated,allocatable,preferred" />
    <register name="r25" regclass="REGC.GPR|REGC.THUMB" regid="0x19" sdb="0x19" usage="saved,preserved,allocated,allocatable,preferred" />
    <register name="r26" regclass="REGC.GPR|REGC.THUMB" regid="0x1a" sdb="0x1a" usage="saved,preserved,allocated,allocatable,preferred" />
    <register name="r27" regclass="REGC.GPR|REGC.THUMB" regid="0x1b" sdb="0x1b" usage="saved,preserved,allocated,allocatable,preferred" />
    <register name="r28" regclass="REGC.GPR|REGC.THUMB" regid="0x1c" sdb="0x1c" usage="saved,preserved,allocated,allocatable,preferred" />
    <register name="r29" regclass="REGC.GPR|REGC.THUMB" regid="0x1d" sdb="0x1d" usage="saved,preserved,allocated,allocatable,preferred" />
    <register name="r30" regclass="REGC.GPR|REGC.THUMB" regid="0x1e" sdb="0x1e" usage="saved,preserved,allocated,allocatable,preferred" />
    <register name="r31" regclass="REGC.GPR|REGC.THUMB" regid="0x1f" sdb="0x1f" usage="saved,preserved,allocated,allocatable,preferred" />
  </register>

    <!-- Upper 32-bits in E500 register bank -->
  <register size="64">
    <register name="r0_hi"	regclass="REGC.GPR" regid="0xd0"  sdb="0x0"  usage="saved,temp" />
    <register name="r1_hi"	regclass="REGC.GPR" regid="0xd1"  sdb="0x1"  usage="saved,preserved"  />
    <register name="r2_hi"	regclass="REGC.GPR" regid="0xd2"  sdb="0x2"  usage="saved,preserved" />
    <register name="r3_hi"	regclass="REGC.GPR" regid="0xd3"  sdb="0x3"  usage="saved,temp,param,ret,allocated" />
    <register name="r4_hi"	regclass="REGC.GPR" regid="0xd4"  sdb="0x4"  usage="saved,temp,param,ret,allocated" />
    <register name="r5_hi"	regclass="REGC.GPR" regid="0xd5"  sdb="0x5"  usage="saved,temp,param,allocated" />
    <register name="r6_hi"	regclass="REGC.GPR" regid="0xd6"  sdb="0x6"  usage="saved,temp,param,allocated" />
    <register name="r7_hi"	regclass="REGC.GPR" regid="0xd7"  sdb="0x7"  usage="saved,temp,param,allocated" />
    <register name="r8_hi"	regclass="REGC.GPR" regid="0xd8"  sdb="0x8"  usage="saved,temp,param,allocated" />
    <register name="r9_hi"	regclass="REGC.GPR" regid="0xd9"  sdb="0x9"  usage="saved,temp,param,allocated" />
    <register name="r10_hi"	regclass="REGC.GPR" regid="0xda"  sdb="0xa"  usage="saved,temp,param,allocated" />
    <register name="r11_hi"	regclass="REGC.GPR" regid="0xdb"  sdb="0xb"  usage="saved,temp,allocated" />
    <register name="r12_hi"	regclass="REGC.GPR" regid="0xdc"  sdb="0xc"  usage="saved,temp,allocated" />
    <register name="r13_hi"	regclass="REGC.GPR" regid="0xdd"  sdb="0xd"  usage="saved,preserved,allocated" />
    <register name="r14_hi"	regclass="REGC.GPR" regid="0xde"  sdb="0xe"  usage="saved,preserved,allocated" />
    <register name="r15_hi"	regclass="REGC.GPR" regid="0xdf"  sdb="0xf"  usage="saved,preserved,allocated" />
    <register name="r16_hi"	regclass="REGC.GPR" regid="0xe0"  sdb="0x10" usage="saved,preserved,allocated" />
    <register name="r17_hi"	regclass="REGC.GPR" regid="0xe1"  sdb="0x11" usage="saved,preserved,allocated" />
    <register name="r18_hi"	regclass="REGC.GPR" regid="0xe2"  sdb="0x12" usage="saved,preserved,allocated" />
    <register name="r19_hi"	regclass="REGC.GPR" regid="0xe3"  sdb="0x13" usage="saved,preserved,allocated" />
    <register name="r20_hi"	regclass="REGC.GPR" regid="0xe4"  sdb="0x14" usage="saved,preserved,allocated" />
    <register name="r21_hi"	regclass="REGC.GPR" regid="0xe5"  sdb="0x15" usage="saved,preserved,allocated" />
    <register name="r22_hi"	regclass="REGC.GPR" regid="0xe6"  sdb="0x16" usage="saved,preserved,allocated" />
    <register name="r23_hi"	regclass="REGC.GPR" regid="0xe7"  sdb="0x17" usage="saved,preserved,allocated" />
    <register name="r24_hi"	regclass="REGC.GPR" regid="0xe8"  sdb="0x18" usage="saved,preserved,allocated" />
    <register name="r25_hi"	regclass="REGC.GPR" regid="0xe9"  sdb="0x19" usage="saved,preserved,allocated" />
    <register name="r26_hi"	regclass="REGC.GPR" regid="0xea"  sdb="0x1a" usage="saved,preserved,allocated" />
    <register name="r27_hi"	regclass="REGC.GPR" regid="0xeb"  sdb="0x1b" usage="saved,preserved,allocated" />
    <register name="r28_hi"	regclass="REGC.GPR" regid="0xec"  sdb="0x1c" usage="saved,preserved,allocated" />
    <register name="r29_hi"	regclass="REGC.GPR" regid="0xed"  sdb="0x1d" usage="saved,preserved,allocated" />
    <register name="r30_hi"	regclass="REGC.GPR" regid="0xee"  sdb="0x1e" usage="saved,preserved,allocated" />
    <register name="r31_hi"	regclass="REGC.GPR" regid="0xef"  sdb="0x1f" usage="saved,preserved,allocated" />
  </register>

<cond when="!Processor.VLE">
  <register size="64">
    <register name="f0"	 regclass="REGC.FPR" regid="0x20" sdb="0x20" usage="saved,temp,allocatable" />
    <register name="f1"	 regclass="REGC.FPR" regid="0x21" sdb="0x21" usage="saved,temp,param,ret,allocated,allocatable"  />
    <register name="f2"	 regclass="REGC.FPR" regid="0x22" sdb="0x22" usage="saved,temp,param,allocated,allocatable" />
    <register name="f3"	 regclass="REGC.FPR" regid="0x23" sdb="0x23" usage="saved,temp,param,allocated,allocatable" />
    <register name="f4"	 regclass="REGC.FPR" regid="0x24" sdb="0x24" usage="saved,temp,param,allocated,allocatable" />
    <register name="f5"	 regclass="REGC.FPR" regid="0x25" sdb="0x25" usage="saved,temp,param,allocated,allocatable" />
    <register name="f6"	 regclass="REGC.FPR" regid="0x26" sdb="0x26" usage="saved,temp,param,allocated,allocatable" />
    <register name="f7"	 regclass="REGC.FPR" regid="0x27" sdb="0x27" usage="saved,temp,param,allocated,allocatable" />
    <register name="f8"	 regclass="REGC.FPR" regid="0x28" sdb="0x28" usage="saved,temp,param,allocated,allocatable" />
    <register name="f9"	 regclass="REGC.FPR" regid="0x29" sdb="0x29" usage="saved,temp,allocated,allocatable" />
    <register name="f10" regclass="REGC.FPR" regid="0x2a" sdb="0x2a" usage="saved,temp,allocated,allocatable" />
    <register name="f11" regclass="REGC.FPR" regid="0x2b" sdb="0x2b" usage="saved,temp,allocated,allocatable" />
    <register name="f12" regclass="REGC.FPR" regid="0x2c" sdb="0x2c" usage="saved,temp,allocated,allocatable" />
    <register name="f13" regclass="REGC.FPR" regid="0x2d" sdb="0x2d" usage="saved,temp,allocated,allocatable" />
    <register name="f14" regclass="REGC.FPR" regid="0x2e" sdb="0x2e" usage="saved,preserved,allocated,allocatable" />
    <register name="f15" regclass="REGC.FPR" regid="0x2f" sdb="0x2f" usage="saved,preserved,allocated,allocatable" />
    <register name="f16" regclass="REGC.FPR" regid="0x30" sdb="0x30" usage="saved,preserved,allocated,allocatable" />
    <register name="f17" regclass="REGC.FPR" regid="0x31" sdb="0x31" usage="saved,preserved,allocated,allocatable" />
    <register name="f18" regclass="REGC.FPR" regid="0x32" sdb="0x32" usage="saved,preserved,allocated,allocatable" />
    <register name="f19" regclass="REGC.FPR" regid="0x33" sdb="0x33" usage="saved,preserved,allocated,allocatable" />
    <register name="f20" regclass="REGC.FPR" regid="0x34" sdb="0x34" usage="saved,preserved,allocated,allocatable" />
    <register name="f21" regclass="REGC.FPR" regid="0x35" sdb="0x35" usage="saved,preserved,allocated,allocatable" />
    <register name="f22" regclass="REGC.FPR" regid="0x36" sdb="0x36" usage="saved,preserved,allocated,allocatable" />
    <register name="f23" regclass="REGC.FPR" regid="0x37" sdb="0x37" usage="saved,preserved,allocated,allocatable" />
    <register name="f24" regclass="REGC.FPR" regid="0x38" sdb="0x38" usage="saved,preserved,allocated,allocatable" />
    <register name="f25" regclass="REGC.FPR" regid="0x39" sdb="0x39" usage="saved,preserved,allocated,allocatable" />
    <register name="f26" regclass="REGC.FPR" regid="0x3a" sdb="0x3a" usage="saved,preserved,allocated,allocatable" />
    <register name="f27" regclass="REGC.FPR" regid="0x3b" sdb="0x3b" usage="saved,preserved,allocated,allocatable" />
    <register name="f28" regclass="REGC.FPR" regid="0x3c" sdb="0x3c" usage="saved,preserved,allocated,allocatable" />
    <register name="f29" regclass="REGC.FPR" regid="0x3d" sdb="0x3d" usage="saved,preserved,allocated,allocatable" />
    <register name="f30" regclass="REGC.FPR" regid="0x3e" sdb="0x3e" usage="saved,preserved,allocated,allocatable" />
    <register name="f31" regclass="REGC.FPR" regid="0x3f" sdb="0x3f" usage="saved,preserved,allocated,allocatable" />
  </register>

  <register size="16*8">
    <register name="v0"	 regclass="REGC.VPR" regid="0x40" sdb="1124" usage="saved,temp,allocated,allocatable" />
    <register name="v1"	 regclass="REGC.VPR" regid="0x41" sdb="1125" usage="saved,temp,allocated,allocatable"  />
    <register name="v2"	 regclass="REGC.VPR" regid="0x42" sdb="1126" usage="saved,temp,param,ret,allocated,allocatable" />
    <register name="v3"	 regclass="REGC.VPR" regid="0x43" sdb="1127" usage="saved,temp,param,allocated,allocatable" />
    <register name="v4"	 regclass="REGC.VPR" regid="0x44" sdb="1128" usage="saved,temp,param,allocated,allocatable" />
    <register name="v5"	 regclass="REGC.VPR" regid="0x45" sdb="1129" usage="saved,temp,param,allocated,allocatable" />
    <register name="v6"	 regclass="REGC.VPR" regid="0x46" sdb="1130" usage="saved,temp,param,allocated,allocatable" />
    <register name="v7"	 regclass="REGC.VPR" regid="0x47" sdb="1131" usage="saved,temp,param,allocated,allocatable" />
    <register name="v8"	 regclass="REGC.VPR" regid="0x48" sdb="1132" usage="saved,temp,param,allocated,allocatable" />
    <register name="v9"	 regclass="REGC.VPR" regid="0x49" sdb="1133" usage="saved,temp,param,allocated,allocatable" />
    <register name="v10" regclass="REGC.VPR" regid="0x4a" sdb="1134" usage="saved,temp,param,allocated,allocatable" />
    <register name="v11" regclass="REGC.VPR" regid="0x4b" sdb="1135" usage="saved,temp,param,allocated,allocatable" />
    <register name="v12" regclass="REGC.VPR" regid="0x4c" sdb="1136" usage="saved,temp,param,allocated,allocatable" />
    <register name="v13" regclass="REGC.VPR" regid="0x4d" sdb="1137" usage="saved,temp,param,allocated,allocatable" />
    <register name="v14" regclass="REGC.VPR" regid="0x4e" sdb="1138" usage="saved,temp,allocated,allocatable" />
    <register name="v15" regclass="REGC.VPR" regid="0x4f" sdb="1139" usage="saved,temp,allocated,allocatable" />
    <register name="v16" regclass="REGC.VPR" regid="0x50" sdb="1140" usage="saved,temp,allocated,allocatable" />
    <register name="v17" regclass="REGC.VPR" regid="0x51" sdb="1141" usage="saved,temp,allocated,allocatable" />
    <register name="v18" regclass="REGC.VPR" regid="0x52" sdb="1142" usage="saved,temp,allocated,allocatable" />
    <register name="v19" regclass="REGC.VPR" regid="0x53" sdb="1143" usage="saved,temp,allocated,allocatable" />
    <register name="v20" regclass="REGC.VPR" regid="0x54" sdb="1144" usage="saved,preserved,allocated,allocatable" />
    <register name="v21" regclass="REGC.VPR" regid="0x55" sdb="1145" usage="saved,preserved,allocated,allocatable" />
    <register name="v22" regclass="REGC.VPR" regid="0x56" sdb="1146" usage="saved,preserved,allocated,allocatable" />
    <register name="v23" regclass="REGC.VPR" regid="0x57" sdb="1147" usage="saved,preserved,allocated,allocatable" />
    <register name="v24" regclass="REGC.VPR" regid="0x58" sdb="1148" usage="saved,preserved,allocated,allocatable" />
    <register name="v25" regclass="REGC.VPR" regid="0x59" sdb="1149" usage="saved,preserved,allocated,allocatable" />
    <register name="v26" regclass="REGC.VPR" regid="0x5a" sdb="1150" usage="saved,preserved,allocated,allocatable" />
    <register name="v27" regclass="REGC.VPR" regid="0x5b" sdb="1151" usage="saved,preserved,allocated,allocatable" />
    <register name="v28" regclass="REGC.VPR" regid="0x5c" sdb="1152" usage="saved,preserved,allocated,allocatable" />
    <register name="v29" regclass="REGC.VPR" regid="0x5d" sdb="1153" usage="saved,preserved,allocated,allocatable" />
    <register name="v30" regclass="REGC.VPR" regid="0x5e" sdb="1154" usage="saved,preserved,allocated,allocatable" />
    <register name="v31" regclass="REGC.VPR" regid="0x5f" sdb="1155" usage="saved,preserved,allocated,allocatable" />
  </register>
</cond>

    <!-- Define processor status registers			-->
  <register size="4">
    <register name="cr0" regclass="REGC.CRF" regid="0x60" usage="saved,temp" />
    <register name="cr1" regclass="REGC.CRF" regid="0x61" usage="saved,temp" />
    <register name="cr2" regclass="REGC.CRF" regid="0x62" usage="saved,preserved" />
    <register name="cr3" regclass="REGC.CRF" regid="0x63" usage="saved,preserved" />
    <register name="cr4" regclass="REGC.CRF" regid="0x64" usage="saved,preserved" />
    <register name="cr5" regclass="REGC.CRF" regid="0x65" usage="saved,temp" />
    <register name="cr6" regclass="REGC.CRF" regid="0x66" usage="saved,temp" />
    <register name="cr7" regclass="REGC.CRF" regid="0x67" usage="saved,temp" />
  </register>

    <popmap ivalue="POP.RLWINM" cost="POC.ARITH+1" rule="l=R&&r=R&&r.r=[0:31]&&r.r.r=[0:31]&&r.r.r.r=[0:31]: l(R) r(R) const(r.r) const(r.r.r) const(r.r.r.r): rlwinm $1,$2,$3,$4,$5" />

    <popmap ivalue="POP.REGCOPY" cost="POC.ARITH" rule="l=R && r=R && is_Ev64_reg(l) && is_Ev64_reg(r) : l(R) r(R) : evmergehilo $1,$2,$2" />
    <popmap ivalue="POP.REGCOPY" cost="POC.ARITH" rule="l=R && r=R : l(R) r(R) : mr $1,$2" />
    <popmap ivalue="POP.REGCOPY" cost="POC.ARITH" rule="l=R && r=S : l(R) r(S) : mfspr $1,$2" />
    <popmap ivalue="POP.REGCOPY" cost="POC.ARITH" rule="l=S && r=R : l(S) r(R) : mtspr $1,$2" />
    <popmap ivalue="POP.REGCOPY" cost="POC.ARITH" rule="l=F && r=F : l(F) r(F) : fmr $1,$2" />
    <popmap ivalue="POP.REGCOPY" cost="POC.ARITH" rule="l=C && r=C : l(C) r(C) : mcrf $1,$2" />
    <popmap ivalue="POP.REGCOPY" cost="POC.ARITH" rule="l=V && r=V : l(V) r(V) : .diab.vmr $1,$2" />

    <popmap validUntil="LLOPT.POSTEXPAND" ivalue="POP.LOADCONST" cost="POC.ARITH" rule="l=R && r=CONST: l(R) const(r): diab.li $1,$2" />

<cond when="!Processor.VLE">
    <popmap ivalue="POP.TINYLOADCONST" cost="POC.ARITH" rule="l=R && r=[-32768:32767]: l(R) const(r): li $1,$2" />	<!-- addi  d,r0,num -->
    <popmap ivalue="POP.TINYLOADCONST" cost="POC.ARITH" rule="l=R && lis(r)	 : l(R) lis(r)	: lis $1,$2" />	<!-- addis d,r0,num -->

    <popmap ivalue="POP.LOADCONST" cost="POC.ARITH" rule="l=R && r=[-32768:32767]: l(R) const(r): li $1,$2" />	<!-- addi  d,r0,num -->
    <popmap ivalue="POP.LOADCONST" cost="POC.ARITH" rule="l=R && lis(r)		 : l(R) lis(r)	: lis $1,$2" />	<!-- addis d,r0,num -->
    <popmap ivalue="POP.LOADCONST" cost="POC.ARITH*2" rule="l=R && r=CONST : l(R) const(r): lis $1,$2>>16 ; ori $1,$1,$2&0xffff" />

</cond>
<cond when="Processor.VLE">
    <popmap ivalue="POP.TINYLOADCONST" cost="POC.ARITH" rule="l=T && r=[0:127]: l(T) const(r): li $1,$2" /> <!-- se_li -->
    <popmap ivalue="POP.TINYLOADCONST" cost="POC.ARITH" rule="l=T && oneset(r): l(T) const(r): li $1,$2" />	<!-- se_bgeni -->
    <popmap ivalue="POP.TINYLOADCONST" cost="POC.ARITH" rule="l=T && bmaski(r): l(T) const(r): li $1,$2" />	<!-- se_bmaski TODO intrinsic -->

    <popmap ivalue="POP.LOADCONST" cost="POC.ARITH" rule="l=T && r=[0:127]: l(T) const(r): li $1,$2" /> <!-- se_li -->
    <popmap ivalue="POP.LOADCONST" cost="POC.ARITH" rule="l=T && oneset(r): l(T) const(r): li $1,$2" />	<!-- se_bgeni -->
    <popmap ivalue="POP.LOADCONST" cost="POC.ARITH" rule="l=T && bmaski(r): l(T) const(r): li $1,$2" />	<!-- se_bmaski TODO intrinsic -->
    <popmap ivalue="POP.LOADCONST" cost="POC.ARITH" rule="l=R && r=[-524288:524287] : l(R) const(r): li $1,$2" />	<!-- e_li TODO intrinsic -->
    <popmap ivalue="POP.LOADCONST" cost="POC.ARITH" rule="l=R && lis(r)	  : l(R) lis(r)	 : e_lis $1,$2" />	<!-- e_lis -->
</cond>

    <popmap unset="F.SIGNED" cost="POC.MEM+2" rule="l=R && noreloc(r)">
	<popmap rule="offset(r)=0 && index(r)=R">
	    <popmap ivalue="POP.LOADB" rule="base(r)=r0 : l(R) index(r)		: lbzx $1,$2,r0" />
	    <popmap ivalue="POP.LOADB" rule="base(r)=R	: l(R) base(r) index(r) : lbzx $1,$2,$3" />
	    <popmap ivalue="POP.LOADH" rule="base(r)=r0 : l(R) index(r)		: lhzx $1,$2,r0" />
	    <popmap ivalue="POP.LOADH" rule="base(r)=R	: l(R) base(r) index(r) : lhzx $1,$2,$3" />
	    <popmap ivalue="POP.LOADW" rule="base(r)=r0 : l(R) index(r)		: lwzx $1,$2,r0" />
	    <popmap ivalue="POP.LOADW" rule="base(r)=R	: l(R) base(r) index(r) : lwzx $1,$2,$3" />
	</popmap>
    </popmap>
    <popmap set="F.SIGNED" cost="POC.MEM+2" rule="l=R && noreloc(r) && offset(r)=0">
	<popmap ivalue="POP.LOADH" rule="base(r)=r0 && index(r)=R : l(R) index(r)	  : lhax $1,$2,r0" />
	<popmap ivalue="POP.LOADH" rule="base(r)=R  && index(r)=R : l(R) base(r) index(r) : lhax $1,$2,$3" />
    </popmap>

    <popmap cost="POC.MEM+2" rule="l=F && noreloc(r) && offset(r)=0">
	<popmap ivalue="POP.LOADFS" rule="base(r)=r0 && index(r)=R : l(F) index(r)	   : lfsx $1,$2,r0" />
	<popmap ivalue="POP.LOADFS" rule="base(r)=R  && index(r)=R : l(F) base(r) index(r) : lfsx $1,$2,$3" />
	<popmap ivalue="POP.LOADFD" rule="base(r)=r0 && index(r)=R : l(F) index(r)	   : lfdx $1,$2,r0" />
	<popmap ivalue="POP.LOADFD" rule="base(r)=R  && index(r)=R : l(F) base(r) index(r) : lfdx $1,$2,$3" />
    </popmap>

    <popmap cost="POC.MEM+3" rule="r=R && noreloc(l) && offset(l)=0 && index(l)=R">
	<popmap ivalue="POP.STOREB" rule="base(l)=r0 : r(R) index(l)	     : stbx $1,$2,r0" />
	<popmap ivalue="POP.STOREH" rule="base(l)=r0 : r(R) index(l)	     : sthx $1,$2,r0" />
	<popmap ivalue="POP.STOREW" rule="base(l)=r0 : r(R) index(l)	     : stwx $1,$2,r0" />
	<popmap ivalue="POP.STOREB" rule="base(l)=R  : r(R) base(l) index(l) : stbx $1,$2,$3" />
	<popmap ivalue="POP.STOREH" rule="base(l)=R  : r(R) base(l) index(l) : sthx $1,$2,$3" />
	<popmap ivalue="POP.STOREW" rule="base(l)=R  : r(R) base(l) index(l) : stwx $1,$2,$3" />
    </popmap>
    <popmap cost="POC.MEM+3" rule="r=F && noreloc(l) && offset(l)=0 && index(l)=R">
	<popmap ivalue="POP.STOREFD" rule="base(l)=r0 : r(R) index(l)	      : stfdx $1,$2,r0" />
	<popmap ivalue="POP.STOREFD" rule="base(l)=R  : r(R) base(l) index(l) : stfdx $1,$2,$3" />
	<popmap ivalue="POP.STOREFS" rule="base(l)=r0 : r(R) index(l)	      : stfsx $1,$2,r0" />
	<popmap ivalue="POP.STOREFS" rule="base(l)=R  : r(R) base(l) index(l) : stfsx $1,$2,$3" />
    </popmap>

    <popmap ivalue="POP.ADD"  cost="POC.ARITH"	 rule="l=R && r=R && r.r=0		: l(R) r(R)	      : mr $1,$2" />
<cond when="!Processor.VLE">
    <Xpopmap ivalue="POP.ADD"  cost="POC.ARITH"	 rule="l=R && r=r0 && r.r=[-32768:32767]: l(R) const(r.r)     : li $1,$2" />
    <Xpopmap ivalue="POP.ADD"  cost="POC.ARITH"	 rule="l=R && r=r0 && lis(r.r)		: l(R) lis(r.r)	      : lis $1,$2" />
</cond>
    <popmap ivalue="POP.ADD"  cost="POC.ARITH+1" rule="l=R && r=R && r!=r0 && r.r=[-32768:32767]	: l(R) r(R) const(r.r): addi $1,$2,$3" />
<cond when="!Processor.VLE">
    <popmap ivalue="POP.ADD"  cost="POC.ARITH+1" rule="l=R && r!=r0 && r=R && lis(r.r)	: l(R) r(R) lis(r.r)  : addis $1,$2,$3" />
</cond>
<cond when="Processor.VLE">
    <popmap ivalue="POP.ADD"  cost="POC.ARITH+1" rule="l=R && l=r && lis(r.r)		: l(R) r(R) lis(r.r)  : addis $1,$2,$3" />
</cond>
    <popmap ivalue="POP.ADD"  cost="POC.ARITH+1" rule="l=R && r=R && r=r.r		: l(R) r(R)	      : add $1,$2,$2" />
    <popmap ivalue="POP.ADD"  cost="POC.ARITH+2" rule="l=R && r=R && r.r=R		: l(R) r(R) r.r(R)    : add $1,$2,$3" />
    <popmap ivalue="POP.SUB"  cost="POC.ARITH"	 rule="l=R && r=R && r.r=0		: l(R) r(R)	      : mr $1,$2" />
    <popmap ivalue="POP.SUB"  cost="POC.ARITH"	 rule="l=R && r=r.r			: l(R)		      : li $1,0" />
    <popmap ivalue="POP.SUB"  cost="POC.ARITH+1" rule="l=R && r!=r0 && r=R && r.r=[0:32767]	: l(R) r(R) const(r.r): addi $1,$2,-1*$3" />
    <popmap ivalue="POP.SUB"  cost="POC.ARITH+2" rule="l=R && r=R && r.r=R		: l(R) r(R) r.r(R)    : subf $1,$3,$2" />
    <popmap ivalue="POP.AND"  cost="POC.ARITH"	 rule="l=R && r=R && r.r=0		: l(R)		      : li $1,0" />
    <popmap ivalue="POP.AND"  cost="POC.ARITH"	 rule="l=R && r=R && r.r=0xffffffff	: l(R) r(R)	      : mr $1,$2" />
    <popmap ivalue="POP.AND"  cost="POC.ARITH"	 rule="l=R && r=R && r=r.r		: l(R) r(R)	      : mr $1,$2" />

    <popmap ivalue="POP.AND"  cost="POC.ARITH+1" rule="l=R && r=R && rlwinm(r.r)       : l(R) r(R) rlwinm(r.r): rlwinm $1,$2,0,$3" />

    <popmap ivalue="POP.AND"  cost="POC.ARITH+2" rule="l=R && r=R && r.r=R	       : l(R) r(R) r.r(R)    : and $1,$2,$3" />
    <popmap ivalue="POP.OR"   cost="POC.ARITH"	 rule="l=R && r=R && r.r=0	       : l(R) r(R)	     : mr $1,$2" />
    <popmap ivalue="POP.ORIS" cost="POC.ARITH"	 rule="l=R && r=R && r.r=0	       : l(R) r(R)	     : mr $1,$2" />
    <popmap ivalue="POP.OR"   cost="POC.ARITH"	 rule="l=R && r=R && r.r=-1	       : l(R)		     : li $1,-1" />
<cond when="!Processor.VLE">
    <popmap ivalue="POP.OR"   cost="POC.ARITH+1" rule="l=R && r=R && r.r=[0:65535]     : l(R) r(R) const(r.r): ori $1,$2,$3" />
    <popmap ivalue="POP.OR"   cost="POC.ARITH+1" rule="l=R && r=R && lis(r.r)	       : l(R) r(R) lis(r.r)  : oris $1,$2,$3" />
</cond>
<cond when="Processor.VLE">
    <popmap ivalue="POP.OR"   cost="POC.ARITH+1" rule="l=R && r=l && r.r=[0:65535]     : l(R) r(R) const(r.r): ori $1,$2,$3" />
    <popmap ivalue="POP.OR"   cost="POC.ARITH+1" rule="l=R && r=l && lis(r.r)	       : l(R) r(R) lis(r.r)  : oris $1,$2,$3" />
    <popmap ivalue="POP.OR"   cost="POC.ARITH+1" rule="l=R && r=R && sci8(r.r)	       : l(R) r(R) const(r.r): ori $1,$2,$3" />
</cond>
    <popmap ivalue="POP.OR"   cost="POC.ARITH"	 rule="l=R && r=R && r=r.r	       : l(R) r(R)	     : mr $1,$2" />
    <popmap ivalue="POP.OR"   cost="POC.ARITH+2" rule="l=R && r=R && r.r=R	       : l(R) r(R) r.r(R)    : or $1,$2,$3" />
    <popmap ivalue="POP.XOR"  cost="POC.ARITH"	 rule="l=R && r=R && r.r=0	       : l(R) r(R)	     : mr $1,$2" />
    <popmap ivalue="POP.XORIS" cost="POC.ARITH"	 rule="l=R && r=R && r.r=0	       : l(R) r(R)	     : mr $1,$2" />
    <popmap ivalue="POP.XOR"  cost="POC.ARITH"	 rule="l=R && r=R && r.r=-1	       : l(R) r(R)	     : nor $1,$2,$2" />
<cond when="!Processor.VLE">
    <popmap ivalue="POP.XOR"  cost="POC.ARITH+1" rule="l=R && r=R && r.r=[0:65535]     : l(R) r(R) const(r.r): xori $1,$2,$3" />
    <popmap ivalue="POP.XOR"  cost="POC.ARITH+1" rule="l=R && r=R && lis(r.r)	       : l(R) r(R) lis(r.r)  : xoris $1,$2,$3" />
</cond>
<cond when="Processor.VLE">
    <popmap ivalue="POP.XOR"  cost="POC.ARITH+1" rule="l=R && r=R && sci8(r.r)	       : l(R) r(R) const(r.r): xori $1,$2,$3" />
</cond>
    <popmap ivalue="POP.XOR"  cost="POC.ARITH"	 rule="l=R && r=R && r=r.r	       : l(R)		     : li $1,0" />
    <popmap ivalue="POP.XOR"  cost="POC.ARITH+2" rule="l=R && r=R && r.r=R	       : l(R) r(R) r.r(R)    : xor $1,$2,$3" />
    <popmap ivalue="POP.MUL"  cost="POC.ARITH"	 rule="l=R && r=R && r.r=0	       : l(R)		     : li $1,0" />
    <popmap ivalue="POP.MUL"  cost="POC.ARITH+1" rule="l=R && r=R && r.r=-1	       : l(R) r(R)	     : neg $1,$2" />
    <popmap ivalue="POP.MUL"  cost="POC.ARITH+1" rule="l=R && r=R && r.r=2	       : l(R) r(R)	     : add $1,$2,$2" />
<cond when="!Processor.VLE">
    <popmap ivalue="POP.MUL"  cost="POC.MUL+1"	 rule="l=R && r=R && r.r=[-32768:32767]: l(R) r(R) const(r.r): mulli $1,$2,$3" />
</cond>
<cond when="Processor.VLE">
    <popmap ivalue="POP.MUL"  cost="POC.MUL+1"	 rule="l=R && l=r && r.r=[-32768:32767]: l(R) r(R) const(r.r): mulli $1,$2,$3" />
    <popmap ivalue="POP.MUL"  cost="POC.MUL+1"	 rule="l=R && r=R && sci8(r.r)	       : l(R) r(R) const(r.r): mulli $1,$2,$3" />
</cond>
    <popmap ivalue="POP.MUL"  cost="POC.MUL+1"	 rule="l=R && r=R && r=r.r	       : l(R) r(R)	     : mullw $1,$2,$2" />
    <popmap ivalue="POP.MUL"  cost="POC.MUL+2"	 rule="l=R && r=R && r.r=R	       : l(R) r(R) r.r(R)    : mullw $1,$2,$3" />

    <popmap ivalue="POP.MULHW"	cost="POC.ARITH" rule="l=R && r=R && r.r=[0:1]: l(R): li $1,0" />
    <popmap ivalue="POP.MULHWU" cost="POC.ARITH" rule="l=R && r=R && r.r=[0:1]: l(R): li $1,0" />

    <popmap ivalue="POP.DIVS" cost="POC.ARITH+1" rule="l=R && r=R && r.r=1: l(R) r(R): mr $1,$2" />
    <popmap ivalue="POP.DIVU" cost="POC.ARITH+1" rule="l=R && r=R && r.r=1: l(R) r(R): mr $1,$2" />
    <popmap ivalue="POP.DIVU" cost="POC.ARITH+1" rule="l=R && r=R && r.r=2: l(R) r(R): rlwinm $1,$2,31,1,31" />

    <popmap ivalue="POP.SHL"  cost="POC.ARITH" rule="l=R && r=R && r.r=0 : l(R) r(R) : mr $1,$2" />
    <popmap ivalue="POP.SHRL" cost="POC.ARITH" rule="l=R && r=R && r.r=0 : l(R) r(R) : mr $1,$2" />
    <popmap ivalue="POP.SHRA" cost="POC.ARITH" rule="l=R && r=R && r.r=0 : l(R) r(R) : mr $1,$2" />

    <popmap ivalue="POP.EXTSB" cost="POC.ARITH"	  rule="l=R && r=[0:127]  : l(R) const(r): li $1,$2" />
    <popmap ivalue="POP.EXTSB" cost="POC.ARITH+1" rule="l=R && r=R	  : l(R) r(R)	 : extsb $1,$2" />
    <popmap ivalue="POP.EXTSH" cost="POC.ARITH"	  rule="l=R && r=[0:32767]: l(R) const(r): li $1,$2" />
    <popmap ivalue="POP.EXTSH" cost="POC.ARITH+1" rule="l=R && r=R	  : l(R) r(R)	 : extsh $1,$2" />

    <popmap ivalue="POP.EXTZB" cost="POC.ARITH"	  rule="l=R && r=CONST	  : l(R) const(r): li $1,$2&255" />
<cond when="!Processor.VLE">
    <popmap ivalue="POP.EXTZB" cost="POC.ARITH+1" rule="l=R && r=R	  : l(R) r(R)	 : extzb $1,$2" />
    <popmap ivalue="POP.EXTZH" cost="POC.ARITH+1" rule="l=R && r=R	  : l(R) r(R)	 : extzh $1,$2" />
</cond>
<cond when="Processor.VLE">
    <popmap ivalue="POP.EXTZB" cost="POC.ARITH+1" rule="l=T && l=r	  : l(R)	 : se_extzb $1" />
    <popmap ivalue="POP.EXTZH" cost="POC.ARITH+1" rule="l=T && l=r	  : l(R)	 : se_extzh $1" />
    <popmap ivalue="POP.EXTZB" cost="POC.ARITH+1" rule="l=R && r=R	  : l(R) r(R)	 : rlwinm $1,$2,0,24,31" />
    <popmap ivalue="POP.EXTZH" cost="POC.ARITH+1" rule="l=R && r=R	  : l(R) r(R)	 : rlwinm $1,$2,0,16,31" />
</cond>

    <popmap ivalue="POP.SHL"  cost="POC.ARITH+1" rule="l=R && r=R && r.r=[1:31]: l(R) r(R) const(r.r): rlwinm $1,$2,$3,0,31-$3" />
    <popmap ivalue="POP.SHRL" cost="POC.ARITH+1" rule="l=R && r=R && r.r=[1:31]: l(R) r(R) const(r.r): rlwinm $1,$2,32-$3,$3,31" />

<!-- TODO: Needs testing -->
    <popmap ivalue="POP.SUBF" cost="POC.ARITH"	 rule="l=R && r=0 && r.r=R		: l(R) r.r(R)	      : mr $1,$2" />
    <popmap ivalue="POP.SUBF" cost="POC.ARITH+1" rule="l=R && r=[-32767:32767] && r.r=R && r.r!=r0: l(R) r.r(R) const(r): addi $1,$2,-1*$3" />
<cond when="!Processor.VLE">
    <popmap ivalue="POP.SUBFC" cost="POC.ARITH+1" rule="l=R && r=[-32767:32767] && r!=0 && r.r=R && r.r!=r0: l(R) r.r(R) const(r): addic $1,$2,-1*$3" />
    <popmap ivalue="POP.SHL"   cost="POC.ARITH+2" rule="l=R && r=l && r.r=R: l(R) r.r(R): slw $1,$1,$2" />
    <popmap ivalue="POP.SHL"   cost="POC.ARITH+3" rule="l=R && r=R && r.r=R: l(R) r(R) r.r(R): slw $1,$2,$3" />
</cond>
<cond when="Processor.VLE">
    <popmap ivalue="POP.SUBFC" cost="POC.ARITH+1" rule="l=R && sci8(r) && r!=0 && r.r=R: l(R) r.r(R) const(r): addic $1,$2,-1*$3" />
    <popmap ivalue="POP.SHL"   cost="POC.ARITH+2" rule="l=T && r=l && r.r=T: l(R) r.r(R): se_slw $1,$2" />
</cond>

    <popmap ivalue="POP.CMP" cost="POC.ARITH+1" rule="r.r.r=R && r.r.r.r=[-32767:32767]: const(r) const(r.r) r.r.r(R) const(r.r.r.r): cmpi $1,$2,$3,$4" />
    <popmap ivalue="POP.CMPL" cost="POC.ARITH+1" rule="r.r.r=R && r.r.r.r=[0:65535]: const(r) const(r.r) r.r.r(R) const(r.r.r.r): cmpli $1,$2,$3,$4" />

<!-- TODO: Add support for nested popmaps -->

    <popmap ivalue="POP.CMPW" set="F.SIGNED"   cost="POC.ARITH+1" rule="l=C&&r=R && r.r=[-32768:32767]	: l(C) r(R) const(r.r) : cmpi	$1,0,$2,$3" />
    <popmap ivalue="POP.CMPW" set="F.SIGNED"   cost="POC.ARITH+2" rule="l=C&&r=R && r.r=R		: l(C) r(R) r.r(R)     : cmp	$1,0,$2,$3" />
    <popmap ivalue="POP.CMPW" unset="F.SIGNED" cost="POC.ARITH+1" rule="l=C&&r=R && r.r=[0:65535]	: l(C) r(R) const(r.r) : cmpli	$1,0,$2,$3" />
    <popmap ivalue="POP.CMPW" unset="F.SIGNED" cost="POC.ARITH+2" rule="l=C&&r=R && r.r=R		: l(C) r(R) r.r(R)     : cmpl	$1,0,$2,$3" />
<cond when="Processor.VLE">
    <popmap  ivalue="POP.CMPH" set="F.SIGNED"	cost="POC.ARITH+1" rule="l=C&&l=cr0 && r=R && r.r=[-32768:32767]: r(R) const(r.r)    : e_cmph16i  $1,$2" />
    <popmap  ivalue="POP.CMPH" set="F.SIGNED"	cost="POC.ARITH+2" rule="l=C&&l=cr0 && r=T && r.r=T		: r(R) r.r(R)	     : se_cmph	  $1,$2" />
    <popmap  ivalue="POP.CMPH" set="F.SIGNED"	cost="POC.ARITH+2" rule="l=C&&r=R && r.r=R			: l(C) r(R) r.r(R)   : e_cmph	  $1,$2,$3" />
    <popmap  ivalue="POP.CMPH" unset="F.SIGNED" cost="POC.ARITH+1" rule="l=C&&l=cr0 && r=R && r.r=[0:65535]	: r(R) const(r.r)    : e_cmphl16i $1,$2" />
    <popmap  ivalue="POP.CMPH" unset="F.SIGNED" cost="POC.ARITH+2" rule="l=C&&l=cr0 && r=T && r.r=T		: r(R) r.r(R)	     : se_cmphl	  $1,$2" />
    <popmap  ivalue="POP.CMPH" unset="F.SIGNED" cost="POC.ARITH+2" rule="l=C&&r=R && r.r=R			: l(C) r(R) r.r(R)   : e_cmphl	  $1,$2,$3" />
</cond>



<cond when="!Processor.VLE">
    <register name="fpscr"  regclass="0"	regid="0x68" size="32" usage="saved,temp" />
    <register name="vrsave" regclass="0"	regid="0x69" size="32" usage="saved,temp" />
</cond>
  <register size="32">
    <register name="msr"    regclass="REGC.SPR" regid="0x6a" sdb="66" usage="preserved" />
    <register name="xer"    regclass="REGC.SPR" regid="0x6b" usage="saved,temp,nonvolatile"		encoding="1" sdb="1+100"  />
    <register name="lr"	    regclass="REGC.SPR" regid="0x6c" usage="saved,temp,nonvolatile"		encoding="8" sdb="8+100"  />
    <register name="ctr"    regclass="REGC.SPR" regid="0x6d" usage="saved,temp,nonvolatile,allocated"	encoding="9" sdb="9+100"  />
    <register name="pvr"    regclass="REGC.SPR" regid="0x6e" usage="preserved,nonvolatile" />
    <register name="dec"    regclass="REGC.SPR" regid="0x6f" usage="preserved" />
    <register name="sprg0"  regclass="REGC.SPR" regid="0x70" usage="preserved,nonvolatile"	encoding="272" sdb="272+100"  />
    <register name="sprg1"  regclass="REGC.SPR" regid="0x71" usage="preserved,nonvolatile"	encoding="273" sdb="273+100"  />
    <register name="sprg2"  regclass="REGC.SPR" regid="0x72" usage="preserved,nonvolatile"	encoding="274" sdb="274+100"  />
    <register name="sprg3"  regclass="REGC.SPR" regid="0x73" usage="preserved,nonvolatile"	encoding="275" sdb="275+100"  />
    <register name="sprg4"  regclass="REGC.SPR" regid="0x74" usage="preserved,nonvolatile"	encoding="276" sdb="276+100"  />
    <register name="sprg5"  regclass="REGC.SPR" regid="0x75" usage="preserved,nonvolatile"	encoding="277" sdb="277+100"  />
    <register name="sprg6"  regclass="REGC.SPR" regid="0x76" usage="preserved,nonvolatile"	encoding="278" sdb="278+100"  />
    <register name="sprg7"  regclass="REGC.SPR" regid="0x77" usage="preserved,nonvolatile"	encoding="279" sdb="279+100"  />
    <register name="bbear"  regclass="REGC.SPR" regid="0x78" usage="preserved" />
    <register name="bbtar"  regclass="REGC.SPR" regid="0x79" usage="preserved" />
    <register name="bucsr0" regclass="REGC.SPR" regid="0x7a" usage="preserved" />
    <register name="csrr0"  regclass="REGC.SPR" regid="0x7b" usage="preserved"	encoding="58" sdb="58+100"  />
    <register name="csrr1"  regclass="REGC.SPR" regid="0x7c" usage="preserved"	encoding="59" sdb="59+100"  />
    <register name="cxtr"   regclass="REGC.SPR" regid="0x7d" usage="preserved" />
    <register name="dbcr0"  regclass="REGC.SPR" regid="0x7e" usage="preserved" />
    <register name="dbcr1"  regclass="REGC.SPR" regid="0x7f" usage="preserved" />
    <register name="dbcr2"  regclass="REGC.SPR" regid="0x80" usage="preserved" />
    <register name="dbsr"   regclass="REGC.SPR" regid="0x81" usage="preserved" />
    <register name="dear"   regclass="REGC.SPR" regid="0x82" usage="preserved" />
    <register name="dvc1"   regclass="REGC.SPR" regid="0x83" usage="preserved" />
    <register name="dvc2"   regclass="REGC.SPR" regid="0x84" usage="preserved" />
    <register name="esr"    regclass="REGC.SPR" regid="0x85" usage="preserved" />
    <register name="hid0"   regclass="REGC.SPR" regid="0x86" usage="preserved"	encoding="1008" sdb="1008+100"  />
    <register name="hid1"   regclass="REGC.SPR" regid="0x87" usage="preserved"	encoding="1009" sdb="1009+100"  />
    <register name="iac1"   regclass="REGC.SPR" regid="0x88" usage="preserved" />
    <register name="iac2"   regclass="REGC.SPR" regid="0x89" usage="preserved" />
    <register name="iac3"   regclass="REGC.SPR" regid="0x8a" usage="preserved" />
    <register name="iac4"   regclass="REGC.SPR" regid="0x8b" usage="preserved" />
    <register name="iarr"   regclass="REGC.SPR" regid="0x8c" usage="preserved" />
    <register name="ivor0"  regclass="REGC.SPR" regid="0x8d" usage="preserved" />
    <register name="ivor1"  regclass="REGC.SPR" regid="0x8e" usage="preserved" />
    <register name="ivor2"  regclass="REGC.SPR" regid="0x8f" usage="preserved" />
    <register name="ivor3"  regclass="REGC.SPR" regid="0x90" usage="preserved" />
    <register name="ivor4"  regclass="REGC.SPR" regid="0x01" usage="preserved" />
    <register name="ivor5"  regclass="REGC.SPR" regid="0x92" usage="preserved" />
    <register name="ivor6"  regclass="REGC.SPR" regid="0x93" usage="preserved" />
    <register name="ivor7"  regclass="REGC.SPR" regid="0x94" usage="preserved" />
    <register name="ivor8"  regclass="REGC.SPR" regid="0x95" usage="preserved" />
    <register name="ivor9"  regclass="REGC.SPR" regid="0x96" usage="preserved" />
    <register name="ivor10" regclass="REGC.SPR" regid="0x97" usage="preserved" />
    <register name="ivor11" regclass="REGC.SPR" regid="0x98" usage="preserved" />
    <register name="ivor12" regclass="REGC.SPR" regid="0x99" usage="preserved" />
    <register name="ivor13" regclass="REGC.SPR" regid="0x9a" usage="preserved" />
    <register name="ivor14" regclass="REGC.SPR" regid="0x9b" usage="preserved" />
    <register name="ivor15" regclass="REGC.SPR" regid="0x9c" usage="preserved" />
    <register name="ivor32" regclass="REGC.SPR" regid="0x9d" usage="preserved" />
    <register name="ivor33" regclass="REGC.SPR" regid="0x9e" usage="preserved" />
    <register name="ivor34" regclass="REGC.SPR" regid="0x9f" usage="preserved" />
    <register name="ivor35" regclass="REGC.SPR" regid="0xa0" usage="preserved" />
    <register name="ivpr"   regclass="REGC.SPR" regid="0xa1" usage="preserved" />
    <register name="l1cfg0" regclass="REGC.SPR" regid="0xa2" usage="preserved" />
    <register name="l1cfg1" regclass="REGC.SPR" regid="0xa3" usage="preserved" />
    <register name="l1csr0" regclass="REGC.SPR" regid="0xa4" usage="preserved" />
    <register name="l1csr1" regclass="REGC.SPR" regid="0xa5" usage="preserved" />
    <register name="mas0"   regclass="REGC.SPR" regid="0xa6" usage="preserved" />
    <register name="mas1"   regclass="REGC.SPR" regid="0xa7" usage="preserved" />
    <register name="mas2"   regclass="REGC.SPR" regid="0xa8" usage="preserved" />
    <register name="mas3"   regclass="REGC.SPR" regid="0xa9" usage="preserved" />
    <register name="mas4"   regclass="REGC.SPR" regid="0xaa" usage="preserved" />
    <register name="mcsr"   regclass="REGC.SPR" regid="0xab" usage="preserved" />
    <register name="mcsrr0" regclass="REGC.SPR" regid="0xac" usage="saved,preserved"	encoding="570" />
    <register name="mcsrr1" regclass="REGC.SPR" regid="0xad" usage="saved,preserved"	encoding="571" />
    <register name="mmucfg" regclass="REGC.SPR" regid="0xae" usage="preserved" />
    <register name="mmucsr0" regclass="REGC.SPR" regid="0xaf" usage="preserved" />
    <register name="npidr"  regclass="REGC.SPR" regid="0xb0" usage="preserved" />
    <register name="pid0"   regclass="REGC.SPR" regid="0xb1" usage="preserved" />
    <register name="pid1"   regclass="REGC.SPR" regid="0xb2" usage="preserved" />
    <register name="pid2"   regclass="REGC.SPR" regid="0xb3" usage="preserved" />
    <register name="pir"    regclass="REGC.SPR" regid="0xb4" usage="preserved"	encoding="1023" sdb="1023+100"  />
    <register name="pmrn"   regclass="REGC.SPR" regid="0xb5" usage="preserved" />
    <register name="spefscr" regclass="REGC.SPR" regid="0xb6" usage="preserved" />
    <register name="srr0"   regclass="REGC.SPR" regid="0xb7" usage="saved,preserved"	encoding="26" sdb="26+100"  />
    <register name="srr1"   regclass="REGC.SPR" regid="0xb8" usage="saved,preserved"	encoding="27" sdb="27+100"  />
    <register name="tbl"    regclass="REGC.SPR" regid="0xb9" usage="preserved"	encoding="284" sdb="284+100"  />
    <register name="tbu"    regclass="REGC.SPR" regid="0xba" usage="preserved"	encoding="284" sdb="284+100"  />
    <register name="tcr"    regclass="REGC.SPR" regid="0xbb" usage="preserved" />
    <register name="tsr"    regclass="REGC.SPR" regid="0xbc" usage="preserved" />
    <register name="usprg0" regclass="REGC.SPR" regid="0xbd" usage="preserved" />
    <register name="decar"  regclass="REGC.SPR" regid="0xbe" usage="preserved" />
    <register name="pmc1"   regclass="REGC.SPR" regid="0xbf" usage="preserved" />
    <register name="upmc1"  regclass="REGC.SPR" regid="0xc0" usage="preserved" />
    <register name="acc"    regclass="REGC.SPR" regid="0xc1" usage="preserved" />
    <register name="dsrr0"  regclass="REGC.SPR" regid="0xc2" usage="saved,preserved"	encoding="574" sdb="574+100"  />
    <register name="dsrr1"  regclass="REGC.SPR" regid="0xc3" usage="saved,preserved"	encoding="575" sdb="575+100"  />
    <register name="gsrr0"  regclass="REGC.SPR" regid="0xc4" usage="saved,preserved"	encoding="378" sdb="378+100"  />
    <register name="gsrr1"  regclass="REGC.SPR" regid="0xc5" usage="saved,preserved"	encoding="379" sdb="379+100"  />
    <!-- E500 PMR registers -->
    <register name="pmgc0"  regclass="REGC.PMR" regid="0xf0" usage="preserved" />
    <register name="pmlca0"  regclass="REGC.PMR" regid="0xf1" usage="preserved" />
    <register name="pmlca1"  regclass="REGC.PMR" regid="0xf2" usage="preserved" />
    <register name="pmlca2"  regclass="REGC.PMR" regid="0xf3" usage="preserved" />
    <register name="pmlca3"  regclass="REGC.PMR" regid="0xf4" usage="preserved" />
    <register name="pmlcb0"  regclass="REGC.PMR" regid="0xf5" usage="preserved" />
    <register name="pmlcb1"  regclass="REGC.PMR" regid="0xf6" usage="preserved" />
    <register name="pmlcb2"  regclass="REGC.PMR" regid="0xf7" usage="preserved" />
    <register name="pmlcb3"  regclass="REGC.PMR" regid="0xf8" usage="preserved" />
    <register name="pmc0"  regclass="REGC.PMR" regid="0xf9" usage="preserved" />
    <register name="pmc1"  regclass="REGC.PMR" regid="0xfa" usage="preserved" />
    <register name="pmc2"  regclass="REGC.PMR" regid="0xfb" usage="preserved" />
    <register name="pmc3"  regclass="REGC.PMR" regid="0xfc" usage="preserved" />
	
    <register name="upmgc0"  regclass="REGC.PMR" regid="0xfd" usage="preserved" />
    <register name="upmlca0"  regclass="REGC.PMR" regid="0xfe" usage="preserved" />
    <register name="upmlca1"  regclass="REGC.PMR" regid="0xff" usage="preserved" />
    <register name="upmlca2"  regclass="REGC.PMR" regid="0x100" usage="preserved" />
    <register name="upmlca3"  regclass="REGC.PMR" regid="0x101" usage="preserved" />
    <register name="upmlcb0"  regclass="REGC.PMR" regid="0x102" usage="preserved" />
    <register name="upmlcb1"  regclass="REGC.PMR" regid="0x103" usage="preserved" />
    <register name="upmlcb2"  regclass="REGC.PMR" regid="0x104" usage="preserved" />
    <register name="upmlcb3"  regclass="REGC.PMR" regid="0x105" usage="preserved" />
    <register name="upmc0"  regclass="REGC.PMR" regid="0x106" usage="preserved" />
    <register name="upmc1"  regclass="REGC.PMR" regid="0x107" usage="preserved" />
    <register name="upmc2"  regclass="REGC.PMR" regid="0x108" usage="preserved" />
    <register name="upmc3"  regclass="REGC.PMR" regid="0x109" usage="preserved" />
  </register>

    <macro parse="PpcParseClass.DST">
	<macro name="mflr"	rule=": l(R) : mfspr $1,lr" />
	<macro name="mfctr"	rule=": l(R) : mfspr $1,ctr" />
	<macro name="mfdec"	rule=": l(R) : mfspr $1,dec" />
	<macro name="mfxer"	rule=": l(R) : mfspr $1,xer" />
	<macro name="mflr"	rule=": l(R) : mfspr $1,lr" />
	<macro name="mfctr"	rule=": l(R) : mfspr $1,ctr" />
	<macro name="mfpvr"	rule=": l(R) : mfspr $1,pvr" />
	<macro name="mfdec"	rule=": l(R) : mfspr $1,dec" />
	<macro name="mfsprg0"	rule=": l(R) : mfspr $1,sprg0" />
	<macro name="mfsprg1"	rule=": l(R) : mfspr $1,sprg1" />
	<macro name="mfsprg2"	rule=": l(R) : mfspr $1,sprg2" />
	<macro name="mfsprg3"	rule=": l(R) : mfspr $1,sprg3" />
	<macro name="mfsprg4"	rule=": l(R) : mfspr $1,sprg4" />
	<macro name="mfsprg5"	rule=": l(R) : mfspr $1,sprg5" />
	<macro name="mfsprg6"	rule=": l(R) : mfspr $1,sprg6" />
	<macro name="mfsprg7"	rule=": l(R) : mfspr $1,sprg7" />
	<macro name="mfbbear"	rule=": l(R) : mfspr $1,bbear" />
	<macro name="mfbbtar"	rule=": l(R) : mfspr $1,bbtar" />
	<macro name="mfbucsr0"	rule=": l(R) : mfspr $1,bucsr0" />
	<macro name="mfcsrr0"	rule=": l(R) : mfspr $1,csrr0" />
	<macro name="mfcsrr1"	rule=": l(R) : mfspr $1,csrr1" />
	<macro name="mfcxtr"	rule=": l(R) : mfspr $1,cxtr" />
	<macro name="mfdbcr0"	rule=": l(R) : mfspr $1,dbcr0" />
	<macro name="mfdbcr1"	rule=": l(R) : mfspr $1,dbcr1" />
	<macro name="mfdbcr2"	rule=": l(R) : mfspr $1,dbcr2" />
	<macro name="mfdbsr"	rule=": l(R) : mfspr $1,dbsr" />
	<macro name="mfdear"	rule=": l(R) : mfspr $1,dear" />
	<macro name="mfdvc1"	rule=": l(R) : mfspr $1,dvc1" />
	<macro name="mfdvc2"	rule=": l(R) : mfspr $1,dvc2" />
	<macro name="mfesr"	rule=": l(R) : mfspr $1,esr" />
	<macro name="mfhid0"	rule=": l(R) : mfspr $1,hid0" />
	<macro name="mfhid1"	rule=": l(R) : mfspr $1,hid1" />
	<macro name="mfiac1"	rule=": l(R) : mfspr $1,iac1" />
	<macro name="mfiac2"	rule=": l(R) : mfspr $1,iac2" />
	<macro name="mfiac3"	rule=": l(R) : mfspr $1,iac3" />
	<macro name="mfiac4"	rule=": l(R) : mfspr $1,iac4" />
	<macro name="mfiarr"	rule=": l(R) : mfspr $1,iarr" />
	<macro name="mfivor0"	rule=": l(R) : mfspr $1,ivor0" />
	<macro name="mfivor1"	rule=": l(R) : mfspr $1,ivor1" />
	<macro name="mfivor2"	rule=": l(R) : mfspr $1,ivor2" />
	<macro name="mfivor3"	rule=": l(R) : mfspr $1,ivor3" />
	<macro name="mfivor4"	rule=": l(R) : mfspr $1,ivor4" />
	<macro name="mfivor5"	rule=": l(R) : mfspr $1,ivor5" />
	<macro name="mfivor6"	rule=": l(R) : mfspr $1,ivor6" />
	<macro name="mfivor7"	rule=": l(R) : mfspr $1,ivor7" />
	<macro name="mfivor8"	rule=": l(R) : mfspr $1,ivor8" />
	<macro name="mfivor9"	rule=": l(R) : mfspr $1,ivor9" />
	<macro name="mfivor10"	rule=": l(R) : mfspr $1,ivor10" />
	<macro name="mfivor11"	rule=": l(R) : mfspr $1,ivor11" />
	<macro name="mfivor12"	rule=": l(R) : mfspr $1,ivor12" />
	<macro name="mfivor13"	rule=": l(R) : mfspr $1,ivor13" />
	<macro name="mfivor14"	rule=": l(R) : mfspr $1,ivor14" />
	<macro name="mfivor15"	rule=": l(R) : mfspr $1,ivor15" />
	<macro name="mfivor32"	rule=": l(R) : mfspr $1,ivor32" />
	<macro name="mfivor33"	rule=": l(R) : mfspr $1,ivor33" />
	<macro name="mfivor34"	rule=": l(R) : mfspr $1,ivor34" />
	<macro name="mfivor35"	rule=": l(R) : mfspr $1,ivor35" />
	<macro name="mfivpr"	rule=": l(R) : mfspr $1,ivpr" />
	<macro name="mfl1cfg0"	rule=": l(R) : mfspr $1,l1cfg0" />
	<macro name="mfl1cfg1"	rule=": l(R) : mfspr $1,l1cfg1" />
	<macro name="mfl1csr0"	rule=": l(R) : mfspr $1,l1csr0" />
	<macro name="mfl1csr1"	rule=": l(R) : mfspr $1,l1csr1" />
	<macro name="mfmas0"	rule=": l(R) : mfspr $1,mas0" />
	<macro name="mfmas1"	rule=": l(R) : mfspr $1,mas1" />
	<macro name="mfmas2"	rule=": l(R) : mfspr $1,mas2" />
	<macro name="mfmas3"	rule=": l(R) : mfspr $1,mas3" />
	<macro name="mfmas4"	rule=": l(R) : mfspr $1,mas4" />
	<macro name="mfmcsr"	rule=": l(R) : mfspr $1,mcsr" />
	<macro name="mfmcsrr0"	rule=": l(R) : mfspr $1,mcsrr0" />
	<macro name="mfmcsrr1"	rule=": l(R) : mfspr $1,mcsrr1" />
	<macro name="mfmmucfg"	rule=": l(R) : mfspr $1,mmucfg" />
	<macro name="mfmmucsr0"	rule=": l(R) : mfspr $1,mmucsr0" />
	<macro name="mfnpidr"	rule=": l(R) : mfspr $1,npidr" />
	<macro name="mfpid0"	rule=": l(R) : mfspr $1,pid0" />
	<macro name="mfpid0"	rule=": l(R) : mfspr $1,pid0" />
	<macro name="mfpid1"	rule=": l(R) : mfspr $1,pid1" />
	<macro name="mfpid2"	rule=": l(R) : mfspr $1,pid2" />
	<macro name="mfpir"	rule=": l(R) : mfspr $1,pir" />
	<macro name="mfpmr"	rule=": l(R) : mfspr $1,pmr" />
	<macro name="mfspefscr"	rule=": l(R) : mfspr $1,spefscr" />
	<macro name="mfsrr0"	rule=": l(R) : mfspr $1,srr0" />
	<macro name="mfsrr1"	rule=": l(R) : mfspr $1,srr1" />
	<macro name="mftcr"	rule=": l(R) : mfspr $1,tcr" />
	<macro name="mftsr"	rule=": l(R) : mfspr $1,tsr" />
	<macro name="mfusprg0"	rule=": l(R) : mfspr $1,usprg0" />
<cond when="!Processor.VLE">
	<macro name="bdnz"	rule=": l(R) : bc 16,0,$1" />
</cond>
<cond when="Processor.VLE">
	<macro name="bdnz"	rule=": l(R) : bc 2,0,$1" />
	<macro name="se_mfctr"	rule=": l(R) : mfspr $1,ctr" />
	<macro name="se_mflr"	rule=": l(R) : mfspr $1,lr" />
</cond>
    </macro>

    <macro parse="PpcParseClass.UNARY" cost="POC.ARITH" >
<cond when="Processor.VLE">
	<macro name="se_mr"	rule="l=R && r=R : l(R) r(R) : mr $1,$2" />
</cond>
    </macro>

    <macro parse="PpcParseClass.SRC2">
	<macro name="diab.spill.32"	rule="r=R && r.r=[-32768:32767]: any(r) const(r.r) framepointer(r): stw $1,$2($3)" />
	<macro name="diab.spill.64"	rule="r=R && r.r=[0:248]: any(r) const(r.r) framepointer(r): evstdd $1,$2($3)" />
	<macro name="diab.spill.32"	rule="r=F && r.r=[-32768:32767]: any(r) const(r.r) framepointer(r): stfs $1,$2($3)" />
	<macro name="diab.spill.64"	rule="r=F && r.r=[-32768:32767]: any(r) const(r.r) framepointer(r): stfd $1,$2($3)" />

	<macro name="diab.spill.32"	rule="r=R && r.r=CONST: any(r) const(r.r) framepointer(r) new(R): li $4,$2 ; stwx $1,$3,$4" />
	<macro name="diab.spill.64"	rule="r=R && r.r=CONST: any(r) const(r.r) framepointer(r) new(R): li $4,$2 ; evstddx $1,$3,$4" />
	<macro name="diab.spill.32"	rule="r=F && r.r=CONST: any(r) const(r.r) framepointer(r) new(R): li $4,$2 ; stfsx $1,$3,$4" />
	<macro name="diab.spill.64"	rule="r=F && r.r=CONST: any(r) const(r.r) framepointer(r) new(R): li $4,$2 ; stfdx $1,$3,$4" />
	<macro name="diab.spill.128"	rule="r=V && r.r=CONST: any(r) const(r.r) framepointer(r) new(R): li $4,$2 ; stvx $1,$3,$4" />
    </macro>
    <macro parse="PpcParseClass.UNARY">
	<macro name="diab.reload.32"	rule="l=R && r=[-32768:32767]: any(l) const(r) framepointer(l): lwz $1,$2($3)" />
	<macro name="diab.reload.64"	rule="l=R && r=[0:248]: any(l) const(r) framepointer(l): evldd $1,$2($3)" />
	<macro name="diab.reload.32"	rule="l=F && r=[-32768:32767]: any(l) const(r) framepointer(l): lfs $1,$2($3)" />
	<macro name="diab.reload.64"	rule="l=F && r=[-32768:32767]: any(l) const(r) framepointer(l): lfd $1,$2($3)" />

	<macro name="diab.reload.32"	rule="l=R && r=CONST: any(l) const(r) framepointer(l) new(R): li $4,$2 ; lwzx $1,$3,$4" />
	<macro name="diab.reload.64"	rule="l=R && r=CONST: any(l) const(r) framepointer(l) new(R): li $4,$2 ; evlddx $1,$3,$4" />
	<macro name="diab.reload.32"	rule="l=F && r=CONST: any(l) const(r) framepointer(l) new(R): li $4,$2 ; lfsx $1,$3,$4" />
	<macro name="diab.reload.64"	rule="l=F && r=CONST: any(l) const(r) framepointer(l) new(R): li $4,$2 ; lfdx $1,$3,$4" />
	<macro name="diab.reload.128"	rule="l=V && r=CONST: any(l) const(r) framepointer(l) new(R): li $4,$2 ; lvx $1,$3,$4" />
    </macro>

    <macro parse="PpcParseClass.SRC" cost="POC.ARITH" >
	<macro name=".diab.frameallocate"	rule="r=[0:128] : const(r) : stwu r1,0 - $1(r1)" />
	<macro name=".diab.frameallocate"	rule="r=CONST : const(r) : li r0,0 - $1 ; stwux r1,r1,r0" />
	<macro name=".diab.frameallocate"	rule="r=CONST : const(r) : stwu r1, 0 - $1(r1)" />
	<macro name=".diab.framedeallocate"	rule="r=CONST : const(r) : addi r1,r1,$1" />

	<macro name="mtlr"	rule=": r(R) : mtspr lr,$1" />
	<macro name="mtctr"	rule=": r(R) : mtspr ctr,$1" />
	<macro name="mtdec"	rule=": r(R) : mtspr dec,$1" />
	<macro name="mtxer"	rule=": r(R) : mtspr xer,$1" />
	<macro name="mtlr"	rule=": r(R) : mtspr lr,$1" />
	<macro name="mtctr"	rule=": r(R) : mtspr ctr,$1" />
	<macro name="mtpvr"	rule=": r(R) : mtspr pvr,$1" />
	<macro name="mtdec"	rule=": r(R) : mtspr dec,$1" />
	<macro name="mtpmr"	rule=": r(R) : mtspr pmr,$1" />
	<macro name="mtsprg0"	rule=": r(R) : mtspr sprg0,$1" />
	<macro name="mtsprg1"	rule=": r(R) : mtspr sprg1,$1" />
	<macro name="mtsprg2"	rule=": r(R) : mtspr sprg2,$1" />
	<macro name="mtsprg3"	rule=": r(R) : mtspr sprg3,$1" />
	<macro name="mtsprg4"	rule=": r(R) : mtspr sprg4,$1" />
	<macro name="mtsprg5"	rule=": r(R) : mtspr sprg5,$1" />
	<macro name="mtsprg6"	rule=": r(R) : mtspr sprg6,$1" />
	<macro name="mtsprg7"	rule=": r(R) : mtspr sprg7,$1" />
	<macro name="mtbbear"	rule=": r(R) : mtspr bbear,$1" />
	<macro name="mtbbtar"	rule=": r(R) : mtspr bbtar,$1" />
	<macro name="mtbucsr0"	rule=": r(R) : mtspr bucsr0,$1" />
	<macro name="mtcsrr0"	rule=": r(R) : mtspr csrr0,$1" />
	<macro name="mtcsrr1"	rule=": r(R) : mtspr csrr1,$1" />
	<macro name="mtcxtr"	rule=": r(R) : mtspr cxtr,$1" />
	<macro name="mtdbcr0"	rule=": r(R) : mtspr dbcr0,$1" />
	<macro name="mtdbcr1"	rule=": r(R) : mtspr dbcr1,$1" />
	<macro name="mtdbcr2"	rule=": r(R) : mtspr dbcr2,$1" />
	<macro name="mtdbsr"	rule=": r(R) : mtspr dbsr,$1" />
	<macro name="mtdear"	rule=": r(R) : mtspr dear,$1" />
	<macro name="mtdvc1"	rule=": r(R) : mtspr dvc1,$1" />
	<macro name="mtdvc2"	rule=": r(R) : mtspr dvc2,$1" />
	<macro name="mtesr"	rule=": r(R) : mtspr esr,$1" />
	<macro name="mthid0"	rule=": r(R) : mtspr hid0,$1" />
	<macro name="mthid1"	rule=": r(R) : mtspr hid1,$1" />
	<macro name="mtiac1"	rule=": r(R) : mtspr iac1,$1" />
	<macro name="mtiac2"	rule=": r(R) : mtspr iac2,$1" />
	<macro name="mtiac3"	rule=": r(R) : mtspr iac3,$1" />
	<macro name="mtiac4"	rule=": r(R) : mtspr iac4,$1" />
	<macro name="mtiarr"	rule=": r(R) : mtspr iarr,$1" />
	<macro name="mtivor0"	rule=": r(R) : mtspr ivor0,$1" />
	<macro name="mtivor1"	rule=": r(R) : mtspr ivor1,$1" />
	<macro name="mtivor2"	rule=": r(R) : mtspr ivor2,$1" />
	<macro name="mtivor3"	rule=": r(R) : mtspr ivor3,$1" />
	<macro name="mtivor4"	rule=": r(R) : mtspr ivor4,$1" />
	<macro name="mtivor5"	rule=": r(R) : mtspr ivor5,$1" />
	<macro name="mtivor6"	rule=": r(R) : mtspr ivor6,$1" />
	<macro name="mtivor7"	rule=": r(R) : mtspr ivor7,$1" />
	<macro name="mtivor8"	rule=": r(R) : mtspr ivor8,$1" />
	<macro name="mtivor9"	rule=": r(R) : mtspr ivor9,$1" />
	<macro name="mtivor10"	rule=": r(R) : mtspr ivor10,$1" />
	<macro name="mtivor11"	rule=": r(R) : mtspr ivor11,$1" />
	<macro name="mtivor12"	rule=": r(R) : mtspr ivor12,$1" />
	<macro name="mtivor13"	rule=": r(R) : mtspr ivor13,$1" />
	<macro name="mtivor14"	rule=": r(R) : mtspr ivor14,$1" />
	<macro name="mtivor15"	rule=": r(R) : mtspr ivor15,$1" />
	<macro name="mtivor32"	rule=": r(R) : mtspr ivor32,$1" />
	<macro name="mtivor33"	rule=": r(R) : mtspr ivor33,$1" />
	<macro name="mtivor34"	rule=": r(R) : mtspr ivor34,$1" />
	<macro name="mtivor35"	rule=": r(R) : mtspr ivor35,$1" />
	<macro name="mtivpr"	rule=": r(R) : mtspr ivpr,$1" />
	<macro name="mtl1cfg0"	rule=": r(R) : mtspr l1cfg0,$1" />
	<macro name="mtl1cfg1"	rule=": r(R) : mtspr l1cfg1,$1" />
	<macro name="mtl1csr0"	rule=": r(R) : mtspr l1csr0,$1" />
	<macro name="mtl1csr1"	rule=": r(R) : mtspr l1csr1,$1" />
	<macro name="mtmas0"	rule=": r(R) : mtspr mas0,$1" />
	<macro name="mtmas1"	rule=": r(R) : mtspr mas1,$1" />
	<macro name="mtmas2"	rule=": r(R) : mtspr mas2,$1" />
	<macro name="mtmas3"	rule=": r(R) : mtspr mas3,$1" />
	<macro name="mtmas4"	rule=": r(R) : mtspr mas4,$1" />
	<macro name="mtmcsr"	rule=": r(R) : mtspr mcsr,$1" />
	<macro name="mtmcsrr0"	rule=": r(R) : mtspr mcsrr0,$1" />
	<macro name="mtmcsrr1"	rule=": r(R) : mtspr mcsrr1,$1" />
	<macro name="mtmmucsr0"	rule=": r(R) : mtspr mmucsr0,$1" />
	<macro name="mtnpidr"	rule=": r(R) : mtspr npidr,$1" />
	<macro name="mtpid0"	rule=": r(R) : mtspr pid0,$1" />
	<macro name="mtpid1"	rule=": r(R) : mtspr pid1,$1" />
	<macro name="mtpid2"	rule=": r(R) : mtspr pid2,$1" />
	<macro name="mtsrr0"	rule=": r(R) : mtspr srr0,$1" />
	<macro name="mtsrr1"	rule=": r(R) : mtspr srr1,$1" />
	<macro name="mttbl"	rule=": r(R) : mtspr tbl,$1" />
	<macro name="mttbu"	rule=": r(R) : mtspr tbu,$1" />
	<macro name="mttcr"	rule=": r(R) : mtspr tcr,$1" />
	<macro name="mttsr"	rule=": r(R) : mtspr tsr,$1" />
	<macro name="mtusprg0"	rule=": r(R) : mtspr usprg0,$1" />
	<macro name="mtdecar"	rule=": r(R) : mtspr decar,$1" />
	<macro name="mtspefscr"	rule=": r(R) : mtspr spefscr,$1" />
<cond when="Processor.VLE">
	<macro name="se_mtctr"	rule=": r(R) : mtspr ctr,$1" />
	<macro name="se_mtlr"	rule=": r(R) : mtspr lr,$1" />
	<macro name="se_blt"	rule=": any(r) : se_bc 1,0,$1" />
	<macro name="se_bge"	rule=": any(r) : se_bc 0,0,$1" />
	<macro name="se_bnl"	rule=": any(r) : se_bc 0,0,$1" />
	<macro name="se_bgt"	rule=": any(r) : se_bc 1,1,$1" />
	<macro name="se_ble"	rule=": any(r) : se_bc 0,1,$1" />
	<macro name="se_bng"	rule=": any(r) : se_bc 0,1,$1" />
	<macro name="se_beq"	rule=": any(r) : se_bc 1,2,$1" />
	<macro name="se_bne"	rule=": any(r) : se_bc 0,2,$1" />
	<macro name="se_bso"	rule=": any(r) : se_bc 1,3,$1" />
	<macro name="se_bun"	rule=": any(r) : se_bc 1,3,$1" />
	<macro name="se_bns"	rule=": any(r) : se_bc 0,3,$1" />
	<macro name="se_bnu"	rule=": any(r) : se_bc 0,3,$1" />
</cond>
    </macro>

    <macro parse="PpcParseClass.EMPTY">
	<macro name="diab.set.ra"	rule="nora(lr)::" />
	<macro name="diab.get.ra"	rule="nora(lr)::" />
	<macro name="diab.load.ra"	rule="nora(lr)::" />
	<macro name="diab.store.ra"	rule="nora(lr)::" />

	<macro name="diab.set.ra"	rule=":: mtspr lr,r0" />
	<macro name="diab.get.ra"	rule=":: mfspr r0,lr" />

	<!-- stinfo 0 is frame pointer	-->
	<!-- stinfo 1 is frame size 	-->
	<macro name="diab.load.ra"	rule=":: diab.loadra r0,r1" />
	<macro name="diab.store.ra"	rule="stinfo(1)=[-32768:32767]: stinfo(0) stinfo(1): stw r0,$2+4(r$1)" />
	<macro name="diab.store.ra"	rule=": stinfo(0) stinfo(1): li r11,$2+4 ; stwx r0,r$1,r11" />
    </macro>

    <macro parse="PpcParseClass.SRC3">
	<macro name="diab.savem.gpr8">
	    <macro rule="r=r30 && r.r=[0:240]: any(r) any(r.r) any(r.r.r): evstdd $1,$2($3) ; diab.savem.gpr8 r31,$2+8,$3" />
	    <macro rule="r=r31 && r.r=[0:248]: any(r) any(r.r) any(r.r.r): evstdd $1,$2($3)" />
	</macro>
	<macro name="diab.restorem.gpr8">
	    <macro rule="r=r30 && r.r=[0:240]: any(r) any(r.r) any(r.r.r): evldd $1,$2($3) ; diab.restorem.gpr8 r31,$2+8,$3" />
	    <macro rule="r=r31 && r.r=[0:248]: any(r) any(r.r) any(r.r.r): evldd $1,$2($3)" />
	</macro>
	<macro name="diab.savem.gpr8"    rule="(r=r30||r=r31) && r.r=CONST: any(r) any(r.r) any(r.r.r): addi r11,$3,$2 ; diab.savem.gpr8 $1,0,r11" />
	<macro name="diab.restorem.gpr8" rule="(r=r30||r=r31) && r.r=CONST: any(r) any(r.r) any(r.r.r): addi r11,$3,$2 ; diab.restorem.gpr8 $1,0,r11" />

	<!-- the save64gpr routines are a bit strange as they expect fixed offsets -->
	<macro name="diab.savem.gpr8"	 rule=": any(r) any(r.r) any(r.r.r) regno(r): diab.get.ra ; addi r11,$3,(((32-$4)*8)+$2)-144 ; diab.savem8 $1,r11 ; diab.store.ra" />
	<macro name="diab.restorem.gpr8" rule=": any(r) any(r.r) any(r.r.r) regno(r): diab.load.ra ; addi r11,$3,(((32-$4)*8)+$2)-144 ; diab.restm8 $1,r11 ; diab.set.ra" />

	<macro name="diab.save.gpr8"	  rule=": any(r) any(r.r) any(r.r.r): evstdd $1,$2($3)" />
	<macro name="diab.restore.gpr8"	  rule=": any(r) any(r.r) any(r.r.r): evldd  $1,$2($3)" />

	<macro name="diab.save.gpr4"	  rule="r.r=[-32768:32767]: any(r) any(r.r) any(r.r.r): stw $1,$2($3)" />
	<macro name="diab.restore.gpr4"	  rule="r.r=[-32768:32767]: any(r) any(r.r) any(r.r.r): lwz $1,$2($3)" />

<cond when="!Processor.VLE">

	<macro name="diab.savem.gpr4"	  rule="r=r31 && r.r=[-32768:32767]: any(r) any(r.r) any(r.r.r): stw $1,$2($3)" />
	<macro name="diab.restorem.gpr4"  rule="r=r31 && r.r=[-32768:32767]: any(r) any(r.r) any(r.r.r): lwz $1,$2($3)" />

	<macro name="diab.savem.gpr4"	  rule="savegpr(r): any(r) any(r.r) any(r.r.r) regno(r): addi r11,$3,(32-$4)*4+$2 ; diab.savem $1,r11" />
	<macro name="diab.restorem.gpr4"  rule="savegpr(r): any(r) any(r.r) any(r.r.r) regno(r): addi r11,$3,(32-$4)*4+$2 ; diab.restm $1,r11" />

    <cond when="!Processor.NOSTM">
	<macro name="diab.savem.gpr4"	  rule="r.r=[-32768:32767]: any(r) any(r.r) any(r.r.r): stmw $1,$2($3)" />
	<macro name="diab.restorem.gpr4"  rule="r.r=[-32768:32767]: any(r) any(r.r) any(r.r.r): lmw $1,$2($3)" />
	<macro name="diab.savem.gpr4"	  rule=": any(r) any(r.r) any(r.r.r): addi r12,$3,$2 ; stmw $1,0(r12)" />
	<macro name="diab.restorem.gpr4"  rule=": any(r) any(r.r) any(r.r.r): addi r12,$3,$2 ; lmw $1,0(r12)" />
    </cond>

	<macro name="diab.savem.gpr4"	  rule="r<r31 && r.r=[-32768:32767]: any(r) any(r.r) any(r.r.r) nextreg(r): stw $1,$2($3) ; diab.savem.gpr4 $4,$2+4,$3" />
	<macro name="diab.restorem.gpr4"  rule="r<r31 && r.r=[-32768:32767]: any(r) any(r.r) any(r.r.r) nextreg(r): lwz $1,$2($3) ; diab.restorem.gpr4 $4,$2+4,$3" />

	<macro name="diab.savem.vr"	  rule="r=v31 && r.r=[-32768:32767]: any(r) any(r.r) any(r.r.r): li r0,$2 ; stvx $1,$3,r0" />
	<macro name="diab.restorem.vr"	  rule="r=v31 && r.r=[-32768:32767]: any(r) any(r.r) any(r.r.r): li r0,$2 ; lvx $1,$3,r0" />
	<macro name="diab.savem.vr"	  rule=": any(r) any(r.r) any(r.r.r) regno(r): addi r0,$3,(32-$4)*16+$2 ; diab.savem $1,r0" />
	<macro name="diab.restorem.vr"	  rule=": any(r) any(r.r) any(r.r.r) regno(r): addi r0,$3,(32-$4)*16+$2 ; diab.restm $1,r0" />

	<macro name="diab.savem.fpr">
	    <macro rule="savefpr(r): any(r) any(r.r) any(r.r.r) regno(r): addi r11,$3,(32-$4)*8+$2 ; diab.savem $1,r11" />
	    <macro rule="r=f31: any(r) any(r.r) any(r.r.r): stfd $1,$2($3)" />
	    <macro rule="r<f31: any(r) any(r.r) any(r.r.r) nextreg(r): stfd $1,$2($3) ; diab.savem.fpr $4,$2+8,$3" />
	</macro>
	<macro name="diab.restorem.fpr">
	    <macro rule="savefpr(r): any(r) any(r.r) any(r.r.r) regno(r): addi r11,$3,(32-$4)*8+$2 ; diab.restm $1,r11" />
	    <macro rule="r=f31: any(r) any(r.r) any(r.r.r): lfd $1,$2($3)" />
	    <macro rule="r<f31: any(r) any(r.r) any(r.r.r) nextreg(r): lfd $1,$2($3) ; diab.restorem.fpr $4,$2+8,$3" />
	</macro>

</cond>
<cond when="Processor.VLE">
	<macro name="diab.savem.gpr4"	 rule="r=r31 && r.r=[-32768:32767]: any(r) any(r.r) any(r.r.r): stw $1,$2($3)" />
	<macro name="diab.restorem.gpr4" rule="r=r31 && r.r=[-32768:32767]: any(r) any(r.r) any(r.r.r): lwz $1,$2($3)" />

	<macro name="diab.savem.gpr4"	 rule="r.r=[-128:127]: any(r) any(r.r) any(r.r.r): stmw $1,$2($3)" />
	<macro name="diab.restorem.gpr4" rule="r.r=[-128:127]: any(r) any(r.r) any(r.r.r): lmw $1,$2($3)" />

	<macro name="diab.savem.gpr4"	 rule=": any(r) any(r.r) any(r.r.r): addi r12,$3,$2 ; stmw $1,0(r12)" />
	<macro name="diab.restorem.gpr4" rule=": any(r) any(r.r) any(r.r.r): addi r12,$3,$2 ; lmw $1,0(r12)" />
</cond>

    </macro>

<cond when="!Processor.VLE">
    <macro parse="PpcParseClass.EMPTY">
	<macro name="beqlr"	rule=": : bclr 12,2" />
	<macro name="bnelr"	rule=": : bclr 4,2" />
	<macro name="bltlr"	rule=": : bclr 12,0" />
	<macro name="blelr"	rule=": : bclr 4,1" />
	<macro name="bgtlr"	rule=": : bclr 12,1" />
	<macro name="bgelr"	rule=": : bclr 4,0" />
	<macro name="bnllr"	rule=": : bclr 4,0" />
	<macro name="bnglr"	rule=": : bclr 4,1" />
	<macro name="bsolr"	rule=": : bclr 12,3" />
	<macro name="bnslr"	rule=": : bclr 4,3" />
	<macro name="bunlr"	rule=": : bclr 12,3" />
	<macro name="bnulr"	rule=": : bclr 4,3" />

	<macro name="beqlrl"	rule=": : bclrl 12,2" />
	<macro name="bnelrl"	rule=": : bclrl 4,2" />
	<macro name="bltlrl"	rule=": : bclrl 12,0" />
	<macro name="blelrl"	rule=": : bclrl 4,1" />
	<macro name="bgtlrl"	rule=": : bclrl 12,1" />
	<macro name="bgelrl"	rule=": : bclrl 4,0" />
	<macro name="bnllrl"	rule=": : bclrl 4,0" />
	<macro name="bnglrl"	rule=": : bclrl 4,1" />
	<macro name="bsolrl"	rule=": : bclrl 12,3" />
	<macro name="bnslrl"	rule=": : bclrl 4,3" />
	<macro name="bunlrl"	rule=": : bclrl 12,3" />
	<macro name="bnulrl"	rule=": : bclrl 4,3" />
    </macro>

    <macro parse="PpcParseClass.SRC">
	<macro name="beqlr"	rule="crf(r) : crf(r) : bclr 12,2+($1*4)" />
	<macro name="bnelr"	rule="crf(r) : crf(r) : bclr 4,2+($1*4)" />
	<macro name="bltlr"	rule="crf(r) : crf(r) : bclr 12,0+($1*4)" />
	<macro name="blelr"	rule="crf(r) : crf(r) : bclr 4,1+($1*4)" />
	<macro name="bgtlr"	rule="crf(r) : crf(r) : bclr 12,1+($1*4)" />
	<macro name="bgelr"	rule="crf(r) : crf(r) : bclr 4,0+($1*4)" />
	<macro name="bnllr"	rule="crf(r) : crf(r) : bclr 4,0+($1*4)" />
	<macro name="bnglr"	rule="crf(r) : crf(r) : bclr 4,1+($1*4)" />
	<macro name="bsolr"	rule="crf(r) : crf(r) : bclr 12,3+($1*4)" />
	<macro name="bnslr"	rule="crf(r) : crf(r) : bclr 4,3+($1*4)" />
	<macro name="bunlr"	rule="crf(r) : crf(r) : bclr 12,3+($1*4)" />
	<macro name="bnulr"	rule="crf(r) : crf(r) : bclr 4,3+($1*4)" />

	<macro name="beqlrl"	rule="crf(r) : crf(r) : bclrl 12,2+($1*4)" />
	<macro name="bnelrl"	rule="crf(r) : crf(r) : bclrl 4,2+($1*4)" />
	<macro name="bltlrl"	rule="crf(r) : crf(r) : bclrl 12,0+($1*4)" />
	<macro name="blelrl"	rule="crf(r) : crf(r) : bclrl 4,1+($1*4)" />
	<macro name="bgtlrl"	rule="crf(r) : crf(r) : bclrl 12,1+($1*4)" />
	<macro name="bgelrl"	rule="crf(r) : crf(r) : bclrl 4,0+($1*4)" />
	<macro name="bnllrl"	rule="crf(r) : crf(r) : bclrl 4,0+($1*4)" />
	<macro name="bnglrl"	rule="crf(r) : crf(r) : bclrl 4,1+($1*4)" />
	<macro name="bsolrl"	rule="crf(r) : crf(r) : bclrl 12,3+($1*4)" />
	<macro name="bnslrl"	rule="crf(r) : crf(r) : bclrl 4,3+($1*4)" />
	<macro name="bunlrl"	rule="crf(r) : crf(r) : bclrl 12,3+($1*4)" />
	<macro name="bnulrl"	rule="crf(r) : crf(r) : bclrl 4,3+($1*4)" />
    </macro>

    <macro parse="PpcParseClass.SRC2">
	<macro name="beq"	rule="crf(r) : crf(r) any(r.r) : bc 12,2+($1*4),$2" />
	<macro name="beq+"	rule="crf(r) : crf(r) any(r.r) : bc+ 12,2+($1*4),$2" />
	<macro name="beq-"	rule="crf(r) : crf(r) any(r.r) : bc- 12,2+($1*4),$2" />
	<macro name="bne"	rule="crf(r) : crf(r) any(r.r) : bc 4,2+($1*4),$2" />
	<macro name="bne+"	rule="crf(r) : crf(r) any(r.r) : bc+ 4,2+($1*4),$2" />
	<macro name="bne-"	rule="crf(r) : crf(r) any(r.r) : bc- 4,2+($1*4),$2" />
	<macro name="blt"	rule="crf(r) : crf(r) any(r.r) : bc 12,0+($1*4),$2" />
	<macro name="blt+"	rule="crf(r) : crf(r) any(r.r) : bc+ 12,0+($1*4),$2" />
	<macro name="blt-"	rule="crf(r) : crf(r) any(r.r) : bc- 12,0+($1*4),$2" />
	<macro name="ble"	rule="crf(r) : crf(r) any(r.r) : bc 4,1+($1*4),$2" />
	<macro name="ble+"	rule="crf(r) : crf(r) any(r.r) : bc+ 4,1+($1*4),$2" />
	<macro name="ble-"	rule="crf(r) : crf(r) any(r.r) : bc- 4,1+($1*4),$2" />
	<macro name="bgt"	rule="crf(r) : crf(r) any(r.r) : bc 12,1+($1*4),$2" />
	<macro name="bgt+"	rule="crf(r) : crf(r) any(r.r) : bc+ 12,1+($1*4),$2" />
	<macro name="bgt-"	rule="crf(r) : crf(r) any(r.r) : bc- 12,1+($1*4),$2" />
	<macro name="bge"	rule="crf(r) : crf(r) any(r.r) : bc 4,0+($1*4),$2" />
	<macro name="bge+"	rule="crf(r) : crf(r) any(r.r) : bc+ 4,0+($1*4),$2" />
	<macro name="bge-"	rule="crf(r) : crf(r) any(r.r) : bc- 4,0+($1*4),$2" />
	<macro name="bnl"	rule="crf(r) : crf(r) any(r.r) : bc 4,0+($1*4),$2" />
	<macro name="bnl+"	rule="crf(r) : crf(r) any(r.r) : bc+ 4,0+($1*4),$2" />
	<macro name="bnl-"	rule="crf(r) : crf(r) any(r.r) : bc- 4,0+($1*4),$2" />
	<macro name="bng"	rule="crf(r) : crf(r) any(r.r) : bc 4,1+($1*4),$2" />
	<macro name="bng+"	rule="crf(r) : crf(r) any(r.r) : bc+ 4,1+($1*4),$2" />
	<macro name="bng-"	rule="crf(r) : crf(r) any(r.r) : bc- 4,1+($1*4),$2" />
	<macro name="bso"	rule="crf(r) : crf(r) any(r.r) : bc 12,3+($1*4),$2" />
	<macro name="bso+"	rule="crf(r) : crf(r) any(r.r) : bc+ 12,3+($1*4),$2" />
	<macro name="bso-"	rule="crf(r) : crf(r) any(r.r) : bc- 12,3+($1*4),$2" />
	<macro name="bns"	rule="crf(r) : crf(r) any(r.r) : bc 4,3+($1*4),$2" />
	<macro name="bns+"	rule="crf(r) : crf(r) any(r.r) : bc+ 4,3+($1*4),$2" />
	<macro name="bns-"	rule="crf(r) : crf(r) any(r.r) : bc- 4,3+($1*4),$2" />
	<macro name="bun"	rule="crf(r) : crf(r) any(r.r) : bc 12,3+($1*4),$2" />
	<macro name="bun+"	rule="crf(r) : crf(r) any(r.r) : bc+ 12,3+($1*4),$2" />
	<macro name="bun-"	rule="crf(r) : crf(r) any(r.r) : bc- 12,3+($1*4),$2" />
	<macro name="bnu"	rule="crf(r) : crf(r) any(r.r) : bc 4,3+($1*4),$2" />
	<macro name="bnu+"	rule="crf(r) : crf(r) any(r.r) : bc+ 4,3+($1*4),$2" />
	<macro name="bnu-"	rule="crf(r) : crf(r) any(r.r) : bc- 4,3+($1*4),$2" />
    </macro>

    <macro parse="PpcParseClass.SRC">
	<macro name="beq"	rule=": any(r) : bc 12,2,$1" />
	<macro name="beq+"	rule=": any(r) : bc+ 12,2,$1" />
	<macro name="beq-"	rule=": any(r) : bc- 12,2,$1" />
	<macro name="bne"	rule=": any(r) : bc 4,2,$1" />
	<macro name="bne-"	rule=": any(r) : bc- 4,2,$1" />
	<macro name="bne+"	rule=": any(r) : bc+ 4,2,$1" />
	<macro name="blt"	rule=": any(r) : bc 12,0,$1" />
	<macro name="blt-"	rule=": any(r) : bc- 12,0,$1" />
	<macro name="blt+"	rule=": any(r) : bc+ 12,0,$1" />
	<macro name="ble"	rule=": any(r) : bc 4,1,$1" />
	<macro name="ble-"	rule=": any(r) : bc- 4,1,$1" />
	<macro name="ble+"	rule=": any(r) : bc+ 4,1,$1" />
	<macro name="bgt"	rule=": any(r) : bc 12,1,$1" />
	<macro name="bgt-"	rule=": any(r) : bc- 12,1,$1" />
	<macro name="bgt+"	rule=": any(r) : bc+ 12,1,$1" />
	<macro name="bge"	rule=": any(r) : bc 4,0,$1" />
	<macro name="bge-"	rule=": any(r) : bc- 4,0,$1" />
	<macro name="bge+"	rule=": any(r) : bc+ 4,0,$1" />
	<macro name="bnl"	rule=": any(r) : bc 4,0,$1" />
	<macro name="bnl-"	rule=": any(r) : bc- 4,0,$1" />
	<macro name="bnl+"	rule=": any(r) : bc+ 4,0,$1" />
	<macro name="bng"	rule=": any(r) : bc 4,1,$1" />
	<macro name="bng-"	rule=": any(r) : bc- 4,1,$1" />
	<macro name="bng+"	rule=": any(r) : bc+ 4,1,$1" />
	<macro name="bso"	rule=": any(r) : bc 12,3,$1" />
	<macro name="bso-"	rule=": any(r) : bc- 12,3,$1" />
	<macro name="bso+"	rule=": any(r) : bc+ 12,3,$1" />
	<macro name="bns"	rule=": any(r) : bc 4,3,$1" />
	<macro name="bns-"	rule=": any(r) : bc- 4,3,$1" />
	<macro name="bns+"	rule=": any(r) : bc+ 4,3,$1" />
	<macro name="bun"	rule=": any(r) : bc 12,3,$1" />
	<macro name="bun-"	rule=": any(r) : bc- 12,3,$1" />
	<macro name="bun+"	rule=": any(r) : bc+ 12,3,$1" />
	<macro name="bnu"	rule=": any(r) : bc 4,3,$1" />
	<macro name="bnu-"	rule=": any(r) : bc- 4,3,$1" />
	<macro name="bnu+"	rule=": any(r) : bc+ 4,3,$1" />
    </macro>
</cond>

<cond when="Processor.VLE">
    <macro parse="PpcParseClass.SRC2">
	<macro name="beq"	rule="crf0(r) : crf0(r) any(r.r) : bc 1,2+($1*4),$2" />
	<macro name="bne"	rule="crf0(r) : crf0(r) any(r.r) : bc 0,2+($1*4),$2" />
	<macro name="blt"	rule="crf0(r) : crf0(r) any(r.r) : bc 1,0+($1*4),$2" />
	<macro name="ble"	rule="crf0(r) : crf0(r) any(r.r) : bc 0,1+($1*4),$2" />
	<macro name="bgt"	rule="crf0(r) : crf0(r) any(r.r) : bc 1,1+($1*4),$2" />
	<macro name="bge"	rule="crf0(r) : crf0(r) any(r.r) : bc 0,0+($1*4),$2" />
	<macro name="bnl"	rule="crf0(r) : crf0(r) any(r.r) : bc 0,0+($1*4),$2" />
	<macro name="bng"	rule="crf0(r) : crf0(r) any(r.r) : bc 0,1+($1*4),$2" />
	<macro name="bso"	rule="crf0(r) : crf0(r) any(r.r) : bc 1,3+($1*4),$2" />
	<macro name="bns"	rule="crf0(r) : crf0(r) any(r.r) : bc 0,3+($1*4),$2" />
	<macro name="bun"	rule="crf0(r) : crf0(r) any(r.r) : bc 1,3+($1*4),$2" />
	<macro name="bnu"	rule="crf0(r) : crf0(r) any(r.r) : bc 0,3+($1*4),$2" />

	<macro name="e_cmpi"	rule=": any(r) any(r.r) : cmpi 0,0,$1,$2" />
    </macro>

    <macro parse="PpcParseClass.SRC">
	<macro name="beq"	rule=": any(r) : bc 1,2,$1" />
	<macro name="beq+"	rule=": any(r) : bc 1,2,$1" />
	<macro name="beq-"	rule=": any(r) : bc 1,2,$1" />
	<macro name="bne"	rule=": any(r) : bc 0,2,$1" />
	<macro name="bne-"	rule=": any(r) : bc 0,2,$1" />
	<macro name="bne+"	rule=": any(r) : bc 0,2,$1" />
	<macro name="blt"	rule=": any(r) : bc 1,0,$1" />
	<macro name="blt-"	rule=": any(r) : bc 1,0,$1" />
	<macro name="blt+"	rule=": any(r) : bc 1,0,$1" />
	<macro name="ble"	rule=": any(r) : bc 0,1,$1" />
	<macro name="ble-"	rule=": any(r) : bc 0,1,$1" />
	<macro name="ble+"	rule=": any(r) : bc 0,1,$1" />
	<macro name="bgt"	rule=": any(r) : bc 1,1,$1" />
	<macro name="bgt-"	rule=": any(r) : bc 1,1,$1" />
	<macro name="bgt+"	rule=": any(r) : bc 1,1,$1" />
	<macro name="bge"	rule=": any(r) : bc 0,0,$1" />
	<macro name="bge-"	rule=": any(r) : bc 0,0,$1" />
	<macro name="bge+"	rule=": any(r) : bc 0,0,$1" />
	<macro name="bnl"	rule=": any(r) : bc 0,0,$1" />
	<macro name="bnl-"	rule=": any(r) : bc 0,0,$1" />
	<macro name="bnl+"	rule=": any(r) : bc 0,0,$1" />
	<macro name="bng"	rule=": any(r) : bc 0,1,$1" />
	<macro name="bng-"	rule=": any(r) : bc 0,1,$1" />
	<macro name="bng+"	rule=": any(r) : bc 0,1,$1" />
	<macro name="bso"	rule=": any(r) : bc 1,3,$1" />
	<macro name="bso-"	rule=": any(r) : bc 1,3,$1" />
	<macro name="bso+"	rule=": any(r) : bc 1,3,$1" />
	<macro name="bns"	rule=": any(r) : bc 0,3,$1" />
	<macro name="bns-"	rule=": any(r) : bc 0,3,$1" />
	<macro name="bns+"	rule=": any(r) : bc 0,3,$1" />
	<macro name="bun"	rule=": any(r) : bc 1,3,$1" />
	<macro name="bun-"	rule=": any(r) : bc 1,3,$1" />
	<macro name="bun+"	rule=": any(r) : bc 1,3,$1" />
	<macro name="bnu"	rule=": any(r) : bc 0,3,$1" />
	<macro name="bnu-"	rule=": any(r) : bc 0,3,$1" />
	<macro name="bnu+"	rule=": any(r) : bc 0,3,$1" />

	<macro name="e_beq"	rule=": any(r) : bc 1,2,$1" />
	<macro name="e_beq+"	rule=": any(r) : bc 1,2,$1" />
	<macro name="e_beq-"	rule=": any(r) : bc 1,2,$1" />
	<macro name="e_bne"	rule=": any(r) : bc 0,2,$1" />
	<macro name="e_bne-"	rule=": any(r) : bc 0,2,$1" />
	<macro name="e_bne+"	rule=": any(r) : bc 0,2,$1" />
	<macro name="e_blt"	rule=": any(r) : bc 1,0,$1" />
	<macro name="e_blt-"	rule=": any(r) : bc 1,0,$1" />
	<macro name="e_blt+"	rule=": any(r) : bc 1,0,$1" />
	<macro name="e_ble"	rule=": any(r) : bc 0,1,$1" />
	<macro name="e_ble-"	rule=": any(r) : bc 0,1,$1" />
	<macro name="e_ble+"	rule=": any(r) : bc 0,1,$1" />
	<macro name="e_bgt"	rule=": any(r) : bc 1,1,$1" />
	<macro name="e_bgt-"	rule=": any(r) : bc 1,1,$1" />
	<macro name="e_bgt+"	rule=": any(r) : bc 1,1,$1" />
	<macro name="e_bge"	rule=": any(r) : bc 0,0,$1" />
	<macro name="e_bge-"	rule=": any(r) : bc 0,0,$1" />
	<macro name="e_bge+"	rule=": any(r) : bc 0,0,$1" />
	<macro name="e_bnl"	rule=": any(r) : bc 0,0,$1" />
	<macro name="e_bnl-"	rule=": any(r) : bc 0,0,$1" />
	<macro name="e_bnl+"	rule=": any(r) : bc 0,0,$1" />
	<macro name="e_bng"	rule=": any(r) : bc 0,1,$1" />
	<macro name="e_bng-"	rule=": any(r) : bc 0,1,$1" />
	<macro name="e_bng+"	rule=": any(r) : bc 0,1,$1" />
	<macro name="e_bso"	rule=": any(r) : bc 1,3,$1" />
	<macro name="e_bso-"	rule=": any(r) : bc 1,3,$1" />
	<macro name="e_bso+"	rule=": any(r) : bc 1,3,$1" />
	<macro name="e_bns"	rule=": any(r) : bc 0,3,$1" />
	<macro name="e_bns-"	rule=": any(r) : bc 0,3,$1" />
	<macro name="e_bns+"	rule=": any(r) : bc 0,3,$1" />
	<macro name="e_bun"	rule=": any(r) : bc 1,3,$1" />
	<macro name="e_bun-"	rule=": any(r) : bc 1,3,$1" />
	<macro name="e_bun+"	rule=": any(r) : bc 1,3,$1" />
	<macro name="e_bnu"	rule=": any(r) : bc 0,3,$1" />
	<macro name="e_bnu-"	rule=": any(r) : bc 0,3,$1" />
	<macro name="e_bnu+"	rule=": any(r) : bc 0,3,$1" />
    </macro>
</cond>

<!-- IBM differs from Freescale for these -->
    <macro parse="PpcParseClass.SRC2">
	<macro name="tlbrehi"	rule="r=R && r.r=R			: r(R) r.r(R) : tlbre $1,$2,0" />
	<macro name="tlbrelo"	rule="r=R && r.r=R			: r(R) r.r(R) : tlbre $1,$2,1" />
	<macro name="tlbwehi"	rule="r=R && r.r=R			: r(R) r.r(R) : tlbwe $1,$2,0" />
	<macro name="tlbwelo"	rule="r=R && r.r=R			: r(R) r.r(R) : tlbwe $1,$2,1" />
    </macro>
<!-- END of IBM differs from Freescale for these -->

    <macro parse="PpcParseClass.UNARY" validUntil="LLOPT.POSTEXPAND">
	    <macro name="li"	rule="l=R && r=CONST			: l(R) any(r) : diab.li $1,$2" />
	    <macro name="lis"	rule="l=R && r=CONST			: l(R) any(r) : diab.li $1,$2<<16" />
    </macro>

    <macro parse="PpcParseClass.BINARY">
	<macro name="slwi"	rule="l=R && r=R && r.r=CONST		: l(R) r(R) const(r.r) : rlwinm	 $1,$2,$3,0,31-$3" />
	<macro name="slwi."	rule="l=R && r=R && r.r=CONST		: l(R) r(R) const(r.r) : rlwinm. $1,$2,$3,0,31-$3" />

    	<macro validUntil="LLOPT.POSTEXPAND">
	    <macro name="addi"	rule="l=R && r=r0 && r.r=CONST		: l(R) any(r.r) : diab.li $1,$2" />
	    <macro name="addis"	rule="l=R && r=r0 && r.r=CONST		: l(R) any(r.r) : diab.li $1,$2<<16" />

	    <macro name="addi"	rule="l=R && r=r0			: l(R) any(r.r) : li $1,$2" />
	    <macro name="addis"	rule="l=R && r=r0			: l(R) any(r.r) : lis $1,$2" />
    	</macro>

<cond when="Processor.VLE">
	<macro name="addis"	rule="l=R && l=r			: l(R) any(r.r) : e_add2is $1,$2" />
	<macro name="andis."	rule="l=R && l=r			: l(R) any(r.r) : e_and2is. $1,$2" />

	<macro name="andi."	rule="l=R && r=R && sci8(r.r)		: l(R) r(R) const(r.r)	: e_andi. $1,$2,$3" />
	<macro name="andi."	rule="l=R && l=r			: l(R) any(r.r)		: e_and2i. $1,$2" />

	<macro name="ori"	rule="l=R && r=l && log2(r.r)		: l(R) log2(r.r)	: .diab.bseti $1,31-$2" />
	<macro name="ori"	rule="l=R && r=R && sci8(r.r)		: l(R) r(R) const(r.r)	: e_ori	 $1,$2,$3" />
	<macro name="ori."	rule="l=R && r=R && sci8(r.r)		: l(R) r(R) const(r.r)	: e_ori. $1,$2,$3" />
	<macro name="ori"	rule="l=R && l=r			: l(R) any(r.r)		: e_or2i $1,$2" />
	<macro name="oris"	rule="l=R && l=r			: l(R) any(r.r)		: e_or2is $1,$2" />

	<macro name="mulli"	rule="l=R && r=R && sci8(r.r)		: l(R) r(R) const(r.r) : e_mulli $1,$2,$3" />
	<macro name="mulli"	rule="l=R && l=r && r.r=[-32768:32767]	: l(R) const(r.r) : e_mull2i $1,$2" />
</cond>
    </macro>

    <!-- Converts all forms of integer comparison to a simplified internal form that is easier to optimize.	-->
    <!-- The internal form will be converted back to a real instruction by the expand phase.			-->
    <macro validUntil="LLOPT.POSTEXPAND" parse="PpcParseClass.COMPARE">
	<macro rule="#r=4 && crf(r) && r.r=0 && r.r.r=R">
	    <macro name="cmp"	rule="r.r.r.r=R			: crf(r) r.r.r(R) r.r.r.r(R)	  : .diab.cmp  cr$1,$2,$3" />
	    <macro name="cmpl"	rule="r.r.r.r=R			: crf(r) r.r.r(R) r.r.r.r(R)	  : .diab.cmpl cr$1,$2,$3" />
	    <macro name="cmpi"	rule="r.r.r.r=[-32768:32767]	: crf(r) r.r.r(R) const(r.r.r.r)  : .diab.cmp  cr$1,$2,$3" />
	    <macro name="cmpli"	rule="r.r.r.r=[0:65535]		: crf(r) r.r.r(R) const(r.r.r.r)  : .diab.cmpl cr$1,$2,$3" />
	</macro>
	<macro rule="#r=3 && crf(r) && r.r=R">
	    <macro name="cmp"	rule="r.r.r=R			: crf(r) r.r(R) r.r.r(R)	  : .diab.cmp  cr$1,$2,$3" />
	    <macro name="cmpl"	rule="r.r.r=R			: crf(r) r.r(R) r.r.r(R)	  : .diab.cmpl cr$1,$2,$3" />
	    <macro name="cmpi"	rule="r.r.r=[-32768:32767]	: crf(r) r.r(R) const(r.r.r)	  : .diab.cmp  cr$1,$2,$3" />
	    <macro name="cmpli"	rule="r.r.r=[0:65535]		: crf(r) r.r(R) const(r.r.r)	  : .diab.cmpl cr$1,$2,$3" />
	</macro>
	<macro rule="#r=2 && r=R">
	    <macro name="cmp"	rule="r.r=R			: r(R) r.r(R)			  : .diab.cmp  cr0,$1,$2" />
	    <macro name="cmpl"	rule="r.r=R			: r(R) r.r(R)			  : .diab.cmpl cr0,$1,$2" />
	    <macro name="cmpi"	rule="r.r=[-32768:32767]	: r(R) const(r.r)		  : .diab.cmp  cr0,$1,$2" />
	    <macro name="cmpli"	rule="r.r=[0:65535]		: r(R) const(r.r)		  : .diab.cmpl cr0,$1,$2" />
	    <macro name="cmpw"	rule="r.r=R			: r(R) r.r(R)			  : .diab.cmp  cr0,$1,$2" />
	</macro>
    </macro>

    <!-- Hypervisor extended mnemonics -->
    <macro parse="PpcParseClass.SRC2">
	<macro name="tlbillpid"		rule="l=R && r=R	: l(R) r(R)	: tlbilx	0,$1,$2" />
	<macro name="tlbilpid"		rule="l=R && r=R	: l(R) r(R)	: tlbilx	1,$1,$2" />
	<macro name="tlbilva"		rule="l=R && r=R	: l(R) r(R)	: tlbilx	3,$1,$2" />
    </macro>
    <macro parse="PpcParseClass.SRC">
	<macro name="tlbilva"		rule="l=R		: l(R)		: tlbilx	3,0,$1" />
    </macro>

    <macro parse="PpcParseClass.DST"> 
	<macro name="mtcr"  rule=": l(R) : mtcrf 255,$1" />
    </macro>

<!-- Fix the defect WIND00086933 Append all Simplified Mnemonics for PowerPC instruction 
 	 The following format of simplified branch mnemonics is not supported at present
	 after confirmed with Mark. 
	           bt n*crn+eq
  -->
<cond when="!Processor.VLE">
	<macro parse="PpcParseClass.EMPTY">
	<macro name="bctr"     rule=":: bcctr 20,0"/>
	<macro name="bctr+"    rule=":: bcctr+ 20,0"/>
	<macro name="bctr-"    rule=":: bcctr- 20,0"/>
	<macro name="bctrl"    rule=":: bcctrl 20,0" />
	<macro name="bctrl+"   rule=":: bcctrl+ 20,0" />
	<macro name="bctrl-"   rule=":: bcctrl- 20,0" />
	<macro name="bdnzlr"   rule=":: bclr 16,0" />
	<macro name="bdnzlr+"  rule=":: bclr+ 16,0" />
	<macro name="bdnzlr-"  rule=":: bclr- 16,0" />
	<macro name="bdnzlrl"  rule=":: bclrl 16,0"/>
	<macro name="bdnzlrl+" rule=":: bclrl+ 16,0"/>
	<macro name="bdnzlrl-" rule=":: bclrl- 16,0"/>
	<macro name="bdzlr"    rule=":: bclr 18,0" />
	<macro name="bdzlr+"   rule=":: bclr+ 18,0" />
	<macro name="bdzlr-"   rule=":: bclr- 18,0" />
	<macro name="bdzlrl"   rule=":: bclrl 18,0" />
	<macro name="bdzlrl+"  rule=":: bclrl+ 18,0" />
	<macro name="bdzlrl-"  rule=":: bclrl- 18,0" />
	<macro name="blrl"     rule=":: bclrl 20,0" />
	<macro name="blrl+"    rule=":: bclrl+ 20,0" />
	<macro name="blrl-"    rule=":: bclrl- 20,0" />
	<macro name="btctr"    rule=":: bcctr 12,0" />
	<macro name="btctr+"   rule=":: bcctr+ 12,0" />
	<macro name="btctr-"   rule=":: bcctr- 12,0" />
	<macro name="btctrl"   rule=":: bcctrl 12,0" />
	<macro name="btctrl+"  rule=":: bcctrl+ 12,0" />
	<macro name="btctrl-"  rule=":: bcctrl- 12,0" />
	<macro name="btlr"     rule=":: bclr 12,0" />
	<macro name="btlr+"    rule=":: bclr+ 12,0" />
	<macro name="btlr-"    rule=":: bclr- 12,0" />
	<macro name="btlrl"    rule=":: bclrl 12,0" />
	<macro name="btlrl+"   rule=":: bclrl+ 12,0" />
	<macro name="btlrl-"   rule=":: bclrl- 12,0" />
	<macro name="bfctr"    rule=":: bcctr 4,0" />
	<macro name="bfctr+"   rule=":: bcctr+ 4,0" />
	<macro name="bfctr-"   rule=":: bcctr- 4,0" />
	<macro name="bfctrl"   rule=":: bcctrl 4,0" />
	<macro name="bfctrl+"  rule=":: bcctrl+ 4,0" />
	<macro name="bfctrl-"  rule=":: bcctrl- 4,0" />
	<macro name="bflr"     rule=":: bclr 4,0" />
	<macro name="bflr+"    rule=":: bclr+ 4,0" />
	<macro name="bflr-"    rule=":: bclr- 4,0" />
	<macro name="bflrl"    rule=":: bclrl 4,0" />
	<macro name="bflrl+"   rule=":: bclrl+ 4,0" />
	<macro name="bflrl-"   rule=":: bclrl- 4,0" />
	<macro name="bfctr"    rule=":: bcctr 4,0" />
	<macro name="bfctr+"   rule=":: bcctr+ 4,0" />
	<macro name="bfctr-"   rule=":: bcctr- 4,0" />
	<macro name="bfctrl"   rule=":: bcctrl 4,0" />
	<macro name="bfctrl+"  rule=":: bcctrl+ 4,0" />
	<macro name="bfctrl-"  rule=":: bcctrl- 4,0" />
	<macro name="bflr"     rule=":: bclr 4,0" />
	<macro name="bflr+"    rule=":: bclr+ 4,0" />
	<macro name="bflr-"    rule=":: bclr- 4,0" />
	<macro name="bflrl"    rule=":: bclrl 4,0" />
	<macro name="bflrl+"   rule=":: bclrl+ 4,0" />
	<macro name="bflrl-"   rule=":: bclrl- 4,0" />
	<macro name="bdnztlr"  rule=":: bclr 8,0" /> 
	<macro name="bdnztlr+" rule=":: bclr+ 8,0" /> 
	<macro name="bdnztlr-" rule=":: bclr- 8,0" /> 
	<macro name="bdnztlrl" rule=":: bclrl 8,0" />
	<macro name="bdnztlrl+" rule=":: bclrl+ 8,0" />
	<macro name="bdnztlrl-" rule=":: bclrl- 8,0" />
	<macro name="bdnzflr"    rule=":: bclr 0,0" />
	<macro name="bdnzflr+"   rule=":: bclr+ 0,0" />
	<macro name="bdnzflr-"   rule=":: bclr- 0,0" />
	<macro name="bdnzflrl"   rule=":: bclrl 0,0" />
	<macro name="bdnzflrl+"  rule=":: bclrl+ 0,0" />
	<macro name="bdnzflrl-"  rule=":: bclrl- 0,0" />
	</macro>
	<macro parse="PpcParseClass.COMPARE">
	<macro rule="#r=3 && crf(r) && r.r=R">
	<macro name="cmpwi"  rule="r.r.r=[-32768:32767]: crf(r) r.r(R) const(r.r.r): .diab.cmp  cr$1,$2,$3" />
	<macro name="cmplwi" rule="r.r.r=[0:65535]: crf(r) r.r(R) const(r.r.r): .diab.cmpl  cr$1,$2,$3" />
	</macro>
	</macro>
	<macro parse="PpcParseClass.SRC">
	<macro name="bdnza"     rule=": any(r): bca 16,0,$1" />
	<macro name="bdnza+"    rule=": any(r): bca+ 16,0,$1" />
	<macro name="bdnza-"    rule=": any(r): bca- 16,0,$1" />
	<macro name="bdnzf"     rule=": any(r): bc 0,0,$1" /> 
	<macro name="bdnzf+"    rule=": any(r): bc+ 0,0,$1" /> 
	<macro name="bdnzf-"    rule=": any(r): bc- 0,0,$1" /> 
	<macro name="bdnzfa"    rule=": any(r): bca 0,0,$1" /> 
	<macro name="bdnzfa+"   rule=": any(r): bca+ 0,0,$1" /> 
	<macro name="bdnzfa-"   rule=": any(r): bca- 0,0,$1" /> 
	<macro name="bdnzfl"    rule=": any(r): bcl 0,0,$1" />
	<macro name="bdnzfl+"   rule=": any(r): bcl+ 0,0,$1" />
	<macro name="bdnzfl-"   rule=": any(r): bcl- 0,0,$1" />
	<macro name="bdnzfla"   rule=": any(r): bcla 0,0,$1" />
	<macro name="bdnzfla+" 	rule=": any(r): bcla+ 0,0,$1" />
	<macro name="bdnzfla-" 	rule=": any(r): bcla- 0,0,$1" />
	<macro name="bdnzflr"   rule="r=[0:31]: const(r): bclr 0,$1" />
	<macro name="bdnzflr+"  rule="r=[0:31]: const(r): bclr+ 0,$1" />
	<macro name="bdnzflr-"  rule="r=[0:31]: const(r): bclr- 0,$1" />
	<macro name="bdnzflrl"  rule="r=[0:31]: const(r): bclrl 0,$1" />
	<macro name="bdnzflrl+" rule="r=[0:31]: const(r): bclrl+ 0,$1" />
	<macro name="bdnzflrl-" rule="r=[0:31]: const(r): bclrl- 0,$1" />
	<macro name="bdnzl"     rule=": any(r): bcl 16,0,$1" />
	<macro name="bdnzl+"    rule=": any(r): bcl+ 16,0,$1" />
	<macro name="bdnzl-"    rule=": any(r): bcl- 16,0,$1" />
	<macro name="bdnzla"    rule=": any(r): bcla 16,0,$1" />
	<macro name="bdnzla+"   rule=": any(r): bcla+ 16,0,$1" />
	<macro name="bdnzla-"   rule=": any(r): bcla- 16,0,$1" />
	<macro name="bdnzt"     rule=": any(r): bc 8,0,$1" />
	<macro name="bdnzt+"    rule=": any(r): bc+ 8,0,$1" />
	<macro name="bdnzt-" 	rule=": any(r): bc- 8,0,$1" />
	<macro name="bdnzta" 	rule=": any(r): bca 8,0,$1" />
	<macro name="bdnzta+" 	rule=": any(r): bca+ 8,0,$1" />
	<macro name="bdnzta-" 	rule=": any(r): bca- 8,0,$1" />
	<macro name="bdnztl" 	rule=": any(r): bcl 8,0,$1" />
	<macro name="bdnztl+" 	rule=": any(r): bcl+ 8,0,$1" />
	<macro name="bdnztl-" 	rule=": any(r): bcl- 8,0,$1" />
	<macro name="bdnztla" 	rule=": any(r): bcla 8,0,$1" />
	<macro name="bdnztla+" 	rule=": any(r): bcla+ 8,0,$1" />
	<macro name="bdnztla-" 	rule=": any(r): bcla- 8,0,$1" />
	<macro name="bdnztlr"   rule="r=[0:31]: const(r): bclr 8,$1" /> 
	<macro name="bdnztlr+"  rule="r=[0:31]: const(r): bclr+ 8,$1" /> 
	<macro name="bdnztlr-"  rule="r=[0:31]: const(r): bclr- 8,$1" /> 
	<macro name="bdnztlrl"  rule="r=[0:31]: const(r): bclrl 8,$1" />
	<macro name="bdnztlrl+" rule="r=[0:31]: const(r): bclrl+ 8,$1" />
	<macro name="bdnztlrl-" rule="r=[0:31]: const(r): bclrl- 8,$1" />
	<macro name="bdz"       rule=": any(r): bc 18,0,$1" />
	<macro name="bdz+"      rule=": any(r): bc+ 18,0,$1" />
	<macro name="bdz-"      rule=": any(r): bc- 18,0,$1" />
	<macro name="bdza"      rule=": any(r): bca 18,0,$1" />
	<macro name="bdza+"     rule=": any(r): bca+ 18,0,$1" />
	<macro name="bdza-"     rule=": any(r): bca- 18,0,$1" />
	<macro name="bdzf"      rule=": any(r): bc 2,0,$1" />
	<macro name="bdzf+"     rule=": any(r): bc+ 2,0,$1" />
	<macro name="bdzf-"     rule=": any(r): bc- 2,0,$1" />
	<macro name="bdzfa"     rule=": any(r): bca 2,0,$1" />
	<macro name="bdzfa+"    rule=": any(r): bca+ 2,0,$1" />
	<macro name="bdzfa-"    rule=": any(r): bca- 2,0,$1" />
	<macro name="bdzfl"     rule=": any(r): bcl 2,0,$1" />
	<macro name="bdzfl+"    rule=": any(r): bcl+ 2,0,$1" />
	<macro name="bdzfl-" 	rule=": any(r): bcl- 2,0,$1" />
	<macro name="bdzfla"    rule=": any(r): bcla 2,0,$1" />
	<macro name="bdzfla+" 	rule=": any(r): bcla+ 2,0,$1" />
	<macro name="bdzfla-"   rule=": any(r): bcla- 2,0,$1" />
	<macro name="bdzflr"    rule="r=[0:31]: const(r): bclr 2,$1" />
	<macro name="bdzflr+"   rule="r=[0:31]: const(r): bclr+ 2,$1" />
	<macro name="bdzflr-"   rule="r=[0:31]: const(r): bclr- 2,$1" />
	<macro name="bdzflrl"   rule="r=[0:31]: const(r): bclrl 2,$1" />
	<macro name="bdzflrl+"  rule="r=[0:31]: const(r): bclrl+ 2,$1" />
	<macro name="bdzflrl-"  rule="r=[0:31]: const(r): bclrl- 2,$1" />
	<macro name="bdzl"      rule=": any(r): bcl  18,0,$1" />
	<macro name="bdzl+"     rule=": any(r): bcl+  18,0,$1" />
	<macro name="bdzl-"     rule=": any(r): bcl-  18,0,$1" />
	<macro name="bdzla"     rule=": any(r): bcla  18,0,$1" />
	<macro name="bdzla+"    rule=": any(r): bcla+  18,0,$1" />
	<macro name="bdzla-"    rule=": any(r): bcla-  18,0,$1" />
	<macro name="bdzt"      rule=":  any(r): bc 10,0,$1" />
	<macro name="bdzt+"     rule=":  any(r): bc+ 10,0,$1" />
	<macro name="bdzt-"     rule=":  any(r): bc- 10,0,$1" />
	<macro name="bdzta"     rule=":  any(r): bca 10,0,$1" />
	<macro name="bdzta+"    rule=":  any(r): bca+ 10,0,$1" />
	<macro name="bdzta-"    rule=":  any(r): bca- 10,0,$1" />
	<macro name="bdztl"     rule=":  any(r): bcl 10,0,$1" />
	<macro name="bdztl+"    rule=":  any(r): bcl+ 10,0,$1" />
	<macro name="bdztl-"    rule=":  any(r): bcl- 10,0,$1" />
	<macro name="bdztla"    rule=":  any(r): bcla 10,0,$1" />
	<macro name="bdztla+"   rule=":  any(r): bcla+ 10,0,$1" />
	<macro name="bdztla-"   rule=":  any(r): bcla- 10,0,$1" />
	<macro name="bdztlr"    rule="r=[0:31]: const(r): bclr 10,$1" />
	<macro name="bdztlr+"   rule="r=[0:31]: const(r): bclr+ 10,$1" />
	<macro name="bdztlr-"   rule="r=[0:31]: const(r): bclr- 10,$1" />
	<macro name="bdztlrl"   rule="r=[0:31]: const(r): bclrl 10,$1" />
	<macro name="bdztlrl+"  rule="r=[0:31]: const(r): bclrl+ 10,$1" />
	<macro name="bdztlrl-"  rule="r=[0:31]: const(r): bclrl- 10,$1" />
	<macro name="beqctr"    rule="crf(r): crf(r): bcctr 12,2+($1*4)" />
	<macro name="beqctr+"   rule="crf(r): crf(r): bcctr+ 12,2+($1*4)" />
	<macro name="beqctr-"   rule="crf(r): crf(r): bcctr- 12,2+($1*4)" />
	<macro name="beqctrl"   rule="crf(r): crf(r): bcctrl 12,2+($1*4)" />
	<macro name="beqctrl+"  rule="crf(r): crf(r): bcctrl+ 12,2+($1*4)" />
	<macro name="beqctrl-"  rule="crf(r): crf(r): bcctrl- 12,2+($1*4)" />
    <macro name="beql"      rule=": any(r.r): bcl 12,2,$1" />
    <macro name="beql+"     rule=": any(r.r): bcl+ 12,2,$1" />
    <macro name="beql-"     rule=": any(r.r): bcl- 12,2,$1" />
    <macro name="bgel"      rule=": any(r.r): bcl 4,0,$1" />
    <macro name="bgel+"     rule=": any(r.r): bcl+ 4,0,$1" />
    <macro name="bgel-"     rule=": any(r.r): bcl- 4,0,$1" />
    <macro name="bgtl"      rule=": any(r.r): bcl 12,1,$1" />
    <macro name="bgtl+"     rule=": any(r.r): bcl+ 12,1,$1" />
    <macro name="bgtl-"     rule=": any(r.r): bcl- 12,1,$1" />
    <macro name="blel"      rule=": any(r.r): bcl 4,1,$1" />
    <macro name="blel+"     rule=": any(r.r): bcl+ 4,1,$1" />
    <macro name="blel-"     rule=": any(r.r): bcl- 4,1,$1" />
	<macro name="bf"        rule=": any(r): bc 4,0,$1" />
	<macro name="bf+"       rule=": any(r): bc+ 4,0,$1" />
	<macro name="bf-"       rule=": any(r): bc- 4,0,$1" />
	<macro name="bfa"       rule=": any(r): bca 4,0,$1" />
	<macro name="bfa+"      rule=": any(r): bca+ 4,0,$1" />
	<macro name="bfa-"      rule=": any(r): bca- 4,0,$1" />
	<macro name="bfctr"     rule="r=[0:31]: const(r): bcctr 4,$1" />
	<macro name="bfctr+"    rule="r=[0:31]: const(r): bcctr+ 4,$1" />
	<macro name="bfctr-"    rule="r=[0:31]: const(r): bcctr- 4,$1" />
	<macro name="bfctrl"    rule="r=[0:31]: const(r): bcctrl 4,$1" />
	<macro name="bfctrl+"   rule="r=[0:31]: const(r): bcctrl+ 4,$1" />
	<macro name="bfctrl-"   rule="r=[0:31]: const(r): bcctrl- 4,$1" />
	<macro name="bfl"       rule=": any(r): bcl 4,0,$1" />
	<macro name="bfl+"      rule=": any(r): bcl+ 4,0,$1" />
	<macro name="bfl-"      rule=": any(r): bcl- 4,0,$1" />
	<macro name="bfla"      rule=": any(r): bcla 4,0,$1" />
	<macro name="bfla+"     rule=": any(r): bcla+ 4,0,$1" />
	<macro name="bfla-"     rule=": any(r): bcla- 4,0,$1" />
	<macro name="bflr"      rule="r=[0:31]: const(r): bclr 4,$1" />
	<macro name="bflr+"     rule="r=[0:31]: const(r): bclr+ 4,$1" />
	<macro name="bflr-"     rule="r=[0:31]: const(r): bclr- 4,$1" />
	<macro name="bflrl"     rule="r=[0:31]: const(r): bclrl 4,$1" />
	<macro name="bflrl+"    rule="r=[0:31]: const(r): bclrl+ 4,$1" />
	<macro name="bflrl-"    rule="r=[0:31]: const(r): bclrl- 4,$1" />
	<macro name="bgectr"    rule="crf(r): crf(r): bcctr 4,($1*4)" />
	<macro name="bgectr+"   rule="crf(r): crf(r): bcctr+ 4,($1*4)" />
	<macro name="bgectr-"   rule="crf(r): crf(r): bcctr- 4,($1*4)" />
	<macro name="bgectrl"   rule="crf(r): crf(r): bcctrl 4,($1*4)" />
	<macro name="bgectrl+"  rule="crf(r): crf(r): bcctrl+ 4,($1*4)" />
	<macro name="bgectrl-"  rule="crf(r): crf(r): bcctrl- 4,($1*4)" />
	<macro name="bgtctr"    rule="crf(r): crf(r): bcctr 12,1+($1*4)" />
	<macro name="bgtctr+"   rule="crf(r): crf(r): bcctr+ 12,1+($1*4)" />
	<macro name="bgtctr-"   rule="crf(r): crf(r): bcctr- 12,1+($1*4)" />
	<macro name="bgtctrl"   rule="crf(r): crf(r): bcctrl 12,1+($1*4)" />
	<macro name="bgtctrl+"  rule="crf(r): crf(r): bcctrl+ 12,1+($1*4)" />
	<macro name="bgtctrl-"  rule="crf(r): crf(r): bcctrl- 12,1+($1*4)" />
	<macro name="blectr"    rule="crf(r): crf(r): bcctr 4,1+($1*4)" />
	<macro name="blectr+"   rule="crf(r): crf(r): bcctr+ 4,1+($1*4)" />
	<macro name="blectr-"   rule="crf(r): crf(r): bcctr- 4,1+($1*4)" />
	<macro name="blectrl"   rule="crf(r): crf(r): bcctrl 4,1+($1*4)" />
	<macro name="blectrl+"  rule="crf(r): crf(r): bcctrl+ 4,1+($1*4)" />
	<macro name="blectrl-"  rule="crf(r): crf(r): bcctrl- 4,1+($1*4)" />
	<macro name="btctr"     rule="r=[0:31]: const(r): bcctr 12,$1" />
	<macro name="btctr+"    rule="r=[0:31]: const(r): bcctr+ 12,$1" />
	<macro name="btctr-"    rule="r=[0:31]: const(r): bcctr- 12,$1" />
	<macro name="btctrl"    rule="r=[0:31]: const(r): bcctrl 12,$1" />
	<macro name="btctrl+"   rule="r=[0:31]: const(r): bcctrl+ 12,$1" />
	<macro name="btctrl-"   rule="r=[0:31]: const(r): bcctrl- 12,$1" />
	<macro name="btlr"      rule="r=[0:31]: const(r): bclr 12,$1" />
	<macro name="btlr+"     rule="r=[0:31]: const(r): bclr+ 12,$1" />
	<macro name="btlr-"     rule="r=[0:31]: const(r): bclr- 12,$1" />
	<macro name="btlrl"     rule="r=[0:31]: const(r): bclrl 12,$1" />
	<macro name="btlrl+"    rule="r=[0:31]: const(r): bclrl+ 12,$1" />
	<macro name="btlrl-"    rule="r=[0:31]: const(r): bclrl- 12,$1" />
	<macro name="bt"        rule=": any(r): bc 12,0,$1" />
	<macro name="bt+"       rule=": any(r): bc+ 12,0,$1" />
	<macro name="bt-"       rule=": any(r): bc- 12,0,$1" />
	<macro name="bta"       rule=": any(r): bca 12,0,$1" />
	<macro name="bta+"      rule=": any(r): bca+ 12,0,$1" />
	<macro name="bta-"      rule=": any(r): bca- 12,0,$1" />
	<macro name="btl"       rule=": any(r): bcl 12,0,$1" />
	<macro name="btl+"      rule=": any(r): bcl+ 12,0,$1" />
	<macro name="btl-"      rule=": any(r): bcl- 12,0,$1" />
	<macro name="btla"      rule=": any(r): bcla 12,0,$1" />
	<macro name="btla+"     rule=": any(r): bcla+ 12,0,$1" />
	<macro name="btla-"     rule=": any(r): bcla- 12,0,$1" />
	<macro name="bltctr"    rule="crf(r): crf(r): bcctr 12,0+($1*4)" />
	<macro name="bltctr+"   rule="crf(r): crf(r): bcctr+ 12,0+($1*4)" />
	<macro name="bltctr-"   rule="crf(r): crf(r): bcctr- 12,0+($1*4)" />
	<macro name="bltctrl"   rule="crf(r): crf(r): bcctrl 12,0+($1*4)" />
	<macro name="bltctrl+"  rule="crf(r): crf(r): bcctrl+ 12,0+($1*4)" />
	<macro name="bltctrl-"  rule="crf(r): crf(r): bcctrl- 12,0+($1*4)" />
	<macro name="bnectr"    rule="crf(r): crf(r): bcctr 4,2+($1*4)" />
	<macro name="bnectr+"   rule="crf(r): crf(r): bcctr+ 4,2+($1*4)" />
	<macro name="bnectr-"   rule="crf(r): crf(r): bcctr- 4,2+($1*4)" />
	<macro name="bnectrl"   rule="crf(r): crf(r): bcctrl 4,2+($1*4)" />
	<macro name="bnectrl+"  rule="crf(r): crf(r): bcctrl+ 4,2+($1*4)" />
	<macro name="bnectrl-"  rule="crf(r): crf(r): bcctrl- 4,2+($1*4)" />
	<macro name="bngctr"    rule="crf(r): crf(r): bcctr 4,1+($1*4)" />
	<macro name="bngctr+"   rule="crf(r): crf(r): bcctr+ 4,1+($1*4)" />
	<macro name="bngctr-"   rule="crf(r): crf(r): bcctr- 4,1+($1*4)" />
	<macro name="bngctrl"   rule="crf(r): crf(r): bcctrl 4,1+($1*4)" />
	<macro name="bngctrl+"  rule="crf(r): crf(r): bcctrl+ 4,1+($1*4)" />
	<macro name="bngctrl-"  rule="crf(r): crf(r): bcctrl- 4,1+($1*4)" />
	<macro name="bnlctr"    rule="crf(r): crf(r): bcctr 4,0+($1*4)" />
	<macro name="bnlctr+"   rule="crf(r): crf(r): bcctr+ 4,0+($1*4)" />
	<macro name="bnlctr-"   rule="crf(r): crf(r): bcctr- 4,0+($1*4)" />
	<macro name="bnlctrl"   rule="crf(r): crf(r): bcctrl 4,0+($1*4)" />
	<macro name="bnlctrl+"  rule="crf(r): crf(r): bcctrl+ 4,0+($1*4)" />
	<macro name="bnlctrl-"  rule="crf(r): crf(r): bcctrl- 4,0+($1*4)" />
	<macro name="bnsctr"    rule="crf(r): crf(r): bcctr 4,3+($1*4)" />
	<macro name="bnsctr+"   rule="crf(r): crf(r): bcctr+ 4,3+($1*4)" />
	<macro name="bnsctr-"   rule="crf(r): crf(r): bcctr- 4,3+($1*4)" />
	<macro name="bnsctrl"   rule="crf(r): crf(r): bcctrl 4,3+($1*4)" />
	<macro name="bnsctrl+"  rule="crf(r): crf(r): bcctrl+ 4,3+($1*4)" />
	<macro name="bnsctrl-"  rule="crf(r): crf(r): bcctrl- 4,3+($1*4)" />
	<macro name="bnuctr"    rule="crf(r): crf(r): bcctr 4,3+($1*4)" />
	<macro name="bnuctr+"   rule="crf(r): crf(r): bcctr+ 4,3+($1*4)" />
	<macro name="bnuctr-"   rule="crf(r): crf(r): bcctr- 4,3+($1*4)" />
	<macro name="bnuctrl"   rule="crf(r): crf(r): bcctrl 4,3+($1*4)" />
	<macro name="bnuctrl+"  rule="crf(r): crf(r): bcctrl+ 4,3+($1*4)" />
	<macro name="bnuctrl-"  rule="crf(r): crf(r): bcctrl- 4,3+($1*4)" />
	<macro name="bsoctr"    rule="crf(r): crf(r): bcctr 12,3+($1*4)" />
	<macro name="bsoctr+"   rule="crf(r): crf(r): bcctr+ 12,3+($1*4)" />
	<macro name="bsoctr-"   rule="crf(r): crf(r): bcctr- 12,3+($1*4)" />
	<macro name="bsoctrl"   rule="crf(r): crf(r): bcctrl 12,3+($1*4)" />
	<macro name="bsoctrl+"  rule="crf(r): crf(r): bcctrl+ 12,3+($1*4)" />
	<macro name="bsoctrl-"  rule="crf(r): crf(r): bcctrl- 12,3+($1*4)" />
	<macro name="bunctr"    rule="crf(r): crf(r): bcctr 12,3+($1*4)" />
	<macro name="bunctr+"   rule="crf(r): crf(r): bcctr+ 12,3+($1*4)" />
	<macro name="bunctr-"   rule="crf(r): crf(r): bcctr- 12,3+($1*4)" />
	<macro name="bunctrl"   rule="crf(r): crf(r): bcctrl 12,3+($1*4)" />
	<macro name="bunctrl+"  rule="crf(r): crf(r): bcctrl+ 12,3+($1*4)" />
	<macro name="bunctrl-"  rule="crf(r): crf(r): bcctrl- 12,3+($1*4)" />
	</macro>
	<macro parse="PpcParseClass.DST"> 
	<macro name="crclr" rule="crf(l): crf(l): crxor $1,$1,$1" />
	<macro name="crset" rule="crf(l): crf(l): creqv $1,$1,$1" />
	</macro>
	<macro parse="PpcParseClass.UNARY">
	<macro name="crmove" rule="crf(l) && crf(r): crf(l) crf(r): cror $1,$2,$2" />
	<macro name="crnot"  rule="crf(l) && crf(r): crf(l) crf(r): crnor $1,$2,$2" />
	<macro name="la" 	 rule="l=R && noreloc(r) && offset(r)=const && base(r)=R: l(R) base(r) offset(r): addi $1,$2,$3" />
	</macro>
	<macro parse="PpcParseClass.SRC2">
	<macro name="bgea"	rule="crf(r) : crf(r) any(r.r) : bca 4,0+($1*4),$2" />
	<macro name="bgea+"	rule="crf(r) : crf(r) any(r.r) : bca+ 4,0+($1*4),$2" />
	<macro name="bgea-"	rule="crf(r) : crf(r) any(r.r) : bca- 4,0+($1*4),$2" />
	<macro name="tweqi"  rule="r=R && r.r=CONST: r(R) const(r.r) : twi 4,$1,$2" />
	<macro name="twgei"  rule="r=R && r.r=CONST: r(R) const(r.r) : twi 12,$1,$2" />
	<macro name="twgti"  rule="r=R && r.r=CONST: r(R) const(r.r) : twi 8,$1,$2" />
	<macro name="twlei"  rule="r=R && r.r=CONST: r(R) const(r.r) : twi 20,$1,$2" />
	<macro name="twlgei" rule="r=R && r.r=CONST: r(R) const(r.r) : twi 12,$1,$2" />
	<macro name="twlgti" rule="r=R && r.r=CONST: r(R) const(r.r) : twi 1,$1,$2" />
	<macro name="twllei" rule="r=R && r.r=CONST: r(R) const(r.r) : twi 6,$1,$2" />
	<macro name="twllti" rule="r=R && r.r=CONST: r(R) const(r.r) : twi 2,$1,$2" />
	<macro name="twlngi" rule="r=R && r.r=CONST: r(R) const(r.r) : twi 6,$1,$2" />
	<macro name="twlnli" rule="r=R && r.r=CONST: r(R) const(r.r) : twi 5,$1,$2" />
	<macro name="twlti"  rule="r=R && r.r=CONST: r(R) const(r.r) : twi 16,$1,$2" />
	<macro name="twnei"  rule="r=R && r.r=CONST: r(R) const(r.r) : twi 24,$1,$2" />
	<macro name="twngi"  rule="r=R && r.r=CONST: r(R) const(r.r) : twi 20,$1,$2" />
	<macro name="twnli"  rule="r=R && r.r=CONST	: r(R) const(r.r) : twi 12,$1,$2" />
	</macro>
	<macro parse="PpcParseClass.BCLR">
	<macro name="bdnzf"	    rule="r=[0:31]: const(r) any(r.r): bc 0,$1,$2" /> 
	<macro name="bdnzf+"	rule="r=[0:31]: const(r) any(r.r): bc+ 0,$1,$2" /> 
	<macro name="bdnzf-"	rule="r=[0:31]: const(r) any(r.r): bc- 0,$1,$2" /> 
	<macro name="bdnzfa"	rule="r=[0:31]: const(r) any(r.r): bca 0,$1,$2" /> 
	<macro name="bdnzfa+"	rule="r=[0:31]: const(r) any(r.r): bca+ 0,$1,$2" /> 
	<macro name="bdnzfa-"	rule="r=[0:31]: const(r) any(r.r): bca- 0,$1,$2" /> 
	<macro name="bdnzfl" 	rule="r=[0:31]: const(r) any(r.r): bcl 0,$1,$2" />
	<macro name="bdnzfl+" 	rule="r=[0:31]: const(r) any(r.r): bcl+ 0,$1,$2" />
	<macro name="bdnzfl-" 	rule="r=[0:31]: const(r) any(r.r): bcl- 0,$1,$2" />
	<macro name="bdnzfla" 	rule="r=[0:31]: const(r) any(r.r): bcla 0,$1,$2" />
	<macro name="bdnzfla+" 	rule="r=[0:31]: const(r) any(r.r): bcla+ 0,$1,$2" />
	<macro name="bdnzfla-" 	rule="r=[0:31]: const(r) any(r.r): bcla- 0,$1,$2" />
	<macro name="bdnzt" 	rule="r=[0:31]: const(r) any(r.r): bc 8,$1,$2" />
	<macro name="bdnzt+" 	rule="r=[0:31]: const(r) any(r.r): bc+ 8,$1,$2" />
	<macro name="bdnzt-" 	rule="r=[0:31]: const(r) any(r.r): bc- 8,$1,$2" />
	<macro name="bdnzta" 	rule="r=[0:31]: const(r) any(r.r): bca 8,$1,$2" />
	<macro name="bdnzta+" 	rule="r=[0:31]: const(r) any(r.r): bca+ 8,$1,$2" />
	<macro name="bdnzta-" 	rule="r=[0:31]: const(r) any(r.r): bca- 8,$1,$2" />
	<macro name="bdnztl" 	rule="r=[0:31]: const(r) any(r.r): bcl 8,$1,$2" />
	<macro name="bdnztl+" 	rule="r=[0:31]: const(r) any(r.r): bcl+ 8,$1,$2" />
	<macro name="bdnztl-" 	rule="r=[0:31]: const(r) any(r.r): bcl- 8,$1,$2" />
	<macro name="bdnztla" 	rule="r=[0:31]: const(r) any(r.r): bcla 8,$1,$2" />
	<macro name="bdnztla+" 	rule="r=[0:31]: const(r) any(r.r): bcla+ 8,$1,$2" />
	<macro name="bdnztla-" 	rule="r=[0:31]: const(r) any(r.r): bcla- 8,$1,$2" />
	<macro name="bdzf" 	    rule="r=[0:31]: const(r) any(r.r): bc 2,$1,$2" />
	<macro name="bdzf+" 	rule="r=[0:31]: const(r) any(r.r): bc+ 2,$1,$2" />
	<macro name="bdzf-" 	rule="r=[0:31]: const(r) any(r.r): bc- 2,$1,$2" />
	<macro name="bdzfa" 	rule="r=[0:31]: const(r) any(r.r): bca 2,$1,$2" />
	<macro name="bdzfa+" 	rule="r=[0:31]: const(r) any(r.r): bca+ 2,$1,$2" />
	<macro name="bdzfa-" 	rule="r=[0:31]: const(r) any(r.r): bca- 2,$1,$2" />
	<macro name="bdzfl" 	rule="r=[0:31]: const(r) any(r.r): bcl 2,$1,$2" />
	<macro name="bdzfl+" 	rule="r=[0:31]: const(r) any(r.r): bcl+ 2,$1,$2" />
	<macro name="bdzfl-" 	rule="r=[0:31]: const(r) any(r.r): bcl- 2,$1,$2" />
	<macro name="bdzfla" 	rule="r=[0:31]: const(r) any(r.r): bcla 2,$1,$2" />
	<macro name="bdzfla+" 	rule="r=[0:31]: const(r) any(r.r): bcla+ 2,$1,$2" />
	<macro name="bdzfla-" 	rule="r=[0:31]: const(r) any(r.r): bcla- 2,$1,$2" />
	<macro name="bdzt" 	    rule="r=[0:31]: const(r) any(r.r): bc 10,$1,$2" />
	<macro name="bdzt+" 	rule="r=[0:31]: const(r) any(r.r): bc+ 10,$1,$2" />
	<macro name="bdzt-" 	rule="r=[0:31]: const(r) any(r.r): bc- 10,$1,$2" />
	<macro name="bdzta" 	rule="r=[0:31]: const(r) any(r.r): bca 10,$1,$2" />
	<macro name="bdzta+" 	rule="r=[0:31]: const(r) any(r.r): bca+ 10,$1,$2" />
	<macro name="bdzta-" 	rule="r=[0:31]: const(r) any(r.r): bca- 10,$1,$2" />
	<macro name="bdztl" 	rule="r=[0:31]: const(r) any(r.r): bcl 10,$1,$2" />
	<macro name="bdztl+" 	rule="r=[0:31]: const(r) any(r.r): bcl+ 10,$1,$2" />
	<macro name="bdztl-" 	rule="r=[0:31]: const(r) any(r.r): bcl- 10,$1,$2" />
	<macro name="bdztla" 	rule="r=[0:31]: const(r) any(r.r): bcla 10,$1,$2" />
	<macro name="bdztla+" 	rule="r=[0:31]: const(r) any(r.r): bcla+ 10,$1,$2" />
	<macro name="bdztla-" 	rule="r=[0:31]: const(r) any(r.r): bcla- 10,$1,$2" />
	<macro name="beqa"      rule="crf(r): crf(r) any(r.r): bca 12,$1*4,$2" />
	<macro name="beqa+"     rule="crf(r): crf(r) any(r.r): bca+ 12,$1*4,$2" />
	<macro name="beqa-"     rule="crf(r): crf(r) any(r.r): bca- 12,$1*4,$2" />
	<macro name="beql"      rule="crf(r): crf(r) any(r.r): bcl 12,2+($1*4),$2" />
	<macro name="beql+"     rule="crf(r): crf(r) any(r.r): bcl+ 12,2+($1*4),$2" />
	<macro name="beql-"     rule="crf(r): crf(r) any(r.r): bcl- 12,2+($1*4),$2" />
	<macro name="beqla"     rule="crf(r): crf(r) any(r.r): bcla 12,2+($1*4),$2" />
	<macro name="beqla+"    rule="crf(r): crf(r) any(r.r): bcla+ 12,2+($1*4),$2" />
	<macro name="beqla-"    rule="crf(r): crf(r) any(r.r): bcla- 12,2+($1*4),$2" />
	<macro name="bf"        rule="r=[0:31]: const(r) any(r.r): bc 4,$1,$2" />
	<macro name="bf+"       rule="r=[0:31]: const(r) any(r.r): bc+ 4,$1,$2" />
	<macro name="bf-"       rule="r=[0:31]: const(r) any(r.r): bc- 4,$1,$2" />
	<macro name="bfa"       rule="r=[0:31]: const(r) any(r.r): bca 4,$1,$2" />
	<macro name="bfa+"      rule="r=[0:31]: const(r) any(r.r): bca+ 4,$1,$2" />
	<macro name="bfa-"      rule="r=[0:31]: const(r) any(r.r): bca- 4,$1,$2" />
	<macro name="bfl"       rule="r=[0:31]: const(r) any(r.r): bcl 4,$1,$2" />
	<macro name="bfl+"      rule="r=[0:31]: const(r) any(r.r): bcl+ 4,$1,$2" />
	<macro name="bfl-"      rule="r=[0:31]: const(r) any(r.r): bcl- 4,$1,$2" />
	<macro name="bfla"      rule="r=[0:31]: const(r) any(r.r): bcla 4,$1,$2" />
	<macro name="bfla+"     rule="r=[0:31]: const(r) any(r.r): bcla+ 4,$1,$2" />
	<macro name="bfla-"     rule="r=[0:31]: const(r) any(r.r): bcla- 4,$1,$2" />
	<macro name="bgel"      rule="crf(r): crf(r) any(r.r): bcl 4,$1*4,$2" />
	<macro name="bgel+"     rule="crf(r): crf(r) any(r.r): bcl+ 4,$1*4,$2" />
	<macro name="bgel-"     rule="crf(r): crf(r) any(r.r): bcl- 4,$1*4,$2" />
	<macro name="bgela"      rule="crf(r): crf(r) any(r.r): bcla 4,$1*4,$2" />
	<macro name="bgela+"     rule="crf(r): crf(r) any(r.r): bcla+ 4,$1*4,$2" />
	<macro name="bgela-"     rule="crf(r): crf(r) any(r.r): bcla- 4,$1*4,$2" />
	<macro name="bgta"      rule="crf(r): crf(r) any(r.r): bca 12,1+($1*4),$2" />
	<macro name="bgta+"     rule="crf(r): crf(r) any(r.r): bca+ 12,1+($1*4),$2" />
	<macro name="bgta-"     rule="crf(r): crf(r) any(r.r): bca- 12,1+($1*4),$2" />
	<macro name="bgtl"      rule="crf(r): crf(r) any(r.r): bcl 12,1+($1*4),$2" />
	<macro name="bgtl+"     rule="crf(r): crf(r) any(r.r): bcl+ 12,1+($1*4),$2" />
	<macro name="bgtl-"     rule="crf(r): crf(r) any(r.r): bcl- 12,1+($1*4),$2" />
	<macro name="bgtla"     rule="crf(r): crf(r) any(r.r): bcla 12,1+($1*4),$2" />
	<macro name="bgtla+"    rule="crf(r): crf(r) any(r.r): bcla+ 12,1+($1*4),$2" />
	<macro name="bgtla-"    rule="crf(r): crf(r) any(r.r): bcla- 12,1+($1*4),$2" />
	<macro name="blea"      rule="crf(r): crf(r) any(r.r): bca 4,1+($1*4),$2" />
	<macro name="blea+"     rule="crf(r): crf(r) any(r.r): bca+ 4,1+($1*4),$2" />
	<macro name="blea-"     rule="crf(r): crf(r) any(r.r): bca- 4,1+($1*4),$2" />
	<macro name="blel"      rule="crf(r): crf(r) any(r.r): bcl 4,1+($1*4),$2" />
	<macro name="blel+"     rule="crf(r): crf(r) any(r.r): bcl+ 4,1+($1*4),$2" />
	<macro name="blel-"     rule="crf(r): crf(r) any(r.r): bcl- 4,1+($1*4),$2" />
	<macro name="blela"     rule="crf(r): crf(r) any(r.r): bcla 4,1+($1*4),$2" />
	<macro name="blela+"    rule="crf(r): crf(r) any(r.r): bcla+ 4,1+($1*4),$2" />
	<macro name="blela-"    rule="crf(r): crf(r) any(r.r): bcla- 4,1+($1*4),$2" />
	<macro name="blta"      rule="r=[0:31]: const(r) any(r.r): bca 12,$1,$2" />
	<macro name="blta+"     rule="r=[0:31]: const(r) any(r.r): bca+ 12,$1,$2" />
	<macro name="blta-"     rule="r=[0:31]: const(r) any(r.r): bca- 12,$1,$2" />
	<macro name="bltl"      rule="crf(r): crf(r) any(r.r): bcl 12,0+($1*4),$2" />
	<macro name="bltl+"     rule="crf(r): crf(r) any(r.r): bcl+ 12,0+($1*4),$2" />
	<macro name="bltl-"     rule="crf(r): crf(r) any(r.r): bcl- 12,0+($1*4),$2" />
	<macro name="bltla"     rule="crf(r): crf(r) any(r.r): bcla 12,0+($1*4),$2" />
	<macro name="bltla+"    rule="crf(r): crf(r) any(r.r): bcla+ 12,0+($1*4),$2" />
	<macro name="bltla-"    rule="crf(r): crf(r) any(r.r): bcla- 12,0+($1*4),$2" />
	<macro name="bnea"      rule="crf(r): crf(r) any(r.r): bca 4,2+($1*4),$2" />
	<macro name="bnea+"     rule="crf(r): crf(r) any(r.r): bca+ 4,2+($1*4),$2" />
	<macro name="bnea-"     rule="crf(r): crf(r) any(r.r): bca- 4,2+($1*4),$2" />
	<macro name="bnel"      rule="crf(r): crf(r) any(r.r): bcl 4,2+($1*4),$2" />
	<macro name="bnel+"     rule="crf(r): crf(r) any(r.r): bcl+ 4,2+($1*4),$2" />
	<macro name="bnel-"     rule="crf(r): crf(r) any(r.r): bcl- 4,2+($1*4),$2" />
	<macro name="bnela"     rule="crf(r): crf(r) any(r.r): bcla 4,2+($1*4),$2" />
	<macro name="bnela+"    rule="crf(r): crf(r) any(r.r): bcla+ 4,2+($1*4),$2" />
	<macro name="bnela-"    rule="crf(r): crf(r) any(r.r): bcla- 4,2+($1*4),$2" />
	<macro name="bnga"      rule="crf(r): crf(r) any(r.r): bca 4,1+($1*4),$2" />
	<macro name="bnga+"     rule="crf(r): crf(r) any(r.r): bca+ 4,1+($1*4),$2" />
	<macro name="bnga-"     rule="crf(r): crf(r) any(r.r): bca- 4,1+($1*4),$2" />
	<macro name="bngl"      rule="crf(r): crf(r) any(r.r): bcl 4,1+($1*4),$2" />
	<macro name="bngl+"     rule="crf(r): crf(r) any(r.r): bcl+ 4,1+($1*4),$2" />
	<macro name="bngl-"     rule="crf(r): crf(r) any(r.r): bcl- 4,1+($1*4),$2" />
	<macro name="bngla"     rule="crf(r): crf(r) any(r.r): bcla 4,1+($1*4),$2" />
	<macro name="bngla+"    rule="crf(r): crf(r) any(r.r): bcla+ 4,1+($1*4),$2" />
	<macro name="bngla-"    rule="crf(r): crf(r) any(r.r): bcla- 4,1+($1*4),$2" />
	<macro name="bnla"      rule="crf(r): crf(r) any(r.r): bca 4,0+($1*4),$2" />
	<macro name="bnla+"     rule="crf(r): crf(r) any(r.r): bca+ 4,0+($1*4),$2" />
	<macro name="bnla-"     rule="crf(r): crf(r) any(r.r): bca- 4,0+($1*4),$2" />
	<macro name="bnll"      rule="crf(r): crf(r) any(r.r): bcl 4,0+($1*4),$2" />
	<macro name="bnll+"     rule="crf(r): crf(r) any(r.r): bcl+ 4,0+($1*4),$2" />
	<macro name="bnll-"     rule="crf(r): crf(r) any(r.r): bcl- 4,0+($1*4),$2" />
	<macro name="bnlla"     rule="crf(r): crf(r) any(r.r): bcla 4,0+($1*4),$2" />
	<macro name="bnlla+"    rule="crf(r): crf(r) any(r.r): bcla+ 4,0+($1*4),$2" />
	<macro name="bnlla-"    rule="crf(r): crf(r) any(r.r): bcla- 4,0+($1*4),$2" />
	<macro name="bnsa"      rule="crf(r): crf(r) any(r.r): bca 4,3+($1*4),$2" />
	<macro name="bnsa+"     rule="crf(r): crf(r) any(r.r): bca+ 4,3+($1*4),$2" />
	<macro name="bnsa-"     rule="crf(r): crf(r) any(r.r): bca- 4,3+($1*4),$2" />
	<macro name="bnsl"      rule="crf(r): crf(r) any(r.r): bcl 4,3+($1*4),$2" />
	<macro name="bnsl+"     rule="crf(r): crf(r) any(r.r): bcl+ 4,3+($1*4),$2" />
	<macro name="bnsl-"     rule="crf(r): crf(r) any(r.r): bcl- 4,3+($1*4),$2" />
	<macro name="bnsla"     rule="crf(r): crf(r) any(r.r): bcla 4,3+($1*4),$2" />
	<macro name="bnsla+"    rule="crf(r): crf(r) any(r.r): bcla+ 4,3+($1*4),$2" />
	<macro name="bnsla-"    rule="crf(r): crf(r) any(r.r): bcla- 4,3+($1*4),$2" />
	<macro name="bnua"      rule="crf(r): crf(r) any(r.r): bca 4,3+($1*4),$2" />
	<macro name="bnua+"     rule="crf(r): crf(r) any(r.r): bca+ 4,3+($1*4),$2" />
	<macro name="bnua-"     rule="crf(r): crf(r) any(r.r): bca- 4,3+($1*4),$2" />
	<macro name="bnul"      rule="crf(r): crf(r) any(r.r): bcl 4,3+($1*4),$2" />
	<macro name="bnul+"     rule="crf(r): crf(r) any(r.r): bcl+ 4,3+($1*4),$2" />
	<macro name="bnul-"     rule="crf(r): crf(r) any(r.r): bcl- 4,3+($1*4),$2" />
	<macro name="bnula"     rule="crf(r): crf(r) any(r.r): bcla 4,3+($1*4),$2" />
	<macro name="bnula+"    rule="crf(r): crf(r) any(r.r): bcla+ 4,3+($1*4),$2" />
	<macro name="bnula-"    rule="crf(r): crf(r) any(r.r): bcla- 4,3+($1*4),$2" />
	<macro name="bsoa"      rule="crf(r): crf(r) any(r.r): bca 12,3+($1*4),$2" />
	<macro name="bsoa+"     rule="crf(r): crf(r) any(r.r): bca+ 12,3+($1*4),$2" />
	<macro name="bsoa-"     rule="crf(r): crf(r) any(r.r): bca- 12,3+($1*4),$2" />
	<macro name="bsol"      rule="crf(r): crf(r) any(r.r): bcl 12,3+($1*4),$2" />
	<macro name="bsol+"     rule="crf(r): crf(r) any(r.r): bcl+ 12,3+($1*4),$2" />
	<macro name="bsol-"     rule="crf(r): crf(r) any(r.r): bcl- 12,3+($1*4),$2" />
	<macro name="bsola"     rule="crf(r): crf(r) any(r.r): bcla 12,3+($1*4),$2" />
	<macro name="bsola+"    rule="crf(r): crf(r) any(r.r): bcla+ 12,3+($1*4),$2" />
	<macro name="bsola-"    rule="crf(r): crf(r) any(r.r): bcla- 12,3+($1*4),$2" />
	<macro name="bt"        rule="r=[0:31]: const(r) any(r.r): bc 12,$1,$2" />
	<macro name="bt+"       rule="r=[0:31]: const(r) any(r.r): bc+ 12,$1,$2" />
	<macro name="bt-"       rule="r=[0:31]: const(r) any(r.r): bc- 12,$1,$2" />
	<macro name="bta"       rule="r=[0:31]: const(r) any(r.r): bca 12,$1,$2" />
	<macro name="bta+"      rule="r=[0:31]: const(r) any(r.r): bca+ 12,$1,$2" />
	<macro name="bta-"      rule="r=[0:31]: const(r) any(r.r): bca- 12,$1,$2" />
	<macro name="btl"      rule="r=[0:31]: const(r) any(r.r): bcl 12,$1,$2" />
	<macro name="btl+"     rule="r=[0:31]: const(r) any(r.r): bcl+ 12,$1,$2" />
	<macro name="btl-"     rule="r=[0:31]: const(r) any(r.r): bcl- 12,$1,$2" />
	<macro name="btla"      rule="r=[0:31]: const(r) any(r.r): bcla 12,$1,$2" />
	<macro name="btla+"     rule="r=[0:31]: const(r) any(r.r): bcla+ 12,$1,$2" />
	<macro name="btla-"     rule="r=[0:31]: const(r) any(r.r): bcla- 12,$1,$2" />
	<macro name="buna"      rule="crf(r): crf(r) any(r.r): bca 12,3+($1*4),$2" />
	<macro name="buna+"     rule="crf(r): crf(r) any(r.r): bca+ 12,3+($1*4),$2" />
	<macro name="buna-"     rule="crf(r): crf(r) any(r.r): bca- 12,3+($1*4),$2" />
	<macro name="bunl"      rule="crf(r): crf(r) any(r.r): bcl 12,3+($1*4),$2" />
	<macro name="bunl+"     rule="crf(r): crf(r) any(r.r): bcl+ 12,3+($1*4),$2" />
	<macro name="bunl-"     rule="crf(r): crf(r) any(r.r): bcl- 12,3+($1*4),$2" />
	<macro name="bunla"     rule="crf(r): crf(r) any(r.r): bcla 12,3+($1*4),$2" />
	<macro name="bunla+"    rule="crf(r): crf(r) any(r.r): bcla+ 12,3+($1*4),$2" />
	<macro name="bunla-"    rule="crf(r): crf(r) any(r.r): bcla- 12,3+($1*4),$2" />
	</macro>
</cond>
	<macro parse="PpcParseClass.BINARY">
	<macro name="subi"  rule="l=R && r=R && r.r=CONST: l(R) r(R) const(r.r) : addi $1,$2,-1*$3" />
	<macro name="subis" rule="l=R && r=R && r.r=CONST: l(R) r(R) const(r.r) : addis $1,$2,-1*$3" />
	<macro name="subic" rule="l=R && r=R && r.r=CONST: l(R) r(R) const(r.r) : addic $1,$2,-1*$3" />
	<macro name="subic." rule="l=R && r=R && r.r=CONST: l(R) r(R) const(r.r) : addic. $1,$2,-1*$3" />
	<macro name="rotlwi" rule="l=R && r=R && r.r=[0:31]: l(R) r(R) const(r.r) : rlwinm  $1,$2,$3,0,31" />
	<macro name="rotlwi." rule="vle(0)=0 && l=R && r=R && r.r=[0:31]: l(R) r(R) const(r.r) : rlwinm. $1,$2,$3,0,31" />
	<macro name="rotrwi" rule="l=R && r=R && r.r=[0:31]: l(R) r(R) const(r.r) : rlwinm  $1,$2,32-$3,0,31" />
	<macro name="rotrwi." rule="vle(0)=0 && l=R && r=R && r.r=[0:31]: l(R) r(R) const(r.r) : rlwinm. $1,$2,32-$3,0,31" />
	<macro name="rotlw" rule="l=R && r=R && r.r=CONST: l(R) r(R) const(r.r) : rlwinm  $1,$2,$3,0,31" />
	<macro name="rotlw." rule="vle(0)=0 && l=R && r=R && r.r=CONST: l(R) r(R) const(r.r): rlwinm. $1,$2,$3,0,31" />
	<macro name="srwi"  rule="l=R && r=R && r.r=[0:31]: l(R) r(R) const(r.r) : rlwinm $1,$2,32-$3,$3,31" />
	<macro name="srwi." rule="vle(0)=0 && l=R && r=R && r.r=[0:31]: l(R) r(R) const(r.r) : rlwinm. $1,$2,32-$3,$3,31" />
	<macro name="clrlwi"  rule="l=R && r=R && r.r=[0:31]: l(R) r(R) const(r.r) : rlwinm $1,$2,0,$3,31" />
	<macro name="clrlwi."  rule="vle(0)=0 && l=R && r=R && r.r=[0:31]: l(R) r(R) const(r.r) : rlwinm. $1,$2,0,$3,31" />
	<macro name="clrrwi"  rule="l=R && r=R && r.r=[0:31]: l(R) r(R) const(r.r) : rlwinm $1,$2,0,0,31-$3" />
	<macro name="clrrwi."  rule="vle(0)=0 && l=R && r=R && r.r=[0:31]: l(R) r(R) const(r.r) : rlwinm. $1,$2,0,0,31-$3" />
	</macro>
	<macro parse="PpcParseClass.TERNARY">
	<macro name="extlwi" rule="l=R && r=R && r.r=[0:31] && r.r.r=CONST: l(R) r(R) const(r.r) const(r.r.r): rlwinm $1,$2,$4,0,$3-1" />
	<macro name="extlwi." rule="vle(0)=0 && l=R && r=R && r.r=[0:31] && r.r.r=CONST: l(R) r(R) const(r.r) const(r.r.r): rlwinm. $1,$2,$4,0,$3-1" />
	<macro name="extrwi" rule="l=R && r=R && r.r=[0:31] && r.r.r=CONST: l(R) r(R) const(r.r) const(r.r.r): rlwinm $1,$2,$3+$4,32-$3,31" />
	<macro name="extrwi." rule="vle(0)=0 && l=R && r=R && r.r=[0:31] && r.r.r=CONST: l(R) r(R) const(r.r) const(r.r.r): rlwinm. $1,$2,$3+$4,32-$3,31" />
	<macro name="inslwi" rule="l=R && r=R && r.r=[0:31] && r.r.r=[0:31]: l(R) r(R) const(r.r) const(r.r.r): rlwinm $1,$2,32-$4,$4,($4+$3)-1" />
	<macro name="inslwi." rule="vle(0)=0 && l=R && r=R && r.r=[0:31] && r.r.r=[0:31]: l(R) r(R) const(r.r) const(r.r.r): rlwinm. $1,$2,32-$4,$4,($4+$3)-1" />
	<macro name="insrwi" rule="l=R && r=R && r.r=[0:31] && r.r.r=CONST: l(R) r(R) const(r.r) const(r.r.r): rlwinm $1,$2,32-($4+$3),$4,($4+$3)-1" />
	<macro name="insrwi." rule="vle(0)=0 && l=R && r=R && r.r=[0:31] && r.r.r=CONST: l(R) r(R) const(r.r) const(r.r.r): rlwinm. $1,$2,32-($4+$3),$4,($4+$3)-1" />
	<macro name="clrlslwi" rule="l=R && r=R && r.r=[0:31] && r.r.r=[0:31]: l(R) r(R) const(r.r) const(r.r.r): rlwinm $1,$2,$3,$4-$3,31-$4" />
	<macro name="clrlslwi." rule="vle(0)=0 && l=R && r=R && r.r=[0:31] && r.r.r=[0:31]: l(R) r(R) const(r.r) const(r.r.r): rlwinm. $1,$2,$3,$4-$3,31-$4" />
	</macro>
<cond when="!Processor.VLE">
	<macro parse="PpcParseClass.COMPARE">
	  <macro rule="#r=3 && crf(r) && r.r=R">
	  <macro name="cmplw" rule="r.r.r=R: crf(r) r.r(R) r.r.r(R): .diab.cmpl  cr$1,$2,$3" />
	  </macro>
	</macro>
</cond>

<macro parse="PpcParseClass.SRC2">
	<macro name="tweq"  rule="r=R && r.r=R: r(R)  r.r(R): tw 4,$1,$2" />
	<macro name="twge"  rule="r=R && r.r=R: r(R) r.r(R) : tw 12,$1,$2" />
	<macro name="twgt"  rule="r=R && r.r=R: r(R) r.r(R) : tw 8,$1,$2" />
	<macro name="twle"  rule="r=R && r.r=R: r(R) r.r(R) : tw 20,$1,$2" />
	<macro name="twlge" rule="r=R && r.r=R: r(R) r.r(R) : tw 12,$1,$2" />
	<macro name="twlgt" rule="r=R && r.r=R: r(R) r.r(R) : tw 1,$1,$2" />
	<macro name="twlle" rule="r=R && r.r=R: r(R) r.r(R) : tw 6,$1,$2" />
	<macro name="twllt" rule="r=R && r.r=R: r(R) r.r(R) : tw 2,$1,$2" />
	<macro name="twlng" rule="r=R && r.r=R: r(R) r.r(R) : tw 6,$1,$2" />
	<macro name="twlnl" rule="r=R && r.r=R: r(R) r.r(R) : tw 5,$1,$2" />
	<macro name="twlt"  rule="r=R && r.r=R: r(R) r.r(R) : tw 16,$1,$2" />
	<macro name="twne"  rule="r=R && r.r=R: r(R) r.r(R) : tw 24,$1,$2" />
	<macro name="twng"  rule="r=R && r.r=R: r(R) r.r(R) : tw 20,$1,$2" />
	<macro name="twnl"  rule="r=R && r.r=R: r(R) r.r(R) : tw 12,$1,$2" />
</macro>
<macro parse="PpcParseClass.BINARY">
	<macro name="sub"    rule="l=R && r=R && r.r=R: l(R) r(R) r.r(R) : subf $1,$3,$2" />
	<macro name="sub."   rule="l=R && r=R && r.r=R: l(R) r(R) r.r(R) : subf. $1,$3,$2" />
	<macro name="subo"   rule="l=R && r=R && r.r=R: l(R) r(R) r.r(R) : subf $1,$3,$2" />
	<macro name="subo."  rule="l=R && r=R && r.r=R: l(R) r(R) r.r(R) : subf. $1,$3,$2" />
	<macro name="subc"   rule="l=R && r=R && r.r=R: l(R) r(R) r.r(R) : subfc $1,$3,$2" />
	<macro name="subc."  rule="l=R && r=R && r.r=R: l(R) r(R) r.r(R) : subfc. $1,$3,$2" />
	<macro name="subco"  rule="l=R && r=R && r.r=R: l(R) r(R) r.r(R) : subfco $1,$3,$2" />
	<macro name="subco." rule="l=R && r=R && r.r=R: l(R) r(R) r.r(R) : subfco. $1,$3,$2" />
</macro>

<cond when="Processor.SPE">
<macro parse="PpcParseClass.UNARY">
	<macro name="evmr"   rule="l=R && r=R: l(R) r(R): evor $1,$2,$2" />
	<macro name="evnot"  rule="l=R && r=R: l(R) r(R): evnor $1,$2,$2" />
</macro>
<macro parse="PpcParseClass.BINARY">
	<macro name="evsubiw" 	rule="l=R && r=R && r.r=CONST: l(R) r(R) const(r.r): evsubifw $1,$3,$2" />
	<macro name="evsubw" 	rule="l=R && r=R && r.r=R: l(R) r(R) r.r(R): evsubfw $1,$3,$2" />
</macro>
</cond>
<cond when="Processor.AltiVec">
<macro parse="PpcParseClass.VXFORMDS">
	<macro name="vmr"    rule="l=V && r=V: l(V) r(V): vor $1,$2,$2" />
	<macro name="vnot"   rule="l=V && r=V: l(V) r(V): vnor $1,$2,$2" />
</macro>
</cond>

<cond when="Processor.VLE">
	<macro parse="PpcParseClass.BINARY">
	<macro name="iseleq" rule="l=R && r=R && r.r=R: l(R) r(R) r.r(R): isel $1,$2,$3,2" />
	<macro name="iselgt" rule="l=R && r=R && r.r=R: l(R) r(R) r.r(R): isel $1,$2,$3,1" />
	<macro name="isellt" rule="l=R && r=R && r.r=R: l(R) r(R) r.r(R): isel $1,$2,$3,0" />
	</macro>
	<macro parse="PpcParseClass.EMPTY">
	<macro name="trap"  rule=":: tw 31,0,0" />
	<macro name="e_nop" rule=":: e_ori 0,0,0" />
	</macro>
	<macro parse="PpcParseClass.UNARY">
	<macro name="e_sub2i." rule="l=R && r=CONST: l(R) const(r): e_add2i. $1,-1*$2" />
	<macro name="e_sub2is" rule="l=R && r=CONST: l(R) const(r): e_add2is $1,-1*$2" />
	</macro>
	<macro parse="PpcParseClass.SRC">
	<macro name="e_bdnz"    rule=": any(r) : e_bc 2,0,$1" />
	<macro name="e_bdnzl"   rule=": any(r): e_bcl 2,0,$1" />
	<macro name="e_bdz"     rule=": any(r) : e_bc 3,0,$1" />
	<macro name="e_bdzl"    rule=": any(r) : e_bcl 3,0,$1" />
	<macro name="e_beql"    rule=": any(r) : e_bcl 1,2,$1" />
	<macro name="e_bgel"	rule=": any(r) : e_bcl 0,0,$1" />
	<macro name="e_bgtl"	rule=": any(r) : e_bcl 1,1,$1" />
	<macro name="e_blel"	rule=": any(r) : e_bcl 0,1,$1" />
	<macro name="e_bltl"	rule=": any(r) : e_bcl 1,0,$1" />
	<macro name="e_bnel"	rule=": any(r) : e_bcl 0,2,$1" />
	<macro name="e_bnll"	rule=": any(r) : e_bcl 0,0,$1" />
	<macro name="e_bnsl"	rule=": any(r) : e_bcl 0,3,$1" />
	<macro name="e_bnul"	rule=": any(r) : e_bcl 0,3,$1" />
	<macro name="e_bsol"	rule=": any(r) : e_bcl 1,3,$1" />
	<macro name="e_bunl"	rule=": any(r) : e_bcl 1,3,$1" />
	</macro>
	<macro parse="PpcParseClass.BCLR">
	<macro name="e_bf"   rule="r=[0:15]: const(r) any(r.r): e_bc 0,$1,$2" />
	<macro name="e_bfl"  rule="r=[0:15]: const(r) any(r.r): e_bcl 0,$1,$2" />
	<macro name="e_bt"   rule="r=[0:15]: const(r) any(r.r): e_bc 1,$1,$2" />
	<macro name="e_btl"  rule="r=[0:15]: const(r) any(r.r): e_bcl 1,$1,$2" />
	<macro name="se_bf"  rule="r=[0:3]: const(r) any(r.r): se_bc 0,$1,$2" />
	<macro name="se_bt"  rule="r=[0:3]: const(r) any(r.r): se_bc 1,$1,$2" />
	</macro>
	<macro parse="PpcParseClass.UNARY">
	<macro name="e_la"  rule="l=R && noreloc(r) && offset(r)=const && base(r)=R: l(R) base(r) offset(r): e_add16i $1,$2,$3" />
	</macro>
	<macro parse="PpcParseClass.BINARY">
	<macro name="e_sub16i" rule="l=R && r=R && r.r=CONST: l(R) r(R) const(r.r): e_add16i $1,$2,-1*$3" />
	<macro name="e_subi"   rule="l=R && r=R && r.r=CONST: l(R) r(R) const(r.r): e_addi $1,$2,-1*$3" />
	<macro name="e_subic"  rule="l=R && r=R && r.r=CONST: l(R) r(R) const(r.r): e_addic $1,$2,-1*$3" />
	<macro name="e_subic." rule="l=R && r=R && r.r=CONST: l(R) r(R) const(r.r): e_addic. $1,$2,-1*$3" />
	<macro name="e_rotlwi" rule="l=R && r=R && r.r=[0:31]: l(R) r(R) const(r.r): e_rlwinm $1,$2,$3,0,31" />
	<macro name="e_rotrwi" rule="l=R && r=R && r.r=[0:31]: l(R) r(R) const(r.r): e_rlwinm $1,$2,32-$3,0,31" />
	<macro name="e_slwi"   rule="l=R && r=R && r.r=[0:31]: l(R) r(R) const(r.r): e_rlwinm $1,$2,$3,0,31-$3" />
	<macro name="e_srwi"   rule="l=R && r=R && r.r=[0:31]: l(R) r(R) const(r.r): e_rlwinm $1,$2,32-$3,$3,31" />
	<macro name="e_clrlwi" rule="l=R && r=R && r.r=[0:31]: l(R) r(R) const(r.r): e_rlwinm $1,$2,0,$3,31" />
	<macro name="e_clrrwi" rule="l=R && r=R && r.r=[0:31]: l(R) r(R) const(r.r): e_rlwinm $1,$2,0,0,32-$3" />
	</macro>
	<macro parse="PpcParseClass.SRC3">
	<macro name="e_cmpwi"   rule="crf(r) && r.r=R && r.r.r=CONST: crf(r) r.r(R) const(r.r.r): e_cmpi $1,$2,$3" />
	<macro name="e_cmpwi"   rule="r=cr0 && r.r=R && r.r.r=CONST: r.r(R) const(r.r.r): e_cmpi $1,$2" />
	<macro name="e_cmplwi"  rule="crf(r) && r.r=R && r.r.r=CONST: crf(r) r.r(R) const(r.r.r): e_cmpli $1,$2,$3" />
	<macro name="e_cmplwi"  rule="r=cr0 && r.r=R && r.r.r=CONST: r.r(R) const(r.r.r): e_cmpli $1,$2" />
	</macro>
	<macro parse="PpcParseClass.TERNARY">
	<macro name="e_extlwi"   rule="l=R && r=R && r.r=[0:31] && r.r.r=[-16:15]: l(R) r(R) const(r.r) const(r.r.r): e_rlwinm $1,$2,$4,0,$3-1" />
	<macro name="e_extrwi"   rule="l=R && r=R && r.r=[0:31] && r.r.r=[-16:15]: l(R) r(R) const(r.r) const(r.r.r): e_rlwinm $1,$2,$3+$4,32-$3,31" />
	<macro name="e_inslwi"   rule="l=R && r=R && r.r=[0:31] && r.r.r=[-16:15]: l(R) r(R) const(r.r) const(r.r.r): e_rlwimi $1,$2,32-$3,$4,($3+$4)-1" />
	<macro name="e_insrwi"   rule="l=R && r=R && r.r=[0:31] && r.r.r=[-16:15]: l(R) r(R) const(r.r) const(r.r.r): e_rlwimi $1,$2,32-($3+$4),$4,($3+$4)-1" />
	<macro name="e_clrlslwi" rule="l=R && r=R && r.r=[0:31] && r.r.r=[0:31]: l(R) r(R) const(r.r) const(r.r.r): e_rlwinm $1,$2,$4,$3-$4,31-$4" />
	</macro>
</cond>
<!-- End append the simplified mnemonics for PPC instruction -->


    <expand>
    	<expand ivalue="POP.DIAB_LOADLA" rule="stinfo(1)=[-32768:32763]: stinfo(1): lwz r0,$1+4(r1)" />
    	<expand ivalue="POP.DIAB_LOADLA" rule=": stinfo(1): li r0,$1+4 ; lwzx r0,r1,r0" />

	<expand ivalue="POP.CMPW" rule="l=C">
	    <expand set="F.SIGNED"	rule="r=R && r.r=[-32768:32767]	: crf(l) r(R) const(r.r) : cmpi	  $1,0,$2,$3" />
	    <expand set="F.SIGNED"	rule="r=R && r.r=R		: crf(l) r(R) r.r(R)	 : cmp	  $1,0,$2,$3" />
	    <expand unset="F.SIGNED"	rule="r=R && r.r=[0:65535]	: crf(l) r(R) const(r.r) : cmpli  $1,0,$2,$3" />
	    <expand unset="F.SIGNED"	rule="r=R && r.r=R		: crf(l) r(R) r.r(R)	 : cmpl	  $1,0,$2,$3" />
	</expand>
	<expand ivalue="POP.DIAB_LA_HALO"	rule="l=R : l(R) any(r)	: lis $1,($2)@ha ; addi $1,$1,($2)@l" />

	<expand ivalue="POP.DIAB_LI_SPE" rule="l=R && r=CONST && r.r=CONST: l(R) const(r) const(r.r): diab.li $1,$2 ; evmergelo $1,$1,$1 ; diab.li $1,$3" paranoia="1" />

<cond when="!Processor.VLE">
    	<expand rule="l=R && r=CONST">
    	    <expand ivalue="POP.LOADCONST" rule="r=[-32768:32767]: l(R) const(r): li $1,$2" />		<!-- addi  d,r0,num -->
    	    <expand ivalue="POP.LOADCONST" rule="lis(r)          : l(R) lis(r)  : lis $1,$2" />	<!-- addis d,r0,num -->
    	    <expand ivalue="POP.LOADCONST" rule="l=R             : l(R) const(r): lis $1,$2>>16 ; ori $1,$1, $2 & 0xffff" />
    	</expand>
	<!-- TODO disallow r0 and check for low half zero -->
	<expand rule="l=R && r=R && r!=r0 && r.r=CONST && r.r!=[-32768:32767]">
	    <expand ivalue="POP.ADD" rule="lis(r.r): l(R) r(R) lis(r.r): addis $1,$2,$3" />
	    <expand ivalue="POP.ADD" rule="l!=r1: l(R) r(R) const(r.r): addis $1,$2,$3@ha ; addi $1,$1,$3@l" /> <!-- non automic add not for SP -->
	    <expand ivalue="POP.ADD" rule="l=r1: r(R) const(r.r): li r0,$2 ; add r1,$1,r0" />
	</expand>
</cond>
<cond when="Processor.VLE">
	<expand ivalue="POP.ADD" rule="l=R && l=r && r.r=CONST && r.r!=[-32768:32767]: l(R) const(r.r): e_add2is $1,$2@ha ; e_add16i $1,$1,$2@l" />
	<expand ivalue="POP.ADD" rule="l=R && l=R && r=R && r.r=CONST && r.r!=[-32768:32767]: l(R) r(R) const(r.r): mr $1,$2 ; e_add2is $1,$3@ha ; e_add16i $1,$1,$3@l" />

	<expand ivalue="POP.CMPH" rule="l=C">
	    <expand set="F.SIGNED"	rule="l=cr0 && r=R && r.r=[-32768:32767]: r(R) const(r.r)    : e_cmph16i  $1,$2" />
	    <expand set="F.SIGNED"	rule="l=cr0 && r=T && r.r=T		: r(R) r.r(R)	     : se_cmph	  $1,$2" />
	    <expand set="F.SIGNED"	rule="r=R && r.r=R			: crf(l) r(R) r.r(R) : e_cmph	  $1,$2,$3" />
	    <expand unset="F.SIGNED"	rule="l=cr0 && r=R && r.r=[0:65535]	: r(R) const(r.r)    : e_cmphl16i $1,$2" />
	    <expand unset="F.SIGNED"	rule="l=cr0 && r=T && r.r=T		: r(R) r.r(R)	     : se_cmphl	  $1,$2" />
	    <expand unset="F.SIGNED"	rule="r=R && r.r=R			: crf(l) r(R) r.r(R) : e_cmphl	  $1,$2,$3" />
	</expand>
    	<expand ivalue="POP.LOADCONST" rule="r=CONST">
	    <expand rule="l=T && r=[0:127]: l(T) const(r): li $1,$2" /> <!-- se_li -->
	    <expand rule="l=T && oneset(r): l(T) const(r): li $1,$2" />	<!-- se_bgeni -->
	    <expand rule="l=T && bmaski(r): l(T) const(r): li $1,$2" />	<!-- se_bmaski TODO intrinsic -->
	    <expand rule="l=R && r=[-524288:524287] : l(R) const(r): li $1,$2" />	<!-- e_li TODO intrinsic -->
	    <expand rule="l=R && lis(r)	: l(R) lis(r)  : e_lis $1,$2" />	<!-- e_lis -->
	    <expand rule="l=R		: l(R) const(r): e_lis $1, $2 >> 16 ; ori $1,$1, $2 & 0xffff" />
    	</expand>
</cond>

	<expand ivalue="POP.FRAMEOFFSET" rule="l=R && r=R && r.r=CONST: l(R) const(r.r): li $1,$2" />
    </expand>

    <inst kind="K.NO_CSE|K.VOLATILE" cost="POC.ARITH" parse="PpcParseClass.EMPTY" ic="IC.DEF" traits="CH.PFIXED">
    	<inst kind="K.MEM_REF|K.MEM_KILL|K.NO_COPY">
	    <inst flags="F.SPADJ" ref="r1" def="r1">
		<inst name="frameallocreq"	pop="POP.FRAMEALLOC"	parse="PpcParseClass.SRC4"	tflag="PTF.FRAMEREQ" />
		<inst name="frameallocopt"	pop="POP.FRAMEALLOC"	parse="PpcParseClass.SRC4"	/>
		<inst name="framedealloc"	pop="POP.FRAMEDEALLOC"	/>
	    </inst>

		<!-- Code absolute far calls indirect through CTR -->

	    <inst name="diab.restm"		pop="POP.DIAB_RESTM"	parse="PpcParseClass.UNARY"	 def="Codefar.CTR" />
	    <inst name="diab.restm8"		pop="POP.DIAB_RESTM"	parse="PpcParseClass.EV64UNARY2" def="Codefar.CTR" />

	    <inst parse="PpcParseClass.SRC2">
	    	<inst name="diab.savem"		pop="POP.DIAB_SAVEM"					def="Codefar.CTR" />
	    	<inst name="diab.savem8"	pop="POP.DIAB_SAVEM"	parse="PpcParseClass.EV64SAVEM"	def="Codefar.CTR"/>

		<!-- TODO add directive XML file and delete this hack -->
		<inst name="d2loclist"		pop="POP.D2LOCLIST"	parse="PpcParseClass.SRC3" />
	    </inst>

	    <inst name="regsave"		pop="POP.REGSAVE"	parse="PpcParseClass.SRC2"	def="Codefar.CTR,lr" />
	    <inst name="regsave2"		pop="POP.REGSAVE2"	parse="PpcParseClass.SRC2"	def="Codefar.CTR,r0,r12,lr" />
	    <inst name="regrestore"		pop="POP.REGRESTORE"	parse="PpcParseClass.SRC"	def="Codefar.CTR,r12,lr" />
	</inst>
	<inst name="frameinfo"			pop="POP.FRAMEINFO"	parse="PpcParseClass.SRC45" />
    </inst>

    <inst kind="K.NO_CSE" cost="POC.ARITH" parse="PpcParseClass.EMPTY" ic="IC.BR">
	<inst name="bbelr"  /> <!-- Branch Buffer Entry Lock Reset -->
	<inst name="bblels" /> <!-- Branch Buffer Load Entry and Lock Set -->

    	<inst export="EXPORT.ASM1|EXPORT.REO" itype="LT.T_ZERO">
	    <inst name="nop"	ifunc="__nop(8 V [V])"  ic="IC.DEF" />
	    <inst name="wait"	ifunc="__wait(8 V [V])" ic="IC.SU1" />
    	</inst>

	<inst ic="IC.FSPR"> <!-- Handled in the SRU unit -->
	    <inst name="mfcr"	parse="PpcParseClass.DST" ref="cr0,cr1,cr2,cr3,cr4,cr5,cr6,cr7"
	        		export="EXPORT.ASM1"	ifunc="__mfcr(2083 V [i])" />

	    <inst kind="K.MEM_REF|K.MEM_KILL" export="EXPORT.ASM1" traits="CH.PCLEAR | CH.PFIXED" >
	        <inst name="mfmsr"	parse="PpcParseClass.DST" ref="msr"	ifunc="__mfmsr(2083 V [i])" />
	        <inst name="mtmsr"	parse="PpcParseClass.SRC" def="msr"	ifunc="__mtmsr(2091 i [V])" />
	        <inst name="isync"						ifunc="__isync(8 V [V])" />
	        <inst name="eieio"						ifunc="__eieio(8 V [V])" /> 
	        <inst name="msync"						ifunc="__msync(8 V [V])" ic="IC.ST" />
	        <inst name="sync"						ifunc="__sync(8 V [V])" />
	        <inst name="mbar"	parse="PpcParseClass.SRCOPT"		ifunc="__mbar(7 C2 [V])" ic="IC.ST" />
	    </inst>

	    <inst flags="F.RETURN|F.BRANCH|F.NOPASS" kind="K.MEM_REF|K.MEM_KILL" itype="LT.T_ZERO" export="EXPORT.REO">
	        <inst name="rfci"	def="msr"	ref="csrr0,csrr1,xer,lr,ctr"	/>
	        <inst name="rfdi"	def="msr"	ref="dsrr0,dsrr1,xer,lr,ctr"	/>
	        <inst name="rfgi"	def="msr"	ref="gsrr0,gsrr1,xer,lr,ctr"	/>
	        <inst name="rfi"	def="msr"	ref="srr0,srr1,xer,lr,ctr"	/>
	        <inst name="rfmci"	def="msr"	ref="mcsrr0,mcsrr1,xer,lr,ctr"	/>
	    </inst>
	</inst>
    </inst>

    <inst parse="PpcParseClass.DSTSRCOPT" cost="POC.ARITH" kind="K.NO_CSE" ic="IC.FSPR">
	<inst name="mftb"	ref="tbl" />
	<inst name="mftbl"	ref="tbl" />
	<inst name="mftbu"	ref="tbu" />
    </inst>

    <inst parse="PpcParseClass.UNARY" cost="POC.ARITH" ic="IC.DEF">
	<inst name="mr"		pop="POP.REGCOPY"	flags="F.DOTPOS" />
	<inst name="mr."				flags="F.DOTPOS" def="cr0" tflag="PTF.DEF_CR0" />
	<inst name="mfspr"	pop="POP.MFSPR"	export="EXPORT.ASM1"	ifunc="__mfspr(2016 C2048 [i])" ic="IC.FSPR" />
	<inst name="mtspr"	pop="POP.MTSPR" export="EXPORT.ASM1"	ifunc="__mtspr(2090 C2048 i [V])" ic="IC.TSPR" />
	<inst kind="K.NO_CSE|K.VOLATILE|K.MEM_KILL|K.MEM_REF|K.NO_COPY">
	    <inst name="mfdcr"			export="EXPORT.ASM1"	ifunc="__mfdcr(2016 C2048 [i])" ic="IC.FSPR" />
	    <inst name="mtdcr"			export="EXPORT.ASM1"	ifunc="__mtdcr(2090 C2048 i [V])" ic="IC.TSPR" />
	</inst>
	<inst name="mtcrf"	/>
	<inst name="diab.li"	pop="POP.LOADCONST" />
	<inst name="li"		pop="POP.LOADCONST" />
	<inst name="lis"	pop="POP.LIS" />
	<inst name="diab.la.halo" pop="POP.DIAB_LA_HALO" parse="PpcParseClass.D_SEA" tflag="PTF.D0NOTR0|PTF.RECOMPUTE" />

	<suffix name="PpcSoRc" ic="IC.DEF" >
		<inst name="addme"  flags="F.DOTPOS" def="CA" ref="CA" />
		<inst name="addze"  flags="F.DOTPOS" def="CA" ref="CA" />
		<inst name="subfze" flags="F.DOTPOS" def="CA" ref="CA" />
		<inst name="neg"    flags="F.DOTPOS" />
	</suffix>
	<suffix name="ClassicOnly.PpcRc" flags="F.DOTPOS" traits="CH.PURE">
		<inst name="extsb"  flags="F.SZ_ONE|F.SIGNED"	kind="K.SEXT"	pop="POP.EXTSB" size="1" ic="IC.DEF" />
		<inst name="extsh"  flags="F.SZ_TWO|F.SIGNED"	kind="K.SEXT"	pop="POP.EXTSH" size="2" ic="IC.DEF" />
		<inst name="extzb"  flags="F.SZ_ONE"		kind="K.ZEXT"	pop="POP.EXTZB" size="1" ic="IC.DEF" />
		<inst name="extzh"  flags="F.SZ_TWO"		kind="K.ZEXT"	pop="POP.EXTZH" size="2" ic="IC.DEF" />
	</suffix>
	<suffix name="PpcRc" flags="F.DOTPOS" traits="CH.PURE">
		<inst name="cntlzw" export="EXPORT.ASM1"	ifunc="__cntlzw(0 i [i])" ic="IC.DEF" pop="POP.CNTLZW" />
	</suffix>
    </inst>

    <inst cost="POC.MEM" kind="K.MEM_REF" parse="PpcParseClass.UNARY" name="diab.loadra" pop="POP.DIAB_LOADLA" />

    <inst cost="POC.MEM" flags="F.LD|F.R0IS0" ic="IC.LD" >
	<inst name="lbz"   parse="PpcParseClass.UNARY"	pop="POP.LOADB" size="1" flags="F.SZ_ONE" />
	<inst name="lbzu"  parse="PpcParseClass.UNARY"	pop="POP.LOADB" size="1" flags="F.SZ_ONE|F.UPDATE" />
	<inst name="lbzx"  parse="PpcParseClass.UNARY"	pop="POP.LOADB" size="1" flags="F.SZ_ONE" />
	<inst name="lbzux" parse="PpcParseClass.UNARY"	pop="POP.LOADB" size="1" flags="F.SZ_ONE|F.UPDATE" />

	<inst name="lha"   parse="PpcParseClass.UNARY"	pop="POP.LOADH" size="2" flags="F.SZ_TWO|F.SIGNED" />
	<inst name="lhau"  parse="PpcParseClass.UNARY"	pop="POP.LOADH" size="2" flags="F.SZ_TWO|F.SIGNED|F.UPDATE" />
	<inst name="lhax"  parse="PpcParseClass.UNARY"	pop="POP.LOADH" size="2" flags="F.SZ_TWO|F.SIGNED" export="EXPORT.SPE1"
		ifunc="__ev_get_s16(2030 eV i [h])"	/>
	<inst name="lhaux" parse="PpcParseClass.UNARY"	pop="POP.LOADH" size="2" flags="F.SZ_TWO|F.SIGNED|F.UPDATE" />

	<inst name="lhz"   parse="PpcParseClass.UNARY"	pop="POP.LOADH" size="2" flags="F.SZ_TWO" />
	<inst name="lhzu"  parse="PpcParseClass.UNARY"	pop="POP.LOADH" size="2" flags="F.SZ_TWO|F.UPDATE" />
	<inst name="lhzx"  parse="PpcParseClass.UNARY"	pop="POP.LOADH" size="2" flags="F.SZ_TWO" export="EXPORT.SPE1" ifunc="__ev_get_u16(2030 eV i [uh])"	/>
	<inst name="lhzux" parse="PpcParseClass.UNARY"	pop="POP.LOADH" size="2" flags="F.SZ_TWO|F.UPDATE" />

	<inst name="lwz"   parse="PpcParseClass.UNARY"	pop="POP.LOADW" size="4" flags="F.SZ_FOUR" />
	<inst name="lwzu"  parse="PpcParseClass.UNARY"	pop="POP.LOADW" size="4" flags="F.SZ_FOUR|F.UPDATE" />
	<inst name="lwzx"  parse="PpcParseClass.UNARY"	pop="POP.LOADW" size="4" flags="F.SZ_FOUR" />
	<inst name="lwzux" parse="PpcParseClass.UNARY"	pop="POP.LOADW" size="4" flags="F.SZ_FOUR|F.UPDATE" />

	<inst name="lhbrx" parse="PpcParseClass.UNARY"	size="2" flags="F.SZ_TWO"  kind="K.NO_CSE" />
	<inst name="lwarx" parse="PpcParseClass.UNARY"	size="4" flags="F.SZ_FOUR" kind="K.NO_CSE" />
	<inst name="lwbrx" parse="PpcParseClass.UNARY"	size="4" flags="F.SZ_FOUR" kind="K.NO_CSE" />

    	<inst kind="K.VOLATILE" parse="PpcParseClass.UNARY" export="EXPORT.ASM1">
	    <inst name="lbepx"	size="1" flags="F.SZ_ONE"	ifunc="__lbepx(2030 CVP i [c])"	/>
	    <inst name="ldepx"	size="8" flags="F.SZ_EIGHT"	/>
	    <inst name="lhepx"	size="2" flags="F.SZ_TWO"	ifunc="__lhepx(2030 CVP i [uh])"	/>
	    <inst name="lwepx"	size="4" flags="F.SZ_FOUR"	ifunc="__lwepx(2030 CVP i [i])"	/>
	    <inst name="lbdx"	size="1" flags="F.SZ_ONE"	ifunc="__lbdx(2030 CVP i [c])"	/>
	    <inst name="lddx"	size="8" flags="F.SZ_EIGHT"	/>
	    <inst name="lhdx"	size="2" flags="F.SZ_TWO"	ifunc="__lhdx(2030 CVP i [uh])"	/>
	    <inst name="lwdx"	size="4" flags="F.SZ_FOUR"	ifunc="__lwdx(2030 CVP i [i])"	/>
	</inst>
    </inst>

    <inst cost="POC.MEM" flags="F.R0IS0" ic="IC.LD">
	<inst name="lmw"    parse="PpcParseClass.UNARY"	 size="4" flags="F.LM" kind="K.NO_CSE" />
	<inst name="lswi"   parse="PpcParseClass.BINARY" kind="K.NO_CSE|K.MEM_REF|K.NO_COPY" pop="POP.LSWI" />
	<inst name="lswx"   parse="PpcParseClass.BINARY" kind="K.NO_CSE|K.MEM_REF|K.NO_COPY|K.VOLATILE" />
    </inst>
    <inst cost="POC.MEM" flags="F.R0IS0" ic="IC.ST">
	<inst name="stmw"   parse="PpcParseClass.STORE"	 size="4" flags="F.SM" kind="K.NO_CSE" />
	<inst name="stswi"  parse="PpcParseClass.STSW"	 kind="K.NO_CSE|K.MEM_KILL|K.NO_COPY" pop="POP.STSWI" />
	<inst name="stswx"  parse="PpcParseClass.STSW"	 kind="K.NO_CSE|K.MEM_KILL|K.NO_COPY|K.VOLATILE" />
    </inst>

    <inst cost="POC.MEM" flags="F.ST|F.R0IS0" parse="PpcParseClass.STORE" ic="IC.ST" >
	<inst pop="POP.STOREB" size="1" flags="F.SZ_ONE">
	    <inst name="stb"	/>
	    <inst name="stbu"	flags="F.UPDATE" />
	    <inst name="stbx"	/>
	    <inst name="stbux"	flags="F.UPDATE" />
	</inst>
	<inst pop="POP.STOREH" size="2" flags="F.SZ_TWO">
	    <inst name="sth"	/>
	    <inst name="sthu"	flags="F.UPDATE" />
	    <inst name="sthx"	export="EXPORT.SPE1" ifunc="__ev_set_s16(2023 eV h i [eV]);__ev_set_u16(2023 eV uh i [eV])"	/>
	    <inst name="sthux"	flags="F.UPDATE" />
	</inst>
	<inst pop="POP.STOREW" size="4" flags="F.SZ_FOUR">
	    <inst name="stw"   />
	    <inst name="stwu"  flags="F.UPDATE" />
	    <inst name="stwx"  />
	    <inst name="stwux" flags="F.UPDATE" />
	</inst>
	<inst name="sthbrx" size="2" flags="F.SZ_TWO"  kind="K.NO_CSE" />
	<inst name="stwbrx" size="4" flags="F.SZ_FOUR" kind="K.NO_CSE" />
	<inst name="stwcx." size="4" flags="F.SZ_FOUR" kind="K.NO_CSE" />
    	<inst kind="K.VOLATILE">
	    <!-- TODO add ifunc for each but need new intrinsic number -->
	    <inst name="stbepx"	size="1" flags="F.SZ_ONE"	/>
	    <inst name="stdepx"	size="8" flags="F.SZ_EIGHT"	/>
	    <inst name="sthepx"	size="2" flags="F.SZ_TWO"	/>
	    <inst name="stwepx"	size="4" flags="F.SZ_FOUR"	/>
	    <inst name="stbdx"	size="1" flags="F.SZ_ONE"	/>
	    <inst name="stddx"	size="8" flags="F.SZ_EIGHT"	/>
	    <inst name="sthdx"	size="2" flags="F.SZ_TWO"	/>
	    <inst name="stwdx"	size="4" flags="F.SZ_FOUR"	/>
	</inst>
    </inst>

    <inst parse="PpcParseClass.BINARY" cost="POC.MUL" ic="IC.MUL">
<cond when="!Processor.VLE">
	<inst name="mulli"  pop="POP.MUL"   flags="F.COMMUTE" />
</cond>
	<suffix name="PpcSoRc" flags="F.DOTPOS">
		<inst name="mullw"  pop="POP.MUL"  flags="F.COMMUTE" earlyOut="1" />
		<inst name="divw"   pop="POP.DIVS" flags="F.SIGNED" ic="IC.DIV" />
		<inst name="divwu"  pop="POP.DIVU" ic="IC.DIV" />
	</suffix>
	<suffix name="PpcRc" flags="F.DOTPOS">
		<inst name="mulhw"	pop="POP.MULHW"	 flags="F.COMMUTE|F.SIGNED" earlyOut="1" />
		<inst name="mulhwu"	pop="POP.MULHWU" flags="F.COMMUTE" earlyOut="1" />
	</suffix>
    </inst>

    <inst parse="PpcParseClass.BINARY" cost="POC.ARITH"		ic="IC.DEF">

	<inst pop="POP.CMPW" size="4"	flags="F.SZ_FOUR"	ic="IC.CMP">
	    <inst name=".diab.cmp"	flags="F.SIGNED" />
	    <inst name=".diab.cmpl"	flags="F.UNSIGNED" />
	</inst>
<cond when="Processor.VLE">
	<inst pop="POP.CMPH" size="2"	flags="F.SZ_TWO"	ic="IC.CMP">
	    <inst name=".diab.cmph"	flags="F.SIGNED" />
	    <inst name=".diab.cmphl"	flags="F.UNSIGNED" />
	</inst>
</cond>

	<inst name="addi"   pop="POP.ADD"   flags="F.COMMUTE|F.R0IS0" />
	<inst name="xori"   pop="POP.XOR"   flags="F.COMMUTE" />
<cond when="!Processor.VLE">
	<inst name="addis"  pop="POP.ADDIS" flags="F.COMMUTE|F.R0IS0" />
	<inst name="andi."  pop="POP.ANDIX"  def="cr0" tflag="PTF.DEF_CR0|PTF.CLEARUPPER" flags="F.COMMUTE" />
	<inst name="andis." pop="POP.ANDISX" def="cr0" tflag="PTF.DEF_CR0" flags="F.COMMUTE" />
	<inst name="ori"    pop="POP.OR"    flags="F.COMMUTE" tflag="PTF.CLEARUPPER" />
	<inst name="oris"   pop="POP.ORIS"  flags="F.COMMUTE" />
	<inst name="xori"   pop="POP.XOR"   flags="F.COMMUTE" tflag="PTF.CLEARUPPER" />
	<inst name="xoris"  pop="POP.XORIS" flags="F.COMMUTE" />
</cond>

	<inst name="frameoffset"	pop="POP.FRAMEOFFSET" />

	<suffix name="PpcSoRc" flags="F.DOTPOS">
		<inst name="add"    pop="POP.ADD"  flags="F.COMMUTE" />
		<inst name="addc"   pop="POP.ADDC" flags="F.COMMUTE" def="CA" />
		<inst name="adde"   def="CA" ref="CA" />
		<inst name="subf"   pop="POP.SUBF" />
		<inst name="subfc"  pop="POP.SUBFC" def="CA" />
		<inst name="subfe"  def="CA" ref="CA" />
		<inst name="subfme" parse="PpcParseClass.UNARY" def="CA" ref="CA" />
	</suffix>
	<inst name="subfic" def="CA" />
	<suffix name="PpcRc" flags="F.DOTPOS">
		<inst name="addic"	pop="POP.ADDIC" def="CA" />
	</suffix>
	<suffix name="PpcRc" flags="F.DOTPOS" traits="CH.PURE">
		<inst name="and"	pop="POP.AND" flags="F.COMMUTE" />
		<inst name="or"		pop="POP.OR"  flags="F.COMMUTE" />
		<inst name="xor"	pop="POP.XOR" flags="F.COMMUTE" />
		<inst name="nand"	pop="POP.NAND" flags="F.COMMUTE" />
		<inst name="nor"	pop="POP.NOR"  flags="F.COMMUTE" />
		<inst name="eqv"	flags="F.COMMUTE" export="EXPORT.ASM1"	ifunc="__eqv(0 i i [i])" />
		<inst name="andc"	pop="POP.ANDC" />
		<inst name="orc"	pop="POP.ORC" />
		<inst name="slw"	pop="POP.SHL" />
		<inst name="srw"	pop="POP.SHRL" />
		<inst name="srawi"			def="CA" />
		<inst name="sraw"	pop="POP.SRAW"	def="CA" />
	</suffix>
    </inst>

    <inst parse="PpcParseClass.COMPARE" cost="POC.ARITH" ic="IC.CMP">
	<inst name="cmp"   pop="POP.CMP" tflag="PTF.CMP|PTF.ICMP" flags="F.SIGNED" />
	<inst name="cmpi"  tflag="PTF.CMP|PTF.ICMP" flags="F.SIGNED" />
	<inst name="cmpl"  pop="POP.CMPL" tflag="PTF.CMP|PTF.ICMP" />
	<inst name="cmpli" tflag="PTF.CMP|PTF.ICMP|PTF.CLEARUPPER" />
    </inst>
    <inst parse="PpcParseClass.SRC3" cost="POC.BRANCH" flags="F.NOPASS" kind="K.NO_CSE|K.NO_COPY|K.VOLATILE|K.MEM_REF|K.MEM_KILL" ic="IC.DEF">
	<inst name="twi" tflag="PTF.BC" />
	<inst name="tw"	 tflag="PTF.BC" />
    </inst>
    <inst parse="PpcParseClass.SRC3" cost="POC.ARITH" kind="K.NO_CSE" ic="IC.COND">
	<inst name="crand"  tflag="PTF.CR3" />
	<inst name="crandc" tflag="PTF.CR3" />
	<inst name="cror"   tflag="PTF.CR3" />
	<inst name="crorc"  tflag="PTF.CR3" />
	<inst name="crxor"  tflag="PTF.CR3" />
	<inst name="crnand" tflag="PTF.CR3" />
	<inst name="crnor"  tflag="PTF.CR3" />
	<inst name="creqv"  tflag="PTF.CR3" />
    </inst>
    <inst parse="PpcParseClass.UNARY" cost="POC.ARITH" ic="IC.FSPR" >
	<inst name="mcrf" tflag="PTF.CR2" pop="POP.REGCOPY" />
    </inst>

    <inst parse="PpcParseClass.ROTATE" cost="POC.ARITH" ic="IC.DEF" >
	<suffix name="PpcRc" flags="F.DOTPOS">
		<inst name="rlwinm" pop="POP.RLWINM" />
		<inst name="rlwnm" />
	</suffix>
    </inst>
    <inst parse="PpcParseClass.INSERT" cost="POC.ARITH" ic="IC.DEF" >
	<suffix name="PpcRc" flags="F.DOTPOS">
		<inst name="rlwimi" />
	</suffix>
    </inst>

    <inst cost="POC.BRANCH" flags="F.BRANCH" ic="IC.BR" >
	<inst name="blr"    parse="PpcParseClass.EMPTY"	 flags="F.RETURN|F.NOPASS" pop="POP.BLR" ref="lr" />
	<inst name="b"	    parse="PpcParseClass.BRANCH" flags="F.UBR|F.NOPASS" />
	<inst name="ba"	    parse="PpcParseClass.BRANCH" flags="F.UBR|F.NOPASS" />
	<inst name="bl"	    parse="PpcParseClass.BRANCH" flags="F.BSR" def="lr" />
	<inst name="bla"    parse="PpcParseClass.BRANCH" flags="F.BSR" def="lr" />
	<inst name="bc"	    parse="PpcParseClass.SRC3"	 flags="F.BCND|F.NOPASS|F.BOBI" tflag="PTF.BC" />
	<inst name="bca"    parse="PpcParseClass.SRC3"	 flags="F.BCND|F.NOPASS|F.BOBI" tflag="PTF.BC" />
	<inst name="bcl"    parse="PpcParseClass.SRC3"	 flags="F.BCND|F.NOPASS|F.BOBI" tflag="PTF.BC" ref="lr" />
	<inst name="bcla"   parse="PpcParseClass.SRC3"	 flags="F.BCND|F.NOPASS|F.BOBI" tflag="PTF.BC" ref="lr" />
	<inst name="bc+"    parse="PpcParseClass.SRC3"	 flags="F.BCND|F.NOPASS|F.BOBI" tflag="PTF.BC" />
	<inst name="bc-"    parse="PpcParseClass.SRC3"	 flags="F.BCND|F.NOPASS|F.BOBI" tflag="PTF.BC" />
	<inst name="bca+"    parse="PpcParseClass.SRC3"	 flags="F.BCND|F.NOPASS|F.BOBI" tflag="PTF.BC" />
	<inst name="bca-"    parse="PpcParseClass.SRC3"	 flags="F.BCND|F.NOPASS|F.BOBI" tflag="PTF.BC" />
	<inst name="bcl+"    parse="PpcParseClass.SRC3"	 flags="F.BCND|F.NOPASS|F.BOBI" tflag="PTF.BC" ref="lr" />
	<inst name="bcl-"    parse="PpcParseClass.SRC3"	 flags="F.BCND|F.NOPASS|F.BOBI" tflag="PTF.BC" ref="lr" />
	<inst name="bcla+"   parse="PpcParseClass.SRC3"	 flags="F.BCND|F.NOPASS|F.BOBI" tflag="PTF.BC" ref="lr" />
	<inst name="bcla-"   parse="PpcParseClass.SRC3"	 flags="F.BCND|F.NOPASS|F.BOBI" tflag="PTF.BC" ref="lr" />
	<inst name="bcctr"  parse="PpcParseClass.BCLR"	 flags="F.BCND|F.NOPASS|F.BOBI" tflag="PTF.BC" ref="ctr" />
	<inst name="bcctr+"  parse="PpcParseClass.BCLR"	 flags="F.BCND|F.NOPASS|F.BOBI" tflag="PTF.BC" ref="ctr" />
	<inst name="bcctr-"  parse="PpcParseClass.BCLR"	 flags="F.BCND|F.NOPASS|F.BOBI" tflag="PTF.BC" ref="ctr" />
	<inst name="bcctrl" parse="PpcParseClass.BCLR"	 flags="F.BCND|F.NOPASS|F.BOBI|F.BSR" tflag="PTF.BC" ref="ctr" />
	<inst name="bcctrl+" parse="PpcParseClass.BCLR"	 flags="F.BCND|F.NOPASS|F.BOBI|F.BSR" tflag="PTF.BC" ref="ctr" />
	<inst name="bcctrl-" parse="PpcParseClass.BCLR"	 flags="F.BCND|F.NOPASS|F.BOBI|F.BSR" tflag="PTF.BC" ref="ctr" />
	<inst name="bclr"   parse="PpcParseClass.BCLR"	 flags="F.BCND|F.NOPASS|F.BOBI|F.RETURN" ref="lr" tflag="PTF.BC" />
	<inst name="bclr+"   parse="PpcParseClass.BCLR"	 flags="F.BCND|F.NOPASS|F.BOBI|F.RETURN" ref="lr" tflag="PTF.BC" />
	<inst name="bclr-"   parse="PpcParseClass.BCLR"	 flags="F.BCND|F.NOPASS|F.BOBI|F.RETURN" ref="lr" tflag="PTF.BC" />
	<inst name="bclrl"  parse="PpcParseClass.BCLR"	 flags="F.BCND|F.NOPASS|F.BOBI|F.BSR" ref="lr" tflag="PTF.BC" />
	<inst name="bclrl+"  parse="PpcParseClass.BCLR"	 flags="F.BCND|F.NOPASS|F.BOBI|F.BSR" ref="lr" tflag="PTF.BC" />
	<inst name="bclrl-"  parse="PpcParseClass.BCLR"	 flags="F.BCND|F.NOPASS|F.BOBI|F.BSR" ref="lr" tflag="PTF.BC" />

	<inst flags="F.BSR|F.NOPASS" kind="K.NO_CSE|K.MEM_REF|K.MEM_KILL" itype="LT.T_ZERO" ic="IC.BR">

	    <inst parse="PpcParseClass.EMPTY"	 export="EXPORT.ASM1|EXPORT.REO" ic="IC.SU1" itype="LT.T_ZERO">

	    	<!-- Hypervisor APU Generate Embedded Hypervisor Privilege Exception -->
	    	<inst name="ehpriv"	ifunc="__ehpriv(8 V [V])"	/>

	    </inst>

	    <!-- Hypervisor APU allows for a ICONST operand -->
	    <inst name="sc"	parse="PpcParseClass.SRCOPT"	/>
	</inst>
    </inst>

<cond when="!Processor.VLE">
    <inst cost="POC.MEM" flags="F.LD|F.R0IS0" tflag="PTF.FLOAT" parse="PpcParseClass.UNARY" ic="IC.LD" >
	<inst size="8" flags="F.SZ_EIGHT" pop="POP.LOADFD" tflag="PTF.D0IS64">
	    <inst name="lfd"	/>
	    <inst name="lfdu"	flags="F.UPDATE"	/>
	    <inst name="lfdux"	flags="F.UPDATE"	/>
	    <inst name="lfdx"	/>
	    <inst name="lfddx"	kind="K.VOLATILE"	/>
	    <inst name="lfdepx"	kind="K.VOLATILE"	/>
    	</inst>
	<inst size="4" flags="F.SZ_FOUR|F.SINGLE" pop="POP.LOADFS">
	    <inst name="lfs"   />
	    <inst name="lfsu"  flags="F.UPDATE"	/>
	    <inst name="lfsux" flags="F.UPDATE"	/>
	    <inst name="lfsx"  />
    	</inst>
    </inst>
    <inst cost="POC.MEM" flags="F.ST|F.R0IS0" tflag="PTF.FLOAT" parse="PpcParseClass.STORE" ic="IC.ST" >
	<inst size="8" flags="F.SZ_EIGHT" pop="POP.STOREFD">
	    <inst name="stfd"	 />
	    <inst name="stfdx"	 />
	    <inst name="stfdu"	 flags="F.UPDATE"	/>
	    <inst name="stfdux"	 flags="F.UPDATE"	/>
	    <inst name="stfddx"	 kind="K.VOLATILE"	/>
	    <inst name="stfdepx" kind="K.VOLATILE"	/>
	</inst>
	<inst size="4" flags="F.SZ_FOUR|F.SINGLE">
	    <inst name="stfs"    pop="POP.STOREFS" tflag="PTF.FSCVT" />
	    <inst name="stfsx"   pop="POP.STOREFS" tflag="PTF.FSCVT" />
	    <inst name="stfsu"   pop="POP.STOREFS" tflag="PTF.FSCVT" 	flags="F.UPDATE"	/>
	    <inst name="stfsux"  pop="POP.STOREFS" tflag="PTF.FSCVT" 	flags="F.UPDATE"	/>
	    <inst name="stfiwx"  />
	</inst>
    </inst>
    <inst parse="PpcParseClass.FCMP" cost="POC.FLOATOP" tflag="PTF.FLOAT" ic="IC.FCMP" >
		<inst name="fcmpu" tflag="PTF.CMP" />
		<inst name="fcmpo" tflag="PTF.CMP" />
    </inst>
    <inst parse="PpcParseClass.DST" cost="POC.FLOATOP" ic="IC.FLT">
	<suffix name="PpcFrc" flags="F.DOTPOS">
		<inst name="mffs" ref="fpscr" kind="K.NO_CSE" />
	</suffix>
    </inst>
    <inst parse="PpcParseClass.SRC" cost="POC.FLOATOP" ic="IC.FLT">
	<suffix name="PpcFrc" flags="F.DOTPOS">
		<inst name="mtfsfb0" def="fpscr" kind="K.NO_CSE" />
		<inst name="mtfsfb1" def="fpscr" kind="K.NO_CSE" />
	</suffix>
    </inst>
    <inst parse="PpcParseClass.SRC2" cost="POC.FLOATOP" ic="IC.FLT">
		<inst name="mcrfs" tflag="PTF.CMP" kind="K.NO_CSE" />
	<suffix name="PpcFrc" flags="F.DOTPOS">
		<inst name="mtfsf"  def="fpscr" kind="K.NO_CSE" />
		<inst name="mtfsfi" def="fpscr" kind="K.NO_CSE" />
	</suffix>
    </inst>
    <inst parse="PpcParseClass.UNARY" cost="POC.ARITH" tflag="PTF.FLOAT" ic="IC.FLT">
	<inst name="fmr"  pop="POP.REGCOPY"  />
	<inst name="fmr."			def="cr1" tflag="PTF.CR1"/>
    </inst>
    <inst parse="PpcParseClass.UNARY" cost="POC.FLOATOP" ic="IC.FLT" >
	<suffix name="PpcFrc" flags="F.DOTPOS">
		<inst name="fneg"	tflag="PTF.FLOAT"	pop="POP.FNEGATE" />
		<inst name="fabs"	tflag="PTF.FLOAT"	pop="POP.FABS" />
		<inst name="fnabs"	tflag="PTF.FLOAT" />
		<inst name="fres"	tflag="PTF.FLOAT" />
		<inst name="frsp"	tflag="PTF.FLOAT"	pop="POP.FRSP"	flags="F.SINGLE" />

		<!-- TODO should these be marked PTF.FLOAT -->
		<inst name="fctid" />
		<inst name="fctidz" />
		<inst name="fctiw" />
		<inst name="fctiwz" />
		<inst name="fcfid" />
	</suffix>
    </inst>
    <inst parse="PpcParseClass.BINARY" cost="POC.FLOATOP" tflag="PTF.FLOAT" ic="IC.FLT" >
	<suffix name="PpcFrc" flags="F.DOTPOS">
	    <inst tflag="PTF.D0IS64">
		<inst name="fadd" />
		<inst name="fsub" />
		<inst name="fmul" />
		<inst name="fdiv"	ic="IC.FDIV" />
	    </inst>
	    <inst flags="F.SINGLE">
		<inst name="fadds" />
		<inst name="fsubs" />
		<inst name="fmuls" />
		<inst name="fdivs"	ic="IC.FDIVS" />
	    </inst>
	</suffix>
    </inst>
    <inst parse="PpcParseClass.FMADD" cost="POC.FLOATOP"  tflag="PTF.FLOAT" ic="IC.FLT4" >
	<suffix name="PpcFrc" flags="F.DOTPOS">
	    <inst tflag="PTF.D0IS64">
		<inst name="fmadd" />
		<inst name="fnmadd" />
		<inst name="fmsub" />
		<inst name="fnmsub" />
	    </inst>
	    <inst flags="F.SINGLE">
		<inst name="fmadds"  />
		<inst name="fnmadds" />
		<inst name="fmsubs"  />
		<inst name="fnmsubs" />
	    </inst>
		<inst name="fsel" />
	</suffix>
    </inst>
</cond>

	<!-- E500 Instructions -->
    <inst parse="PpcParseClass.ISEL" flags="F.R0IS0" tflag="PTF.SEL" export="EXPORT.ISEL" ic="IC.DEF">
	<inst name="isel"	cost="POC.ARITH"	/>
    </inst>

    <inst parse="PpcParseClass.BINARY" cost="POC.ARITH" itype="LT.T_3OP" ic="IC.DEF" traits="CH.PURE">
	<inst name="brinc"	export="EXPORT.SPE2"	ifunc="__brinc(2008 ui ui [ui])" />
    </inst>

    <inst parse="PpcParseClass.SRC" cost="POC.ARITH" ic="IC.FSPR">
	<inst name="mcrxr"				/>
	<inst name="wrtee"	export="EXPORT.ASM1"	ifunc="__wrtee(2091 i [V])" ic="IC.SU1" />
	<inst name="wrteei"	export="EXPORT.ASM1"	ifunc="__wrteei(7 C2 [V])" />
    </inst>

    <inst kind="K.VOLATILE|K.NO_CSE" cost="POC.ARITH" flags="F.R0IS0" ic="IC.LD">
	<inst parse="PpcParseClass.SRC23" export="EXPORT.ASM1">
	    <inst name="dcba"		ifunc="__dcba(2094 CVP i [V])" />
	    <inst name="dcbf"		ifunc="__dcbf(2094 CVP i [V])" />
	    <inst name="dcbfep"		ifunc="__dcbfep(2094 CVP i [V])" />
	    <inst name="dcbi"		ifunc="__dcbi(2094 CVP i [V])" />
	    <inst name="dcblc"		ifunc="__dcblc(2095 C32 CVP i [V])" />
	    <inst name="dcbst"		ifunc="__dcbst(2094 CVP i [V])" />
	    <inst name="dcbstep"	ifunc="__dcbstep(2094 CVP i [V])" />
	    <inst name="dcbt"		ifunc="__dcbt(2095 C32 CVP i [V])" />
	    <inst name="dcbtep"		ifunc="__dcbtep(2095 C32 CVP i [V])" />
	    <inst name="dcbtls"		ifunc="__dcbtls(2095 C32 CVP i [V])" />
	    <inst name="dcbtst"		ifunc="__dcbtst(2095 C32 CVP i [V])" />
	    <inst name="dcbtstep"	ifunc="__dcbtstep(2095 C32 CVP i [V])" />
	    <inst name="dcbtstls"	ifunc="__dcbtstls(2095 C32 CVP i [V])" />
	    <inst name="dcbz"		ifunc="__dcbz(2094 CVP i [V])" />
	    <inst name="dcbzep"		ifunc="__dcbzep(2094 CVP i [V])" />
	    <inst name="dcbzl"		ifunc="__dcbzl(2094 CVP i [V])" />
	    <inst name="dcbzlep"	ifunc="__dcbzlep(2094 CVP i [V])" />
	    <inst name="dsn"		ifunc="__dsn(2094 CVP i [V])" />
	    <inst name="icbi"		ifunc="__icbi(2094 CVP i [V])" />
	    <inst name="icblc"		ifunc="__icblc(2095 C32 CVP i [V])" />
	    <inst name="icbt"		ifunc="__icbt(2095 C32 CVP i [V])" />
	    <inst name="icbtls"		ifunc="__icbtls(2095 C32 CVP i [V])" />
	    <inst name="icbiep"		ifunc="__icbiep(2094 CVP i [V])" />
	</inst>
    	<inst export="EXPORT.ASM1|EXPORT.REO">
	    <inst parse="PpcParseClass.SRC3" itype="LT.T_C_U_U">
		<inst name="tlbilx"	ifunc="__tlbilx(2095 C4 CVP i [V])"	/>
	    </inst>
	    <inst parse="PpcParseClass.SRC2" itype="LT.T_U_TWO">
		<inst name="tlbivax"	ifunc="__tlbivax(2094 CVP i [V])"	/>
		<inst name="tlbsx"	ifunc="__tlbsx(2094 CVP i [V])"	/>
	    </inst>
	    <inst parse="PpcParseClass.SRC3OPT" itype="LT.T_ZERO" kind="K.MEM_REF|K.MEM_KILL">
		<!-- IBM differs from Freescale for these next two -->
	        <inst name="tlbre"	ifunc="__tlbre(8 V [V])"	/>
	        <inst name="tlbwe"	ifunc="__tlbwe(8 V [V])"	/>
	    </inst>
	    <inst parse="PpcParseClass.EMPTY" itype="LT.T_ZERO" kind="K.MEM_REF|K.MEM_KILL">
	        <inst name="tlbsync"	ifunc="__tlbsync(8 V [V])"	/>
	    </inst>
	</inst>
    </inst>
    <inst kind="K.NO_CSE" cost="POC.ARITH" flags="F.R0IS0" parse="PpcParseClass.SRC" export="EXPORT.ASM1|EXPORT.REO" ic="IC.SU1" itype="LT.T_U_ONE">
	<inst name="msgclr"	ifunc="__msgclr(2091 i [V])" />
	<inst name="msgsnd"	ifunc="__msgsnd(2091 i [V])" />
    </inst>

	<!-- SPE SIMD -->
<cond when="Processor.SPE">
    <inst parse="PpcParseClass.EV64UNARY" cost="POC.FLOATOP" export="EXPORT.SPE1" ic="IC.MU6" itype="LT.T_2OP_EVACC">
	<inst name="efdabs"				/>
	<inst name="efdnabs"				/>
	<inst name="efdneg"				/>
    </inst>
    <inst parse="PpcParseClass.EV64UNARY2" cost="POC.FLOATOP" export="EXPORT.SPE1" ic="IC.MU6" itype="LT.T_2OP_EVACC">
	<inst name="efdcfs"				/>
	<inst name="efdcfsf"				/>
	<inst name="efdcfsi"				/>
	<inst name="efdcfuf"				/>
	<inst name="efdcfui"				/>
	<inst name="efdctsf"				/>
	<inst name="efdctsi"				/>
	<inst name="efdctsiz"				/>
	<inst name="efdctuf"				/>
	<inst name="efdctui"				/>
	<inst name="efdctuiz"				/>
    </inst>
    <inst parse="PpcParseClass.EV64UNARY3" cost="POC.FLOATOP" flags="F.SINGLE" export="EXPORT.SPE1" ic="IC.MU" itype="LT.T_2OP_EVACC">
	<inst name="efscfd"				/>
    </inst>
    <inst parse="PpcParseClass.UNARY" cost="POC.FLOATOP" flags="F.SINGLE" export="EXPORT.SPE1" ic="IC.MU" itype="LT.T_2OP">
	<inst name="efsabs"		ic="IC.DEF" 	/>
	<inst name="efscfsf"				/>
	<inst name="efscfsi"				/>
	<inst name="efscfuf"				/>
	<inst name="efscfui"				/>
	<inst name="efsctsf"				/>
	<inst name="efsctsi"				/>
	<inst name="efsctsiz"				/>
	<inst name="efsctuf"				/>
	<inst name="efsctui"				/>
	<inst name="efsctuiz"				/>
	<inst name="efsnabs"		ic="IC.DEF"	/>
	<inst name="efsneg"		ic="IC.DEF"	/>
    </inst>
    <inst parse="PpcParseClass.EV64BINARY" cost="POC.FLOATOP" ic="IC.MU6" itype="LT.T_3OP_EV">
	<inst name="diab.li.spe"	pop="POP.DIAB_LI_SPE" />
    </inst>
    <inst parse="PpcParseClass.EV64BINARY" cost="POC.FLOATOP" ic="IC.MU6" itype="LT.T_3OP_EV" export="EXPORT.SPE1">
        <inst kind="K.NO_CSE">
	    <inst name="efdadd"				/>
	    <inst name="efddiv"	ic="Efddiv.IC"		/>
	    <inst name="efdmul"				/>
	    <inst name="efdsub"				/>
	</inst>
        <inst flags="F.SINGLE" itype="LT.T_3OP" ic="IC.MU" parse="PpcParseClass.BINARY">
    	    <inst name="efsadd"				/>
    	    <inst name="efsdiv"	ic="IC.MU2"		/>
    	    <inst name="efsmul"				/>
    	    <inst name="efssub"				/>
        </inst>
    </inst>
    <inst parse="PpcParseClass.MAC3" cost="POC.FLOATOP" flags="F.SINGLE" export="EXPORT.SPE1" ic="IC.MU" itype="LT.T_DU_U_U">
	<inst name="efsmadd"				/>
	<inst name="efsnmadd"				/>
	<inst name="efsmsub"				/>
	<inst name="efsnmsub"				/>
    </inst>
    <inst parse="PpcParseClass.EVMAC3" cost="POC.FLOATOP" flags="F.SINGLE" export="EXPORT.SPE1" ic="IC.MU" itype="LT.T_DU_U_U">
	<inst name="evfsmadd"				/>
	<inst name="evfsnmadd"				/>
	<inst name="evfsmsub"				/>
	<inst name="evfsnmsub"				/>
    </inst>

    <inst parse="PpcParseClass.EV64COMPARE2" cost="POC.FLOATOP" tflag="PTF.CMP" export="EXPORT.SPE1" kind="K.NO_CSE" ic="IC.MU6" itype="LT.T_EV_VD_VU_VU">
	<inst name="efdcmpeq"				/>
	<inst name="efdcmpgt"				/>
	<inst name="efdcmplt"				/>
	<inst name="efdtsteq"				/>
	<inst name="efdtstgt"				/>
	<inst name="efdtstlt"				/>
    </inst>
    <inst parse="PpcParseClass.COMPARE2" cost="POC.FLOATOP" flags="F.SINGLE" tflag="PTF.CMP" export="EXPORT.SPE1" ic="IC.SU1" itype="LT.T_EV_VD_VU_VU">
	<inst name="efscmpeq"				/>
	<inst name="efscmpgt"				/>
	<inst name="efscmplt"				/>
	<inst name="efststeq"	ic="IC.DEF"		/>
	<inst name="efststgt"	ic="IC.DEF"		/>
	<inst name="efststlt"	ic="IC.DEF"		/>
    </inst>
    <inst parse="PpcParseClass.EV64ISEL" tflag="PTF.SEL" export="EXPORT.SPE1" ic="IC.SU1" itype="LT.T_3OP_CR">
	<inst name="evsel"	cost="POC.FLOATOP"	/>
    </inst>
    <inst parse="PpcParseClass.EV64UNARY" cost="POC.FLOATOP" export="EXPORT.SPE1" ic="IC.MU" itype="LT.T_2OP_EVACC">
	<inst name="evabs"	ic="IC.SU1"		ifunc="__ev_abs(0 eV [eV])"	traits="CH.PURE" />
	<inst name="evaddsmiaaw" ref="acc" def="acc"	ifunc="__ev_addsmfaaw(2000 eV [eV]);__ev_addsmiaaw(2000 eV [eV])"	/>
	<inst name="evaddssiaaw" ref="acc" def="acc"	ifunc="__ev_addssfaaw(2000 eV [eV]);__ev_addssiaaw(2000 eV [eV])"	/>
	<inst name="evaddumiaaw" ref="acc" def="acc"
		ifunc="__ev_addumfaaw(2000 eV [eV]);__ev_addumiaaw(2000 eV [eV]);__ev_mwhumiaaw(2041 eV eV [eV]);__ev_mwhumfaaw(2041 eV eV [eV])"	/>
	<inst name="evaddusiaaw" ref="acc" def="acc"
		ifunc="__ev_addusfaaw(2000 eV [eV]);__ev_addusiaaw(2000 eV [eV]);__ev_mwhusiaaw(2041 eV eV [eV]);__ev_mwhusfaaw(2041 eV eV [eV])"	/>
    	<inst ic="IC.SU1" traits="CH.PURE">
	    <inst name="evcntlsw"			ifunc="__ev_cntlsw(0 eV [eV])"	/>
	    <inst name="evcntlzw"			ifunc="__ev_cntlzw(0 eV [eV])"	/>
	    <inst name="evextsb"			ifunc="__ev_extsb(0 eV [eV])"	/>
	    <inst name="evextsh"			ifunc="__ev_extsh(0 eV [eV])"	/>
	    <inst name="evfsabs"			ifunc="__ev_fsabs(0 eV [eV])"	/>
    	</inst>
    	<inst ic="IC.MU" kind="K.NO_CSE" traits="CH.PURE">
	    <inst name="evfscfsf"			ifunc="__ev_fscfsf(0 eV [eV])" />
	    <inst name="evfscfsi"			ifunc="__ev_fscfsi(0 eV [eV])" />
	    <inst name="evfscfuf"			ifunc="__ev_fscfuf(0 eV [eV])" />
	    <inst name="evfscfui"			ifunc="__ev_fscfui(0 eV [eV])" />
	    <inst name="evfsctsf"			ifunc="__ev_fsctsf(0 eV [eV])" />
	    <inst name="evfsctsi"			ifunc="__ev_fsctsi(0 eV [eV])" />
	    <inst name="evfsctsiz"			ifunc="__ev_fsctsiz(0 eV [eV])" />
	    <inst name="evfsctuf"			ifunc="__ev_fsctuf(0 eV [eV])" />
	    <inst name="evfsctui"			ifunc="__ev_fsctui(0 eV [eV])" />
	    <inst name="evfsctuiz"			ifunc="__ev_fsctuiz(0 eV [eV])" />
	</inst>
    	<inst ic="IC.SU1" traits="CH.PURE">
	    <inst name="evfsnabs"			ifunc="__ev_fsnabs(0 eV [eV])"	/>
	    <inst name="evfsneg"			ifunc="__ev_fsneg(0 eV [eV])"	/>
	</inst>
	<inst name="evmra"	def="acc"		ifunc="__ev_mra(2000 eV [eV])"	/>
    	<inst ic="IC.SU1" itype="LT.T_2OP" traits="CH.PURE">
	    <inst name="evneg"				ifunc="__ev_neg(0 eV [eV])"	/>
	    <inst name="evrndw"				ifunc="__ev_rndw(0 eV [eV])"	/>
	</inst>
    	<inst ic="IC.SU1" itype="LT.T_D_IMM" traits="CH.PURE">
	    <inst name="evsplatfi"			ifunc="__ev_splatfi(2016 S32 [eV])"	/>
	    <inst name="evsplati"			ifunc="__ev_splati(2016 S32 [eV])"	/>
	</inst>
    	<inst kind="K.NO_CSE" ic="Evsubf.IC">
	    <inst name="evsubfsmiaaw" ref="acc" def="acc"	ifunc="__ev_subfsmfaaw(2000 eV [eV]);__ev_subfsmiaaw(2000 eV [eV])"	/>
	    <inst name="evsubfssiaaw" ref="acc" def="acc"	ifunc="__ev_subfssfaaw(2000 eV [eV]);__ev_subfssiaaw(2000 eV [eV])"	/>
	    <inst name="evsubfumiaaw" ref="acc" def="acc"
		ifunc="__ev_subfumfaaw(2000 eV [eV]);__ev_subfumiaaw(2000 eV [eV]);__ev_mwhumianw(2043 eV eV [eV]);__ev_mwhumfanw(2043 eV eV [eV])"	/>
	    <inst name="evsubfusiaaw" ref="acc" def="acc"
		ifunc="__ev_subfusfaaw(2000 eV [eV]);__ev_subfusiaaw(2000 eV [eV]);__ev_mwhusianw(2043 eV eV [eV]);__ev_mwhusfanw(2043 eV eV [eV])"	/>
	</inst>
    </inst>

    <inst parse="PpcParseClass.EV64COMPARE2" cost="POC.FLOATOP" tflag="PTF.CMP" export="EXPORT.SPE1" ic="IC.SU1" itype="LT.T_EV_VD_VU_VU" traits="CH.PURE">
	<inst name="evcmpeq"
		ifunc="__ev_all_eq(2058 eV eV [i]);__ev_any_eq(2058 eV eV [i]);__ev_lower_eq(2058 eV eV [i]);__ev_upper_eq(2058 eV eV [i]);__ev_select_eq(2019 eV eV eV eV [eV])"	/>
	<inst name="evcmpgts"
		ifunc="__ev_all_gts(2009 eV eV [i]);__ev_any_gts(2009 eV eV [i]);__ev_lower_gts(2009 eV eV [i]);__ev_upper_gts(2009 eV eV [i]);__ev_select_gts(2019 eV eV eV eV [eV])"	/>
	<inst name="evcmpgtu"
		ifunc="__ev_all_gtu(2009 eV eV [i]);__ev_any_gtu(2009 eV eV [i]);__ev_lower_gtu(2009 eV eV [i]);__ev_upper_gtu(2009 eV eV [i]);__ev_select_gtu(2019 eV eV eV eV [eV])"	/>
	<inst name="evcmplts"
		ifunc="__ev_all_lts(2009 eV eV [i]);__ev_any_lts(2009 eV eV [i]);__ev_lower_lts(2009 eV eV [i]);__ev_upper_lts(2009 eV eV [i]);__ev_select_lts(2019 eV eV eV eV [eV])"	/>
	<inst name="evcmpltu"
		ifunc="__ev_all_ltu(2009 eV eV [i]);__ev_any_ltu(2009 eV eV [i]);__ev_lower_ltu(2009 eV eV [i]);__ev_upper_ltu(2009 eV eV [i]);__ev_select_ltu(2019 eV eV eV eV [eV])"	/>
	<inst name="evfscmpeq" ic="IC.MU"
		ifunc="__ev_all_fs_eq(2009 eV eV [i]);__ev_any_fs_eq(2009 eV eV [i]);__ev_lower_fs_eq(2009 eV eV [i]);__ev_upper_fs_eq(2009 eV eV [i]);__ev_select_fs_eq(2019 eV eV eV eV [eV])"	/>
	<inst name="evfscmpgt" ic="IC.MU"
		ifunc="__ev_all_fs_gt(2009 eV eV [i]);__ev_any_fs_gt(2009 eV eV [i]);__ev_lower_fs_gt(2009 eV eV [i]);__ev_upper_fs_gt(2009 eV eV [i]);__ev_select_fs_gt(2019 eV eV eV eV [eV])"	/>
	<inst name="evfscmplt" ic="IC.MU"
		ifunc="__ev_all_fs_lt(2009 eV eV [i]);__ev_any_fs_lt(2009 eV eV [i]);__ev_lower_fs_lt(2009 eV eV [i]);__ev_upper_fs_lt(2009 eV eV [i]);__ev_select_fs_lt(2019 eV eV eV eV [eV])"	/>
	<inst name="evfststeq"
		ifunc="__ev_all_fs_tst_eq(2009 eV eV [i]);__ev_any_fs_tst_eq(2009 eV eV [i]);__ev_lower_fs_tst_eq(2009 eV eV [i]);__ev_upper_fs_tst_eq(2009 eV eV [i]);__ev_select_fs_tst_eq(2019 eV eV eV eV [eV])"	/>
	<inst name="evfststgt"
		ifunc="__ev_all_fs_tst_gt(2009 eV eV [i]);__ev_any_fs_tst_gt(2009 eV eV [i]);__ev_lower_fs_tst_gt(2009 eV eV [i]);__ev_upper_fs_tst_gt(2009 eV eV [i]);__ev_select_fs_tst_gt(2019 eV eV eV eV [eV])"	/>
	<inst name="evfststlt"
		ifunc="__ev_all_fs_tst_lt(2009 eV eV [i]);__ev_any_fs_tst_lt(2009 eV eV [i]);__ev_lower_fs_tst_lt(2009 eV eV [i]);__ev_upper_fs_tst_lt(2009 eV eV [i]);__ev_select_fs_tst_lt(2019 eV eV eV eV [eV])"	/>
    </inst>

    <!-- TODO I think volatile is a hack but it was in reorders tables -->
    <inst cost="POC.FLOATOP" export="EXPORT.SPE1" ic="IC.SU1" kind="K.VOLATILE|K.NO_CSE" traits="CH.PURE">
	<inst name="evmergehi"	   parse="PpcParseClass.EV64HI"	   pop="POP.EVMERGEHI"	itype="LT.T_3OP_EVHI"
		ifunc="__ev_mergehi(2003 eV eV [eV])"	/>
	<inst name="evmergehilo"   parse="PpcParseClass.EV64HILO"  pop="POP.EVMERGEHILO"	itype="LT.T_3OP_EVHILO" key="KEY.PPCEV_MRGHL"
		ifunc="__ev_mergehilo(2003 eV eV [eV]);__ev_set_lower_s32(2014 eV i [eV]);__ev_set_lower_sfix32_s32(2014 eV i [eV]);__ev_set_lower_ufix32_u32(2014 eV ui [eV]);__ev_set_lower_u32(2014 eV ui [eV])"
		size="8" flags="F.SZ_EIGHT" />
	<inst name="evmergelo"	   parse="PpcParseClass.EV64LO"	   pop="POP.EVMERGELO"	itype="LT.T_3OP_EVLO"
		ifunc="__ev_mergelo(2003 eV eV [eV]);__ev_set_upper_sfix32_s32(2015 eV i [eV]);__ev_set_upper_s32(2015 eV i [eV]);__ev_set_upper_ufix32_u32(2015 eV ui [eV]);__ev_set_upper_u32(2015 eV ui [eV])"	/>
	<inst name="evmergelohi"   parse="PpcParseClass.EV64LOHI"  pop="POP.EVMERGELOHI"	itype="LT.T_3OP_EVLOHI"
		ifunc="__ev_mergelohi(2003 eV eV [eV])"
		size="8" flags="F.SZ_EIGHT" />
    </inst>

    <inst parse="PpcParseClass.EV64BINARY" cost="POC.FLOATOP" export="EXPORT.SPE1" ic="IC.SU1" itype="LT.T_3OP_EV">
	<inst traits="CH.PURE">
	    <inst name="evaddiw"	itype="LT.T_2OP_CONST"	ifunc="__ev_addiw(2001 eV C31 [eV])"	/>
	    <inst name="evaddw"					ifunc="__ev_addw(0 eV eV [eV])"	/>
	    <inst name="evand"					ifunc="__ev_and(0 eV eV [eV])"	/>
	    <inst name="evandc"					ifunc="__ev_andc(0 eV eV [eV])"	/>
	    <inst name="evdivws"	ic="IC.MU3"		ifunc="__ev_divws(0 eV eV [eV])"	/>
	    <inst name="evdivwu"	ic="IC.MU3"		ifunc="__ev_divwu(0 eV eV [eV])"	/>
	    <inst name="eveqv"					ifunc="__ev_eqv(0 eV eV [eV])"	/>
	    <inst name="evfsadd"	ic="IC.MU"		ifunc="__ev_fsadd(2008 eV eV [eV])"	/>
	    <inst name="evfsdiv"	ic="IC.MU2"		ifunc="__ev_fsdiv(2008 eV eV [eV])"	/>
	    <inst name="evfsmul"	ic="IC.MU"		ifunc="__ev_fsmul(2008 eV eV [eV])"	/>
	    <inst name="evfssub"	ic="IC.MU"		ifunc="__ev_fssub(2008 eV eV [eV])"	/>
	</inst>
	<inst ic="IC.MU" itype="LT.T_3OP_EVACC">
	    <inst name="evmhegsmfaa" ref="acc" def="acc"	ifunc="__ev_mhegsmfaa(2003 eV eV [eV])"	/>
	    <inst name="evmhegsmfan" ref="acc" def="acc"	ifunc="__ev_mhegsmfan(2003 eV eV [eV])"	/>
	    <inst name="evmhegsmiaa" ref="acc" def="acc"	ifunc="__ev_mhegsmiaa(2003 eV eV [eV])"	/>
	    <inst name="evmhegsmian" ref="acc" def="acc"	ifunc="__ev_mhegsmian(2003 eV eV [eV])"	/>
	    <inst name="evmhegumiaa" ref="acc" def="acc"	ifunc="__ev_mhegumfaa(2003 eV eV [eV]);__ev_mhegumiaa(2003 eV eV [eV])"	/>
	    <inst name="evmhegumian" ref="acc" def="acc"	ifunc="__ev_mhegumfan(2003 eV eV [eV]);__ev_mhegumian(2003 eV eV [eV])"	/>
	    <inst name="evmhesmf"				ifunc="__ev_mhesmf(2003 eV eV [eV])"	/>
	    <inst name="evmhesmfa"		   def="acc"	ifunc="__ev_mhesmfa(2003 eV eV [eV])"	/>
	    <inst name="evmhesmfaaw" ref="acc" def="acc"	ifunc="__ev_mhesmfaaw(2003 eV eV [eV])"	/>
	    <inst name="evmhesmfanw" ref="acc" def="acc"	ifunc="__ev_mhesmfanw(2003 eV eV [eV])"	/>
	    <inst name="evmhesmi"				ifunc="__ev_mhesmi(2003 eV eV [eV])"	/>
	    <inst name="evmhesmia"		   def="acc"	ifunc="__ev_mhesmia(2003 eV eV [eV])"	/>
	    <inst name="evmhesmiaaw" ref="acc" def="acc"	ifunc="__ev_mhesmiaaw(2003 eV eV [eV])"	/>
	    <inst name="evmhesmianw" ref="acc" def="acc"	ifunc="__ev_mhesmianw(2003 eV eV [eV])"	/>
	    <inst name="evmhessf"				ifunc="__ev_mhessf(2003 eV eV [eV])"	/>
	    <inst name="evmhessfa"		   def="acc"	ifunc="__ev_mhessfa(2003 eV eV [eV])"	/>
	    <inst name="evmhessfaaw" ref="acc" def="acc"	ifunc="__ev_mhessfaaw(2003 eV eV [eV])"	/>
	    <inst name="evmhessfanw" ref="acc" def="acc"	ifunc="__ev_mhessfanw(2003 eV eV [eV])"	/>
	    <inst name="evmhessiaaw" ref="acc" def="acc"	ifunc="__ev_mhessiaaw(2003 eV eV [eV])"	/>
	    <inst name="evmhessianw" ref="acc" def="acc"	ifunc="__ev_mhessianw(2003 eV eV [eV])"	/>
	    <inst name="evmheumi"				ifunc="__ev_mheumf(2003 eV eV [eV]);__ev_mheumi(2003 eV eV [eV])"	/>
	    <inst name="evmheumia"		   def="acc"	ifunc="__ev_mheumfa(2003 eV eV [eV]);__ev_mheumia(2003 eV eV [eV])"	/>
	    <inst name="evmheumiaaw" ref="acc" def="acc"	ifunc="__ev_mheumfaaw(2003 eV eV [eV]);__ev_mheumiaaw(2003 eV eV [eV])"	/>
	    <inst name="evmheumianw" ref="acc" def="acc"	ifunc="__ev_mheumfanw(2003 eV eV [eV]);__ev_mheumianw(2003 eV eV [eV])"	/>
	    <inst name="evmheusiaaw" ref="acc" def="acc"	ifunc="__ev_mheusfaaw(2003 eV eV [eV]);__ev_mheusiaaw(2003 eV eV [eV])"	/>
	    <inst name="evmheusianw" ref="acc" def="acc"	ifunc="__ev_mheusfanw(2003 eV eV [eV]);__ev_mheusianw(2003 eV eV [eV])"	/>
	    <inst name="evmhogsmfaa" ref="acc" def="acc"	ifunc="__ev_mhogsmfaa(2003 eV eV [eV])"	/>
	    <inst name="evmhogsmfan" ref="acc" def="acc"	ifunc="__ev_mhogsmfan(2003 eV eV [eV])"	/>
	    <inst name="evmhogsmiaa" ref="acc" def="acc"	ifunc="__ev_mhogsmiaa(2003 eV eV [eV])"	/>
	    <inst name="evmhogsmian" ref="acc" def="acc"	ifunc="__ev_mhogsmian(2003 eV eV [eV])"	/>
	    <inst name="evmhogumiaa" ref="acc" def="acc"	ifunc="__ev_mhogumfaa(2003 eV eV [eV]);__ev_mhogumiaa(2003 eV eV [eV])"	/>
	    <inst name="evmhogumian" ref="acc" def="acc"	ifunc="__ev_mhogumfan(2003 eV eV [eV]);__ev_mhogumian(2003 eV eV [eV])"	/>
	    <inst name="evmhosmf"				ifunc="__ev_mhosmf(2003 eV eV [eV])"	/>
	    <inst name="evmhosmfa"		   def="acc"	ifunc="__ev_mhosmfa(2003 eV eV [eV])"	/>
	    <inst name="evmhosmfaaw" ref="acc" def="acc"	ifunc="__ev_mhosmfaaw(2003 eV eV [eV])"	/>
	    <inst name="evmhosmfanw" ref="acc" def="acc"	ifunc="__ev_mhosmfanw(2003 eV eV [eV])"	/>
	    <inst name="evmhosmi"				ifunc="__ev_mhosmi(2003 eV eV [eV])"	/>
	    <inst name="evmhosmia"		   def="acc"	ifunc="__ev_mhosmia(2003 eV eV [eV])"	/>
	    <inst name="evmhosmiaaw" ref="acc" def="acc"	ifunc="__ev_mhosmiaaw(2003 eV eV [eV])"	/>
	    <inst name="evmhosmianw" ref="acc" def="acc"	ifunc="__ev_mhosmianw(2003 eV eV [eV])"	/>
	    <inst name="evmhossf"				ifunc="__ev_mhossf(2003 eV eV [eV])"	/>
	    <inst name="evmhossfa"		   def="acc"	ifunc="__ev_mhossfa(2003 eV eV [eV])"	/>
	    <inst name="evmhossfaaw" ref="acc" def="acc"	ifunc="__ev_mhossfaaw(2003 eV eV [eV])"	/>
	    <inst name="evmhossfanw" ref="acc" def="acc"	ifunc="__ev_mhossfanw(2003 eV eV [eV])"	/>
	    <inst name="evmhossiaaw" ref="acc" def="acc"	ifunc="__ev_mhossiaaw(2003 eV eV [eV])"	/>
	    <inst name="evmhossianw" ref="acc" def="acc"	ifunc="__ev_mhossianw(2003 eV eV [eV])"	/>
	    <inst name="evmhoumi"
	    	ifunc="__ev_mhoumf(2003 eV eV [eV]);__ev_mhoumi(2003 eV eV [eV])"	/>
	    <inst name="evmhoumia"		   def="acc"
	    	ifunc="__ev_mhoumfa(2003 eV eV [eV]);__ev_mhoumia(2003 eV eV [eV])"	/>
	    <inst name="evmhoumiaaw" ref="acc" def="acc"
	    	ifunc="__ev_mhoumfaaw(2003 eV eV [eV]);__ev_mhoumiaaw(2003 eV eV [eV])"	/>
	    <inst name="evmhoumianw" ref="acc" def="acc"
	    	ifunc="__ev_mhoumfanw(2003 eV eV [eV]);__ev_mhoumianw(2003 eV eV [eV])"	/>
	    <inst name="evmhousiaaw" ref="acc" def="acc"
	    	ifunc="__ev_mhousfaaw(2003 eV eV [eV]);__ev_mhousiaaw(2003 eV eV [eV])"	/>
	    <inst name="evmhousianw" ref="acc" def="acc"
	    	ifunc="__ev_mhousfanw(2003 eV eV [eV]);__ev_mhousianw(2003 eV eV [eV])"	/>
	    <inst name="evmwhsmf"
	    	ifunc="__ev_mwhsmf(2003 eV eV [eV]);__ev_mwhsmfaaw?__SPE2__(2033 eV eV [eV]);__ev_mwhsmfanw?__SPE2__(2042 eV eV [eV]);__ev_mwhgsmfaa(2038 eV eV [eV]);__ev_mwhgsmfan(2039 eV eV [eV])"	/>
	    <inst name="evmwhsmfa"		   def="acc"	ifunc="__ev_mwhsmfa(2003 eV eV [eV])"	/>
	    <inst name="evmwhsmi"
		ifunc="__ev_mwhsmi(2003 eV eV [eV]);__ev_mwhssiaaw(2033 eV eV [eV]);__ev_mwhsmiaaw(2033 eV eV [eV]);__ev_mwhssianw(2034 eV eV [eV]);__ev_mwhsmianw(2042 eV eV [eV]);__ev_mwhgsmiaa(2038 eV eV [eV]);__ev_mwhgsmian(2039 eV eV [eV])"	/>
	    <inst name="evmwhsmia"		   def="acc"	ifunc="__ev_mwhsmia(2003 eV eV [eV])"	/>
	    <inst name="evmwhssf"
	    	ifunc="__ev_mwhssf(2003 eV eV [eV]);__ev_mwhssfaaw?__SPE2__(2033 eV eV [eV]);__ev_mwhssfanw?__SPE2__(2034 eV eV [eV]);__ev_mwhgssfaa(2038 eV eV [eV]);__ev_mwhgssfan(2039 eV eV [eV])"	/>
	    <inst name="evmwhssfa"		   def="acc"	ifunc="__ev_mwhssfa(2003 eV eV [eV])"	/>
	    <inst name="evmwhumi"
	    	ifunc="__ev_mwhumf(2003 eV eV [eV]);__ev_mwhumi(2003 eV eV [eV])"	/>
	    <inst name="evmwhumia"		   def="acc"
	    	ifunc="__ev_mwhumfa(2003 eV eV [eV]);__ev_mwhumia(2003 eV eV [eV])"	/>
	    <inst name="evmwlsmiaaw" ref="acc" def="acc"	ifunc="__ev_mwlsmiaaw(2003 eV eV [eV])"	/>
	    <inst name="evmwlsmianw" ref="acc" def="acc"	ifunc="__ev_mwlsmianw(2003 eV eV [eV])"	/>
	    <inst name="evmwlssiaaw" ref="acc" def="acc"	ifunc="__ev_mwlssiaaw(2003 eV eV [eV])"	/>
	    <inst name="evmwlssianw" ref="acc" def="acc"	ifunc="__ev_mwlssianw(2003 eV eV [eV])"	/>
	    <inst name="evmwlumi"				ifunc="__ev_mwlumi(2003 eV eV [eV])"	/>
	    <inst name="evmwlumia"		   def="acc"	ifunc="__ev_mwlumia(2003 eV eV [eV])"	/>
	    <inst name="evmwlumiaaw" ref="acc" def="acc"	ifunc="__ev_mwlumiaaw(2003 eV eV [eV])"	/>
	    <inst name="evmwlumianw" ref="acc" def="acc"	ifunc="__ev_mwlumianw(2003 eV eV [eV])"	/>
	    <inst name="evmwlusiaaw" ref="acc" def="acc"	ifunc="__ev_mwlusiaaw(2003 eV eV [eV])"	/>
	    <inst name="evmwlusianw" ref="acc" def="acc"	ifunc="__ev_mwlusianw(2003 eV eV [eV])"	/>
	    <inst name="evmwsmf"	traits="CH.PURE"	ifunc="__ev_mwsmf(0 eV eV [eV])"	/>
	    <inst name="evmwsmfa"		   def="acc"	ifunc="__ev_mwsmfa(2003 eV eV [eV])"	/>
	    <inst name="evmwsmfaa"	 ref="acc" def="acc"	ifunc="__ev_mwsmfaa(2003 eV eV [eV])"	/>
	    <inst name="evmwsmfan"	 ref="acc" def="acc"	ifunc="__ev_mwsmfan(2003 eV eV [eV])"	/>
	    <inst name="evmwsmi"	traits="CH.PURE"	ifunc="__ev_mwsmi(0 eV eV [eV])"	/>
	    <inst name="evmwsmia"		   def="acc"	ifunc="__ev_mwsmia(2003 eV eV [eV])"	/>
	    <inst name="evmwsmiaa"	 ref="acc" def="acc"	ifunc="__ev_mwsmiaa(2003 eV eV [eV])"	/>
	    <inst name="evmwsmian"	 ref="acc" def="acc"	ifunc="__ev_mwsmian(2003 eV eV [eV])"	/>
	    <inst name="evmwssf"	traits="CH.PURE"	ifunc="__ev_mwssf(0 eV eV [eV])"	/>
	    <inst name="evmwssfa"		   def="acc"	ifunc="__ev_mwssfa(2003 eV eV [eV])"	/>
	    <inst name="evmwssfaa"	 ref="acc" def="acc"	ifunc="__ev_mwssfaa(2003 eV eV [eV])"	/>
	    <inst name="evmwssfan"	 ref="acc" def="acc"	ifunc="__ev_mwssfan(2003 eV eV [eV])"	/>
	    <inst name="evmwumi"	traits="CH.PURE"
	    	ifunc="__ev_mwumf(0 eV eV [eV]);__ev_mwumi(0 eV eV [eV])"	/>
	    <inst name="evmwumia"		   def="acc"
	    	ifunc="__ev_mwumfa(2003 eV eV [eV]);__ev_mwumia(2003 eV eV [eV])"	/>
	    <inst name="evmwumiaa"	 ref="acc" def="acc"
	    	ifunc="__ev_mwumfaa(2003 eV eV [eV]);__ev_mwumiaa(2003 eV eV [eV]);__ev_mwhgumfaa(2040 eV eV [eV]);__ev_mwhgumiaa(2040 eV eV [eV])"	/>
	    <inst name="evmwumian"	 ref="acc" def="acc"
		ifunc="__ev_mwumfan(2003 eV eV [eV]);__ev_mwumian(2003 eV eV [eV]);__ev_mwhgumfan(2040 eV eV [eV]);__ev_mwhgumian(2040 eV eV [eV])"	/>
	</inst>
	<inst traits="CH.PURE">
	    <inst name="evnand"				ifunc="__ev_nand(0 eV eV [eV])"	/>
	    <inst name="evnor"				ifunc="__ev_nor(0 eV eV [eV])"	/>
	    <inst name="evor"				ifunc="__ev_or(0 eV eV [eV])"	/>
	    <inst name="evorc"				ifunc="__ev_orc(0 eV eV [eV])"	/>
	    <inst name="evrlw"				ifunc="__ev_rlw(0 eV eV [eV])"	/>
	    <inst name="evslw"				ifunc="__ev_slw(0 eV eV [eV])"	/>
    	    <inst ic="IC.SU1" itype="LT.T_2OP_CONST">
		<inst name="evrlwi"			ifunc="__ev_rlwi(2001 eV C31 [eV])"	/>
		<inst name="evslwi"			ifunc="__ev_slwi(2001 eV C31 [eV])"	/>
		<inst name="evsrwis"			ifunc="__ev_srwis(2001 eV C31 [eV])"	/>
		<inst name="evsrwiu"			ifunc="__ev_srwiu(2001 eV C31 [eV])"	/>
    	    </inst>
	    <inst name="evsrws"				ifunc="__ev_srws(0 eV eV [eV])"	/>
	    <inst name="evsrwu"				ifunc="__ev_srwu(0 eV eV [eV])"	/>
	    <inst kind="K.NO_CSE" itype="LT.T_2OPC">
		<inst name="evsubifw"	   def="acc"	ifunc="__ev_subiw(2061 eV C31 [eV]);__ev_subifw(2059 C31 eV [eV])" />
    	    </inst>
	    <inst name="evsubfw"			ifunc="__ev_subw(2060 eV eV [eV]);__ev_subfw(2008 eV eV [eV])"	/>
	    <inst name="evxor"				ifunc="__ev_xor(0 eV eV [eV])"	/>
	</inst>
    </inst>

    <inst cost="POC.MEM" flags="F.LD|F.R0IS0" parse="PpcParseClass.EV64UNARY2" pop="POP.LOADD" export="EXPORT.SPE1" ic="IC.LD" itype="LT.T_2OPC" key="KEY.PPCEV_LOAD" traits="CH.PURE" tflag="PTF.NOREMAT">
    	<inst tflag="PTF.EV64BY8" size="8" flags="F.SZ_EIGHT">
	    <inst name="evldd"	   			ifunc="__ev_ldd(2053 eVP C31 [eV])"	/>
	    <inst name="evldh"	   			ifunc="__ev_ldh(2053 eVP C31 [eV])"	/>
	    <inst name="evldw"	   			ifunc="__ev_ldw(2053 eVP C31 [eV])"	/>
    	</inst>
	<inst tflag="PTF.EV64BY2" kind="K.NO_CSE" size="2" flags="F.SZ_TWO">
	    <inst name="evlhhesplat"   			ifunc="__ev_lhhesplat(2053 uhP C31 [eV])"	/>
	    <inst name="evlhhossplat"  			ifunc="__ev_lhhossplat(2053 uhP C31 [eV])"	/>
	    <inst name="evlhhousplat"  			ifunc="__ev_lhhousplat(2053 uhP C31 [eV])"	/>
    	</inst>
	<inst tflag="PTF.EV64BY4" kind="K.NO_CSE" size="4" flags="F.SZ_FOUR">
	    <inst name="evlwhe"	   			ifunc="__ev_lwhe(2053 uiP C31 [eV])"	/>
	    <inst name="evlwhos"	   		ifunc="__ev_lwhos(2053 uiP C31 [eV])"	/>
	    <inst name="evlwhou"	   		ifunc="__ev_lwhou(2053 uiP C31 [eV])"	/>
	    <inst name="evlwhsplat"			ifunc="__ev_lwhsplat(2053 uiP C31 [eV])"	/>
	    <inst name="evlwwsplat"			ifunc="__ev_lwwsplat(2053 uiP C31 [eV])"	/>
	</inst>
    </inst>

    <inst cost="POC.MEM" flags="F.LD|F.R0IS0" parse="PpcParseClass.EV64BINARY2" pop="POP.LOADD" export="EXPORT.SPE1" ic="IC.LD" itype="LT.T_3OP_EV" key="KEY.PPCEV_LOAD" traits="CH.PURE" tflag="PTF.NOREMAT">
	<inst size="8" flags="F.SZ_EIGHT">
	    <inst name="evlddepx"			ifunc="__ev_lddepx(2008 eVP i [eV])"	kind="K.VOLATILE" />
	    <inst name="evlddx"	   			ifunc="__ev_lddx(2008 eVP i [eV])"	/>
	    <inst name="evldhx"	   			ifunc="__ev_ldhx(2008 eVP i [eV])"	/>
	    <inst name="evldwx"	   			ifunc="__ev_ldwx(2008 eVP i [eV])"	/>
	</inst>
	<inst kind="K.NO_CSE" size="2" flags="F.SZ_TWO">
	    <inst name="evlhhesplatx"  			ifunc="__ev_lhhesplatx(2003 uhP i [eV])"	/>
	    <inst name="evlhhossplatx" 			ifunc="__ev_lhhossplatx(2003 uhP i [eV])"	/>
	    <inst name="evlhhousplatx" 			ifunc="__ev_lhhousplatx(2003 uhP i [eV])"	/>
	</inst>
	<inst kind="K.NO_CSE" size="4" flags="F.SZ_FOUR">
	    <inst name="evlwhex"			ifunc="__ev_lwhex(2008 uiP i [eV])"	/>
	    <inst name="evlwhosx"			ifunc="__ev_lwhosx(2003 uiP i [eV])"	/>
	    <inst name="evlwhoux"			ifunc="__ev_lwhoux(2003 uiP i [eV])"	/>
	    <inst name="evlwhsplatx"   			ifunc="__ev_lwhsplatx(2003 uiP i [eV])"	/>
	    <inst name="evlwwsplatx"			ifunc="__ev_lwwsplatx(2003 uiP i [eV])"	/>
    	</inst>
    </inst>

    <inst parse="PpcParseClass.EV64STORE" cost="POC.MEM" flags="F.ST|F.R0IS0" export="EXPORT.SPE1" ic="IC.ST" itype="LT.T_U_TWO_C" key="KEY.PPCEV_STORE" tflag="PTF.NOREMAT">
	<inst size="8" flags="F.SZ_EIGHT" tflag="PTF.EV64BY8">
	    <inst name="evstdd" 			ifunc="__ev_stdd(2025 eV eVP C31 [V])"	/>
	    <inst name="evstdh"				ifunc="__ev_stdh(2025 eV eVP C31 [V])"	/>
	    <inst name="evstdw"				ifunc="__ev_stdw(2025 eV eVP C31 [V])"	/>
	</inst>
	<inst size="4" flags="F.SZ_FOUR" tflag="PTF.EV64BY4">
	    <inst name="evstwhe"			ifunc="__ev_stwhe(2025 eV uiP C31 [V])"	/>
	    <inst name="evstwho"			ifunc="__ev_stwho(2025 eV uiP C31 [V])"	/>
	    <inst name="evstwwe"			ifunc="__ev_stwwe(2025 eV uiP C31 [V])"	/>
	    <inst name="evstwwo"			ifunc="__ev_stwwo(2025 eV uiP C31 [V])"	/>
    	</inst>
    </inst>

    <inst parse="PpcParseClass.EV64STORE" cost="POC.MEM" flags="F.ST|F.R0IS0" export="EXPORT.SPE1" ic="IC.ST" itype="LT.T_U_THREE" key="KEY.PPCEV_STORE" tflag="PTF.NOREMAT">
	<inst size="8" flags="F.SZ_EIGHT">
	    <inst name="evstddepx"			ifunc="__ev_stddepx(2026 eV eVP i [V])"	kind="K.VOLATILE" />
	    <inst name="evstddx"			ifunc="__ev_stddx(2026 eV eVP i [V])"	/>
	    <inst name="evstdhx"			ifunc="__ev_stdhx(2026 eV eVP i [V])"	/>
	    <inst name="evstdwx"			ifunc="__ev_stdwx(2026 eV eVP i [V])"	/>
	</inst>
	<inst size="4" flags="F.SZ_FOUR">
	    <inst name="evstwhex"			ifunc="__ev_stwhex(2026 eV uiP i [V])"	/>
	    <inst name="evstwhox"			ifunc="__ev_stwhox(2026 eV uiP i [V])"	/>
	    <inst name="evstwwex"			ifunc="__ev_stwwex(2026 eV uiP i [V])"	/>
	    <inst name="evstwwox"			ifunc="__ev_stwwox(2026 eV uiP i [V])"	/>
	</inst>
    </inst>

    <inst parse="PpcParseClass.EV64DST" cost="POC.FLOATOP" export="EXPORT.SPE2" ic="IC.SU1" itype="LT.T_D_ONE" traits="CH.PURE">
	<inst name="evmar"	ref="acc"		ifunc="__ev_mar(2083 V [eV])"	/>
    </inst>

    <inst parse="PpcParseClass.EV64UNARY" cost="POC.FLOATOP" export="EXPORT.SPE2" ic="IC.SU1" itype="LT.T_2OP_EVACC">
	<inst traits="CH.PURE">
	    <inst name="evabsb"				ifunc="__ev_absb(0 eV [eV])"	/>
	    <inst name="evabsbs"			ifunc="__ev_absbs(0 eV [eV])"	/>
	    <inst name="evabsh"				ifunc="__ev_absh(0 eV [eV])"	/>
	    <inst name="evabshs"			ifunc="__ev_abshs(0 eV [eV])"	/>
	    <inst name="evabss"				ifunc="__ev_abss(0 eV [eV])"	/>
	</inst>
	<inst name="evaddaa"	ref="acc" def="acc"	ifunc="__ev_addaa(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evaddssiaa"	ref="acc" def="acc"	ifunc="__ev_addssiaa(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evaddusiaa"	ref="acc" def="acc"	ifunc="__ev_addusiaa(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst traits="CH.PURE">
	    <inst name="evnegb"				ifunc="__ev_negb(0 eV [eV])"	/>
	    <inst name="evnegh"				ifunc="__ev_negh(0 eV [eV])"	/>
	    <inst name="evnegs"				ifunc="__ev_negs(0 eV [eV])"	/>
	    <inst name="evnegbs"			ifunc="__ev_negbs(0 eV [eV])"	/>
	    <inst name="evneghs"			ifunc="__ev_neghs(0 eV [eV])"	/>
	    <inst name="evextzb"			ifunc="__ev_extzb(0 eV [eV])"	/>
	    <inst name="evextsbh"			ifunc="__ev_extsbh(0 eV [eV])"	/>
	    <inst name="evextsw"			ifunc="__ev_extsw(0 eV [eV])"	/>
	    <inst name="evrndh"				ifunc="__ev_rndh(0 eV [eV])"	/>
	    <inst name="evrndwus"			ifunc="__ev_rndwus(0 eV [eV])"	/>
	    <inst name="evrndwss"			ifunc="__ev_rndwss(0 eV [eV])"	/>
	    <inst name="evrndhus"			ifunc="__ev_rndhus(0 eV [eV])"	/>
	    <inst name="evrndhss"			ifunc="__ev_rndhss(0 eV [eV])"	/>
	    <inst name="evcntlzh"			ifunc="__ev_cntlzh(0 eV [eV])"	/>
	    <inst name="evcntlsh"			ifunc="__ev_cntlsh(0 eV [eV])"	/>
	    <inst name="evpopcntb"			ifunc="__ev_popcntb(0 eV [eV])"	/>
	    <inst name="evmaxbpsh"			ifunc="__ev_maxbpsh(0 eV [eV])"	/>
	    <inst name="evmaxbpuh"			ifunc="__ev_maxbpuh(0 eV [eV])"	/>
	    <inst name="evmaxhpsw"			ifunc="__ev_maxhpsw(0 eV [eV])"	/>
	    <inst name="evmaxhpuw"			ifunc="__ev_maxhpuw(0 eV [eV])"	/>
	    <inst name="evmaxwpsd"			ifunc="__ev_maxwpsd(0 eV [eV])"	/>
	    <inst name="evmaxwpud"			ifunc="__ev_maxwpud(0 eV [eV])"	/>
	    <inst name="evminbpsh"			ifunc="__ev_minbpsh(0 eV [eV])"	/>
	    <inst name="evminbpuh"			ifunc="__ev_minbpuh(0 eV [eV])"	/>
	    <inst name="evminhpsw"			ifunc="__ev_minhpsw(0 eV [eV])"	/>
	    <inst name="evminhpuw"			ifunc="__ev_minhpuw(0 eV [eV])"	/>
	    <inst name="evminwpsd"			ifunc="__ev_minwpsd(0 eV [eV])"	/>
	    <inst name="evminwpud"			ifunc="__ev_minwpud(0 eV [eV])"	/>
	    <inst name="evsatsbub"			ifunc="__ev_satsbub(0 eV [eV])"	/>
	    <inst name="evsatsdsw"			ifunc="__ev_satsdsw(0 eV [eV])"	/>
	    <inst name="evsatsduw"			ifunc="__ev_satsduw(0 eV [eV])"	/>
	    <inst name="evsatshsb"			ifunc="__ev_satshsb(0 eV [eV])"	/>
	    <inst name="evsatshub"			ifunc="__ev_satshub(0 eV [eV])"	/>
	    <inst name="evsatshuh"			ifunc="__ev_satshuh(0 eV [eV])"	/>
	    <inst name="evsatswsh"			ifunc="__ev_satswsh(0 eV [eV])"	/>
	    <inst name="evsatswuh"			ifunc="__ev_satswuh(0 eV [eV])"	/>
	    <inst name="evsatswuw"			ifunc="__ev_satswuw(0 eV [eV])"	/>
	    <inst name="evsatubsb"			ifunc="__ev_satubsb(0 eV [eV])"	/>
	    <inst name="evsatuduw"			ifunc="__ev_satuduw(0 eV [eV])"	/>
	    <inst name="evsatuhsh"			ifunc="__ev_satuhsh(0 eV [eV])"	/>
	    <inst name="evsatuhub"			ifunc="__ev_satuhub(0 eV [eV])"	/>
	    <inst name="evsatuwsw"			ifunc="__ev_satuwsw(0 eV [eV])"	/>
	    <inst name="evsatuwuh"			ifunc="__ev_satuwuh(0 eV [eV])"	/>
	</inst>
	<inst name="evsubfaa"	    ref="acc" def="acc"	ifunc="__ev_subfaa(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsubfssiaa"    ref="acc" def="acc"	ifunc="__ev_subfssiaa(2000 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsubfusiaa"    ref="acc" def="acc"	ifunc="__ev_subfusiaa(2000 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsum2his"	    traits="CH.PURE"	ifunc="__ev_sum2his(0 eV [eV])"	/>
	<inst name="evsum2hisa"	    def="acc"		ifunc="__ev_sum2hisa(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsum2hisaaw"   ref="acc" def="acc"	ifunc="__ev_sum2hisaaw(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsum2hiu"	    traits="CH.PURE"	ifunc="__ev_sum2hiu(0 eV [eV])"	/>
	<inst name="evsum2hiua"	    def="acc"		ifunc="__ev_sum2hiua(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsum2hiuaaw"   ref="acc" def="acc"	ifunc="__ev_sum2hiuaaw(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsum2hs"	    traits="CH.PURE"	ifunc="__ev_sum2hs(0 eV [eV])"	/>
	<inst name="evsum2hsa"	    def="acc"		ifunc="__ev_sum2hsa(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsum2hsaaw"    ref="acc" def="acc"	ifunc="__ev_sum2hsaaw(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsum2hu"	    traits="CH.PURE"	ifunc="__ev_sum2hu(0 eV [eV])"	/>
	<inst name="evsum2hua"	    def="acc"		ifunc="__ev_sum2hua(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsum2huaaw"    ref="acc" def="acc"	ifunc="__ev_sum2huaaw(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsum4bs"	    traits="CH.PURE"	ifunc="__ev_sum4bs(0 eV [eV])"	/>
	<inst name="evsum4bsa"	    def="acc"		ifunc="__ev_sum4bsa(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsum4bsaaw"    ref="acc" def="acc"	ifunc="__ev_sum4bsaaw(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsum4bu"	    traits="CH.PURE"	ifunc="__ev_sum4bu(0 eV [eV])"	/>
	<inst name="evsum4bua"	    def="acc"		ifunc="__ev_sum4bua(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsum4buaaw"    ref="acc" def="acc"	ifunc="__ev_sum4buaaw(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsumws"	    traits="CH.PURE"	ifunc="__ev_sumws(0 eV [eV])"	/>
	<inst name="evsumwsa"	    def="acc"		ifunc="__ev_sumwsa(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsumwsaa"	    ref="acc" def="acc"	ifunc="__ev_sumwsaa(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsumwu"	    traits="CH.PURE"	ifunc="__ev_sumwu(0 eV [eV])"	/>
	<inst name="evsumwua"	    def="acc"		ifunc="__ev_sumwua(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsumwuaa"	    ref="acc" def="acc"	ifunc="__ev_sumwuaa(2000 eV [eV])"	kind="K.NO_CSE"	/>
	<inst traits="CH.PURE">
	    <inst name="evunpkhibsi"			ifunc="__ev_unpkhibsi(0 eV [eV])"	/>
	    <inst name="evunpkhibui"			ifunc="__ev_unpkhibui(0 eV [eV])"	/>
	    <inst name="evunpkhihf"			ifunc="__ev_unpkhihf(0 eV [eV])"	/>
	    <inst name="evunpkhihsi"			ifunc="__ev_unpkhihsi(0 eV [eV])"	/>
	    <inst name="evunpkhihui"			ifunc="__ev_unpkhihui(0 eV [eV])"	/>
	    <inst name="evunpklobsi"			ifunc="__ev_unpklobsi(0 eV [eV])"	/>
	    <inst name="evunpklobui"			ifunc="__ev_unpklobui(0 eV [eV])"	/>
	    <inst name="evunpklohf"			ifunc="__ev_unpklohf(0 eV [eV])"	/>
	    <inst name="evunpklohsi"			ifunc="__ev_unpklohsi(0 eV [eV])"	/>
	    <inst name="evunpklohui"			ifunc="__ev_unpklohui(0 eV [eV])"	/>
	</inst>
    </inst>

    <inst parse="PpcParseClass.EV64BDBSIMM" cost="POC.FLOATOP" export="EXPORT.SPE2" ic="IC.SU1" itype="LT.T_2OP_CONST" traits="CH.PURE">
	<inst name="evsli"				ifunc="__ev_sli(2001 eV C32 [eV])"	/>
	<inst name="evsrbiu"				ifunc="__ev_srbiu(2001 eV C32 [eV])"	/>
	<inst name="evsrbis"				ifunc="__ev_srbis(2001 eV C32 [eV])"	/>
	<inst name="evslbi"				ifunc="__ev_slbi(2001 eV C32 [eV])"	/>
	<inst name="evrlbi"				ifunc="__ev_rlbi(2001 eV C32 [eV])"	/>
	<inst name="evsrhiu"				ifunc="__ev_srhiu(2001 eV C32 [eV])"	/>
	<inst name="evsrhis"				ifunc="__ev_srhis(2001 eV C32 [eV])"	/>
	<inst name="evslhi"				ifunc="__ev_slhi(2001 eV C32 [eV])"	/>
	<inst name="evrlhi"				ifunc="__ev_rlhi(2001 eV C32 [eV])"	/>
	<inst name="evsriu"				ifunc="__ev_sriu(2001 eV C32 [eV])"	/>
	<inst name="evsris"				ifunc="__ev_sris(2001 eV C32 [eV])"	/>
    </inst>

    <inst parse="PpcParseClass.EV64BINARY" cost="POC.FLOATOP" export="EXPORT.SPE2" ic="IC.SU1" itype="LT.T_3OP_EV">
	<inst traits="CH.PURE">
	    <inst name="evabsdifsb"			ifunc="__ev_absdifsb(0 eV eV [eV])"	/>
	    <inst name="evabsdifsh"			ifunc="__ev_absdifsh(0 eV eV [eV])"	/>
	    <inst name="evabsdifsw"			ifunc="__ev_absdifsw(0 eV eV [eV])"	/>
	    <inst name="evabsdifub"			ifunc="__ev_absdifub(0 eV eV [eV])"	/>
	    <inst name="evabsdifuh"			ifunc="__ev_absdifuh(0 eV eV [eV])"	/>
	    <inst name="evabsdifuw"			ifunc="__ev_absdifuw(0 eV eV [eV])"	/>
	    <inst name="evadd2subf2h"			ifunc="__ev_add2subf2h(0 eV eV [eV])"	/>
	    <inst name="evadd2subf2hss"			ifunc="__ev_add2subf2hss(0 eV eV [eV])"	/>
	    <inst name="evadd2subf2hus"			ifunc="__ev_add2subf2hus(0 eV eV [eV])"	/>
	    <inst name="evaddb"				ifunc="__ev_addb(0 eV eV [eV])"	/>
	    <inst name="evaddbss"			ifunc="__ev_addbss(0 eV eV [eV])"	/>
	    <inst name="evaddbus"			ifunc="__ev_addbus(0 eV eV [eV])"	/>
	    <inst name="evaddh"				ifunc="__ev_addh(0 eV eV [eV])"	/>
	    <inst name="evaddhss"			ifunc="__ev_addhss(0 eV eV [eV])"	/>
	    <inst name="evaddhus"			ifunc="__ev_addhus(0 eV eV [eV])"	/>
	    <inst name="evaddhx"			ifunc="__ev_addhx(0 eV eV [eV])"	/>
	    <inst name="evaddhxss"			ifunc="__ev_addhxss(0 eV eV [eV])"	/>
	    <inst name="evaddhxus"			ifunc="__ev_addhxus(0 eV eV [eV])"	/>
	    <inst name="evaddsubfh"			ifunc="__ev_addsubfh(0 eV eV [eV])"	/>
	    <inst name="evaddsubfhss"			ifunc="__ev_addsubfhss(0 eV eV [eV])"	/>
	    <inst name="evaddsubfhus"			ifunc="__ev_addsubfhus(0 eV eV [eV])"	/>
	    <inst name="evaddsubfhx"			ifunc="__ev_addsubfhx(0 eV eV [eV])"	/>
	    <inst name="evaddsubfhxss"			ifunc="__ev_addsubfhxss(0 eV eV [eV])"	/>
	    <inst name="evaddsubfhxus"			ifunc="__ev_addsubfhxus(0 eV eV [eV])"	/>
	    <inst name="evaddsubfw"			ifunc="__ev_addsubfw(0 eV eV [eV])"	/>
	    <inst name="evaddsubfwss"			ifunc="__ev_addsubfwss(0 eV eV [eV])"	/>
	    <inst name="evaddsubfwus"			ifunc="__ev_addsubfwus(0 eV eV [eV])"	/>
	    <inst name="evaddsubfwx"			ifunc="__ev_addsubfwx(0 eV eV [eV])"	/>
	    <inst name="evaddsubfwxss"			ifunc="__ev_addsubfwxss(0 eV eV [eV])"	/>
	    <inst name="evaddsubfwxus"			ifunc="__ev_addsubfwxus(0 eV eV [eV])"	/>
	    <inst name="evaddwss"			ifunc="__ev_addwss(0 eV eV [eV])"	/>
	    <inst name="evaddwus"			ifunc="__ev_addwus(0 eV eV [eV])"	/>
	    <inst name="evaddwx"			ifunc="__ev_addwx(0 eV eV [eV])"	/>
	    <inst name="evaddwxss"			ifunc="__ev_addwxss(0 eV eV [eV])"	/>
	    <inst name="evaddwxus"			ifunc="__ev_addwxus(0 eV eV [eV])"	/>
	    <inst name="evavgbs"			ifunc="__ev_avgbs(0 eV eV [eV])"	/>
	    <inst name="evavgbsr"			ifunc="__ev_avgbsr(0 eV eV [eV])"	/>
	    <inst name="evavgbu"			ifunc="__ev_avgbu(0 eV eV [eV])"	/>
	    <inst name="evavgbur"			ifunc="__ev_avgbur(0 eV eV [eV])"	/>
	    <inst name="evavghs"			ifunc="__ev_avghs(0 eV eV [eV])"	/>
	    <inst name="evavghsr"			ifunc="__ev_avghsr(0 eV eV [eV])"	/>
	    <inst name="evavghu"			ifunc="__ev_avghu(0 eV eV [eV])"	/>
	    <inst name="evavghur"			ifunc="__ev_avghur(0 eV eV [eV])"	/>
	    <inst name="evavgws"			ifunc="__ev_avgws(0 eV eV [eV])"	/>
	    <inst name="evavgwsr"			ifunc="__ev_avgwsr(0 eV eV [eV])"	/>
	    <inst name="evavgwu"			ifunc="__ev_avgwu(0 eV eV [eV])"	/>
	    <inst name="evavgwur"			ifunc="__ev_avgwur(0 eV eV [eV])"	/>
	    <inst name="evdivs"				ifunc="__ev_divs(0 eV eV [eV])"	/>
	    <inst name="evdivu"				ifunc="__ev_divu(0 eV eV [eV])"	/>
	    <inst name="evdivwsf"			ifunc="__ev_divwsf(0 eV eV [eV])"	/>
	    <inst name="evdivwuf"			ifunc="__ev_divwuf(0 eV eV [eV])"	/>
	    <inst name="evdlveb"			ifunc="__ev_dlveb(0 eV eV [eV])"	/>
	    <inst name="evdlveh"			ifunc="__ev_dlveh(0 eV eV [eV])"	/>
	    <inst name="evdlveob"			ifunc="__ev_dlveob(0 eV eV [eV])"	/>
	    <inst name="evdlveoh"			ifunc="__ev_dlveoh(0 eV eV [eV])"	/>
	    <inst name="evdlvob"			ifunc="__ev_dlvob(0 eV eV [eV])"	/>
	    <inst name="evdlvoeb"			ifunc="__ev_dlvoeb(0 eV eV [eV])"	/>
	    <inst name="evdlvoeh"			ifunc="__ev_dlvoeh(0 eV eV [eV])"	/>
	    <inst name="evdlvoh"			ifunc="__ev_dlvoh(0 eV eV [eV])"	/>
	</inst>
	<inst name="evdotp4hasmfaalw"	ref="acc" def="acc"	ifunc="__ev_dotp4hasmfaalw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hasmfaauw"	ref="acc" def="acc"	ifunc="__ev_dotp4hasmfaauw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hasmflwa"	def="acc"		ifunc="__ev_dotp4hasmflwa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hasmflw"	traits="CH.PURE"	ifunc="__ev_dotp4hasmflw(0 eV eV [eV])"	/>
	<inst name="evdotp4hasmfuwa"	def="acc"		ifunc="__ev_dotp4hasmfuwa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hasmfuw"	traits="CH.PURE"	ifunc="__ev_dotp4hasmfuw(0 eV eV [eV])"	/>
	<inst name="evdotp4hasmiaalw"	ref="acc" def="acc"	ifunc="__ev_dotp4hasmiaalw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hasmiaauw"	ref="acc" def="acc"	ifunc="__ev_dotp4hasmiaauw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hasmilwa"	def="acc"		ifunc="__ev_dotp4hasmilwa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hasmilw"	traits="CH.PURE"	ifunc="__ev_dotp4hasmilw(0 eV eV [eV])"	/>
	<inst name="evdotp4hasmiuwa"	def="acc"		ifunc="__ev_dotp4hasmiuwa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hasmiuw"	traits="CH.PURE"	ifunc="__ev_dotp4hasmiuw(0 eV eV [eV])"	/>
	<inst name="evdotp4hassfaalw"	ref="acc" def="acc"	ifunc="__ev_dotp4hassfaalw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hassfaauw"	ref="acc" def="acc"	ifunc="__ev_dotp4hassfaauw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hassflwa"	def="acc"		ifunc="__ev_dotp4hassflwa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hassflw"	traits="CH.PURE"	ifunc="__ev_dotp4hassflw(0 eV eV [eV])"	/>
	<inst name="evdotp4hassfuwa"	def="acc"		ifunc="__ev_dotp4hassfuwa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hassfuw"	traits="CH.PURE"	ifunc="__ev_dotp4hassfuw(0 eV eV [eV])"	/>
	<inst name="evdotp4hassiaalw"	ref="acc" def="acc"	ifunc="__ev_dotp4hassiaalw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hassiaauw"	ref="acc" def="acc"	ifunc="__ev_dotp4hassiaauw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hassilwa"	def="acc"		ifunc="__ev_dotp4hassilwa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hassilw"	traits="CH.PURE"	ifunc="__ev_dotp4hassilw(0 eV eV [eV])"	/>
	<inst name="evdotp4hassiuwa"	def="acc"		ifunc="__ev_dotp4hassiuwa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hassiuw"	traits="CH.PURE"	ifunc="__ev_dotp4hassiuw(0 eV eV [eV])"	/>
	<inst name="evdotp4hasumiaalw"	ref="acc" def="acc"	ifunc="__ev_dotp4hasumiaalw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hasumiaauw"	ref="acc" def="acc"	ifunc="__ev_dotp4hasumiaauw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hasumilwa"	def="acc"		ifunc="__ev_dotp4hasumilwa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hasumilw"	traits="CH.PURE"	ifunc="__ev_dotp4hasumilw(0 eV eV [eV])"	/>
	<inst name="evdotp4hasumiuwa"	def="acc"		ifunc="__ev_dotp4hasumiuwa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hasumiuw"	traits="CH.PURE"	ifunc="__ev_dotp4hasumiuw(0 eV eV [eV])"	/>
	<inst name="evdotp4hasusiaalw"	ref="acc" def="acc"	ifunc="__ev_dotp4hasusiaalw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hasusiaauw"	ref="acc" def="acc"	ifunc="__ev_dotp4hasusiaauw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hasusilwa"	def="acc"		ifunc="__ev_dotp4hasusilwa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hasusilw"	traits="CH.PURE"	ifunc="__ev_dotp4hasusilw(0 eV eV [eV])"	/>
	<inst name="evdotp4hasusiuwa"	def="acc"		ifunc="__ev_dotp4hasusiuwa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hasusiuw"	traits="CH.PURE"	ifunc="__ev_dotp4hasusiuw(0 eV eV [eV])"	/>
	<inst name="evdotp4haumiaalw"	ref="acc" def="acc"	ifunc="__ev_dotp4haumiaalw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4haumiaauw"	ref="acc" def="acc"	ifunc="__ev_dotp4haumiaauw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4haumilwa"	def="acc"		ifunc="__ev_dotp4haumilwa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4haumilw"	traits="CH.PURE"	ifunc="__ev_dotp4haumilw(0 eV eV [eV])"	/>
	<inst name="evdotp4haumiuwa"	def="acc"		ifunc="__ev_dotp4haumiuwa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4haumiuw"	traits="CH.PURE"	ifunc="__ev_dotp4haumiuw(0 eV eV [eV])"	/>
	<inst name="evdotp4hausiaalw"	ref="acc" def="acc"	ifunc="__ev_dotp4hausiaalw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hausiaauw"	ref="acc" def="acc"	ifunc="__ev_dotp4hausiaauw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hausilwa"	def="acc"		ifunc="__ev_dotp4hausilwa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hausilw"	traits="CH.PURE"	ifunc="__ev_dotp4hausilw(0 eV eV [eV])"	/>
	<inst name="evdotp4hausiuwa"	def="acc"		ifunc="__ev_dotp4hausiuwa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hausiuw"	traits="CH.PURE"	ifunc="__ev_dotp4hausiuw(0 eV eV [eV])"	/>
	<inst name="evdotp4hgasmfaa"	ref="acc" def="acc"	ifunc="__ev_dotp4hgasmfaa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hgasmfa"	def="acc"		ifunc="__ev_dotp4hgasmfa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hgasmf"	traits="CH.PURE"	ifunc="__ev_dotp4hgasmf(0 eV eV [eV])"	/>
	<inst name="evdotp4hgasmiaa"	ref="acc" def="acc"	ifunc="__ev_dotp4hgasmiaa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hgasmia"	def="acc"		ifunc="__ev_dotp4hgasmia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hgasmi"	traits="CH.PURE"	ifunc="__ev_dotp4hgasmi(0 eV eV [eV])"	/>
	<inst name="evdotp4hgasumiaa"	ref="acc" def="acc"	ifunc="__ev_dotp4hgasumiaa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hgasumia"	def="acc"		ifunc="__ev_dotp4hgasumia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hgasumi"	traits="CH.PURE"	ifunc="__ev_dotp4hgasumi(0 eV eV [eV])"	/>
	<inst name="evdotp4hgaumiaa"	ref="acc" def="acc"	ifunc="__ev_dotp4hgaumiaa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hgaumia"	def="acc"		ifunc="__ev_dotp4hgaumia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotp4hgaumi"	traits="CH.PURE"	ifunc="__ev_dotp4hgaumi(0 eV eV [eV])"	/>
	<inst name="evdotpbasmiaaw"	ref="acc" def="acc"	ifunc="__ev_dotpbasmiaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpbasmia"	def="acc"		ifunc="__ev_dotpbasmia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpbasmi"	traits="CH.PURE"	ifunc="__ev_dotpbasmi(0 eV eV [eV])"	/>
	<inst name="evdotpbasumiaaw"	ref="acc" def="acc"	ifunc="__ev_dotpbasumiaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpbasumia"	def="acc"		ifunc="__ev_dotpbasumia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpbasumi"	traits="CH.PURE"	ifunc="__ev_dotpbasumi(0 eV eV [eV])"	/>
	<inst name="evdotpbaumiaaw"	ref="acc" def="acc"	ifunc="__ev_dotpbaumiaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpbaumia"	def="acc"		ifunc="__ev_dotpbaumia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpbaumi"	traits="CH.PURE"	ifunc="__ev_dotpbaumi(0 eV eV [eV])"	/>
	<inst name="evdotphasmfaaw"	ref="acc" def="acc"	ifunc="__ev_dotphasmfaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphasmfa"	def="acc"		ifunc="__ev_dotphasmfa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphasmf"	traits="CH.PURE"	ifunc="__ev_dotphasmf(0 eV eV [eV])"	/>
	<inst name="evdotphasmiaaw"	ref="acc" def="acc"	ifunc="__ev_dotphasmiaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphasmia"	def="acc"		ifunc="__ev_dotphasmia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphasmi"	traits="CH.PURE"	ifunc="__ev_dotphasmi(0 eV eV [eV])"	/>
	<inst name="evdotphassfaaw"	ref="acc" def="acc"	ifunc="__ev_dotphassfaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphassfa"	def="acc"		ifunc="__ev_dotphassfa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphassf"	traits="CH.PURE"	ifunc="__ev_dotphassf(0 eV eV [eV])"	/>
	<inst name="evdotphassiaaw"	ref="acc" def="acc"	ifunc="__ev_dotphassiaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphassia"	def="acc"		ifunc="__ev_dotphassia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphassi"	traits="CH.PURE"	ifunc="__ev_dotphassi(0 eV eV [eV])"	/>
	<inst name="evdotphasumiaaw"	ref="acc" def="acc"	ifunc="__ev_dotphasumiaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphasumia"	def="acc"		ifunc="__ev_dotphasumia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphasumi"	traits="CH.PURE"	ifunc="__ev_dotphasumi(0 eV eV [eV])"	/>
	<inst name="evdotphasusiaaw"	ref="acc" def="acc"	ifunc="__ev_dotphasusiaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphasusia"	def="acc"		ifunc="__ev_dotphasusia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphasusi"	traits="CH.PURE"	ifunc="__ev_dotphasusi(0 eV eV [eV])"	/>
	<inst name="evdotphaumiaaw"	ref="acc" def="acc"	ifunc="__ev_dotphaumiaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphaumia"	def="acc"		ifunc="__ev_dotphaumia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphaumi"	traits="CH.PURE"	ifunc="__ev_dotphaumi(0 eV eV [eV])"	/>
	<inst name="evdotphausiaaw"	ref="acc" def="acc"	ifunc="__ev_dotphausiaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphausia"	def="acc"		ifunc="__ev_dotphausia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphausi"	traits="CH.PURE"	ifunc="__ev_dotphausi(0 eV eV [eV])"	/>
	<inst name="evdotphcsmfaaw"	ref="acc" def="acc"	ifunc="__ev_dotphcsmfaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphcsmfa"	def="acc"		ifunc="__ev_dotphcsmfa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphcsmf"	traits="CH.PURE"	ifunc="__ev_dotphcsmf(0 eV eV [eV])"	/>
	<inst name="evdotphcsmiaaw"	ref="acc" def="acc"	ifunc="__ev_dotphcsmiaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphcsmia"	def="acc"		ifunc="__ev_dotphcsmia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphcsmi"	traits="CH.PURE"	ifunc="__ev_dotphcsmi(0 eV eV [eV])"	/>
	<inst name="evdotphcssfaaw"	ref="acc" def="acc"	ifunc="__ev_dotphcssfaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphcssfa"	def="acc"		ifunc="__ev_dotphcssfa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphcssf"	traits="CH.PURE"	ifunc="__ev_dotphcssf(0 eV eV [eV])"	/>
	<inst name="evdotphcssiaaw"	ref="acc" def="acc"	ifunc="__ev_dotphcssiaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphcssia"	def="acc"		ifunc="__ev_dotphcssia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphcssi"	traits="CH.PURE"	ifunc="__ev_dotphcssi(0 eV eV [eV])"	/>
	<inst name="evdotphssmfaaw"	ref="acc" def="acc"	ifunc="__ev_dotphssmfaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphssmfa"	def="acc"		ifunc="__ev_dotphssmfa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphssmf"	traits="CH.PURE"	ifunc="__ev_dotphssmf(0 eV eV [eV])"	/>
	<inst name="evdotphssmiaaw"	ref="acc" def="acc"	ifunc="__ev_dotphssmiaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphssmia"	def="acc"		ifunc="__ev_dotphssmia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphssmi"	traits="CH.PURE"	ifunc="__ev_dotphssmi(0 eV eV [eV])"	/>
	<inst name="evdotphsssfaaw"	ref="acc" def="acc"	ifunc="__ev_dotphsssfaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphsssfa"	def="acc"		ifunc="__ev_dotphsssfa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphsssf"	traits="CH.PURE"	ifunc="__ev_dotphsssf(0 eV eV [eV])"	/>
	<inst name="evdotphsssiaaw"	ref="acc" def="acc"	ifunc="__ev_dotphsssiaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphsssia"	def="acc"		ifunc="__ev_dotphsssia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphsssi"	traits="CH.PURE"	ifunc="__ev_dotphsssi(0 eV eV [eV])"	/>
	<inst name="evdotphxasmfaaw"	ref="acc" def="acc"	ifunc="__ev_dotphxasmfaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphxasmfa"	def="acc"		ifunc="__ev_dotphxasmfa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphxasmf"	traits="CH.PURE"	ifunc="__ev_dotphxasmf(0 eV eV [eV])"	/>
	<inst name="evdotphxasmiaaw"	ref="acc" def="acc"	ifunc="__ev_dotphxasmiaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphxasmia"	def="acc"		ifunc="__ev_dotphxasmia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphxasmi"	traits="CH.PURE"	ifunc="__ev_dotphxasmi(0 eV eV [eV])"	/>
	<inst name="evdotphxassfaaw"	ref="acc" def="acc"	ifunc="__ev_dotphxassfaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphxassfa"	def="acc"		ifunc="__ev_dotphxassfa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphxassf"	traits="CH.PURE"	ifunc="__ev_dotphxassf(0 eV eV [eV])"	/>
	<inst name="evdotphxassiaaw"	ref="acc" def="acc"	ifunc="__ev_dotphxassiaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphxassia"	def="acc"		ifunc="__ev_dotphxassia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotphxassi"	traits="CH.PURE"	ifunc="__ev_dotphxassi(0 eV eV [eV])"	/>
	<inst name="evdotpwasmiaa"	ref="acc" def="acc"	ifunc="__ev_dotpwasmiaa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpwasmia"	def="acc"		ifunc="__ev_dotpwasmia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpwasmi"	traits="CH.PURE"	ifunc="__ev_dotpwasmi(0 eV eV [eV])"	/>
	<inst name="evdotpwassiaa"	ref="acc" def="acc"	ifunc="__ev_dotpwassiaa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpwassia"	def="acc"		ifunc="__ev_dotpwassia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpwassi"	traits="CH.PURE"	ifunc="__ev_dotpwassi(0 eV eV [eV])"	/>
	<inst name="evdotpwasumiaa"	ref="acc" def="acc"	ifunc="__ev_dotpwasumiaa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpwasumia"	def="acc"		ifunc="__ev_dotpwasumia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpwasumi"	traits="CH.PURE"	ifunc="__ev_dotpwasumi(0 eV eV [eV])"	/>
	<inst name="evdotpwasusiaa"	ref="acc" def="acc"	ifunc="__ev_dotpwasusiaa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpwasusia"	def="acc"		ifunc="__ev_dotpwasusia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpwasusi"	traits="CH.PURE"	ifunc="__ev_dotpwasusi(0 eV eV [eV])"	/>
	<inst name="evdotpwaumiaa"	ref="acc" def="acc"	ifunc="__ev_dotpwaumiaa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpwaumia"	def="acc"		ifunc="__ev_dotpwaumia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpwaumi"	traits="CH.PURE"	ifunc="__ev_dotpwaumi(0 eV eV [eV])"	/>
	<inst name="evdotpwausiaa"	ref="acc" def="acc"	ifunc="__ev_dotpwausiaa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpwausia"	def="acc"		ifunc="__ev_dotpwausia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpwausi"	traits="CH.PURE"	ifunc="__ev_dotpwausi(0 eV eV [eV])"	/>
	<inst name="evdotpwssmiaa"	ref="acc" def="acc"	ifunc="__ev_dotpwssmiaa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpwssmia"	def="acc"		ifunc="__ev_dotpwssmia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpwssmi"	traits="CH.PURE"	ifunc="__ev_dotpwssmi(0 eV eV [eV])"	/>
	<inst name="evdotpwsssiaa"	ref="acc" def="acc"	ifunc="__ev_dotpwsssiaa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpwxasmiaa"	ref="acc" def="acc"	ifunc="__ev_dotpwxasmiaa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpwxasmia"	def="acc"		ifunc="__ev_dotpwxasmia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpwxasmi"	traits="CH.PURE"	ifunc="__ev_dotpwxasmi(0 eV eV [eV])"	/>
	<inst name="evdotpwxassiaa"	ref="acc" def="acc"	ifunc="__ev_dotpwxassiaa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpwxassia"	def="acc"		ifunc="__ev_dotpwxassia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evdotpwxassi"	traits="CH.PURE"	ifunc="__ev_dotpwxassi(0 eV eV [eV])"	/>
	<inst traits="CH.PURE">
	    <inst name="evilveh"				ifunc="__ev_ilveh(0 eV eV [eV])"	/>
	    <inst name="evilveoh"				ifunc="__ev_ilveoh(0 eV eV [eV])"	/>
	    <inst name="evilvhih"				ifunc="__ev_ilvhih(0 eV eV [eV])"	/>
	    <inst name="evilvhiloh"				ifunc="__ev_ilvhiloh(0 eV eV [eV])"	/>
	    <inst name="evilvloh"				ifunc="__ev_ilvloh(0 eV eV [eV])"	/>
	    <inst name="evilvlohih"				ifunc="__ev_ilvlohih(0 eV eV [eV])"	/>
	    <inst name="evilvoeh"				ifunc="__ev_ilvoeh(0 eV eV [eV])"	/>
	    <inst name="evilvoh"				ifunc="__ev_ilvoh(0 eV eV [eV])"	/>
	    <inst name="evmaxbs"				ifunc="__ev_maxbs(0 eV eV [eV])"	/>
	    <inst name="evmaxbu"				ifunc="__ev_maxbu(0 eV eV [eV])"	/>
	    <inst name="evmaxhs"				ifunc="__ev_maxhs(0 eV eV [eV])"	/>
	    <inst name="evmaxhu"				ifunc="__ev_maxhu(0 eV eV [eV])"	/>
	    <inst name="evmaxws"				ifunc="__ev_maxws(0 eV eV [eV])"	/>
	    <inst name="evmaxwu"				ifunc="__ev_maxwu(0 eV eV [eV])"	/>
	</inst>
	<inst name="evmbesmiaah"	ref="acc" def="acc"	ifunc="__ev_mbesmiaah(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbesmia"		def="acc"		ifunc="__ev_mbesmia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbesmianh"	def="acc"		ifunc="__ev_mbesmianh(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbesmi"		traits="CH.PURE"	ifunc="__ev_mbesmi(0 eV eV [eV])"	/>
	<inst name="evmbessiaah"	ref="acc" def="acc"	ifunc="__ev_mbessiaah(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbessianh"	def="acc"		ifunc="__ev_mbessianh(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbesumiaah"	ref="acc" def="acc"	ifunc="__ev_mbesumiaah(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbesumia"		def="acc"		ifunc="__ev_mbesumia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbesumianh"	def="acc"		ifunc="__ev_mbesumianh(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbesumi"		traits="CH.PURE"	ifunc="__ev_mbesumi(0 eV eV [eV])"	/>
	<inst name="evmbesusiaah"	ref="acc" def="acc"	ifunc="__ev_mbesusiaah(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbesusianh"	def="acc"		ifunc="__ev_mbesusianh(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbeumiaah"	ref="acc" def="acc"	ifunc="__ev_mbeumiaah(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbeumia"		def="acc"		ifunc="__ev_mbeumia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbeumianh"	def="acc"		ifunc="__ev_mbeumianh(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbeumi"		traits="CH.PURE"	ifunc="__ev_mbeumi(0 eV eV [eV])"	/>
	<inst name="evmbeusiaah"	ref="acc" def="acc"	ifunc="__ev_mbeusiaah(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbeusianh"	def="acc"		ifunc="__ev_mbeusianh(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbosmiaah"	ref="acc" def="acc"	ifunc="__ev_mbosmiaah(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbosmia"		def="acc"		ifunc="__ev_mbosmia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbosmianh"	def="acc"		ifunc="__ev_mbosmianh(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbosmi"		traits="CH.PURE"	ifunc="__ev_mbosmi(0 eV eV [eV])"	/>
	<inst name="evmbossiaah"	ref="acc" def="acc"	ifunc="__ev_mbossiaah(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbossianh"	def="acc"		ifunc="__ev_mbossianh(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbosumiaah"	ref="acc" def="acc"	ifunc="__ev_mbosumiaah(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbosumia"		def="acc"		ifunc="__ev_mbosumia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbosumianh"	def="acc"		ifunc="__ev_mbosumianh(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbosumi"		traits="CH.PURE"	ifunc="__ev_mbosumi(0 eV eV [eV])"	/>
	<inst name="evmbosusiaah"	ref="acc" def="acc"	ifunc="__ev_mbosusiaah(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbosusianh"	def="acc"		ifunc="__ev_mbosusianh(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmboumiaah"	ref="acc" def="acc"	ifunc="__ev_mboumiaah(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmboumia"		def="acc"		ifunc="__ev_mboumia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmboumianh"	def="acc"		ifunc="__ev_mboumianh(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmboumi"		traits="CH.PURE"	ifunc="__ev_mboumi(0 eV eV [eV])"	/>
	<inst name="evmbousiaah"	ref="acc" def="acc"	ifunc="__ev_mbousiaah(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmbousianh"	def="acc"		ifunc="__ev_mbousianh(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmhesumiaaw"	ref="acc" def="acc"	ifunc="__ev_mhesumiaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmhesumia"		def="acc"		ifunc="__ev_mhesumia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmhesumianw"	def="acc"		ifunc="__ev_mhesumianw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmhesumi"		traits="CH.PURE"	ifunc="__ev_mhesumi(0 eV eV [eV])"	/>
	<inst name="evmhesusiaaw"	ref="acc" def="acc"	ifunc="__ev_mhesusiaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmhesusianw"	def="acc"		ifunc="__ev_mhesusianw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmhosumiaaw"	ref="acc" def="acc"	ifunc="__ev_mhosumiaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmhosumia"		def="acc"		ifunc="__ev_mhosumia(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmhosumianw"	def="acc"		ifunc="__ev_mhosumianw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmhosumi"		traits="CH.PURE"	ifunc="__ev_mhosumi(0 eV eV [eV])"	/>
	<inst name="evmhosusiaaw"	ref="acc" def="acc"	ifunc="__ev_mhosusiaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmhosusianw"	def="acc"		ifunc="__ev_mhosusianw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst traits="CH.PURE">
	    <inst name="evmhsmf"				ifunc="__ev_mhsmf(0 eV eV [eV])"	/>
	    <inst name="evmhsmfr"				ifunc="__ev_mhsmfr(0 eV eV [eV])"	/>
	    <inst name="evmhssf"				ifunc="__ev_mhssf(0 eV eV [eV])"	/>
	    <inst name="evmhssfr"				ifunc="__ev_mhssfr(0 eV eV [eV])"	/>
	    <inst name="evmhssi"				ifunc="__ev_mhssi(0 eV eV [eV])"	/>
	    <inst name="evmhsusi"				ifunc="__ev_mhsusi(0 eV eV [eV])"	/>
	    <inst name="evmhumi"				ifunc="__ev_mhumi(0 eV eV [eV])"	/>
	    <inst name="evmhusi"				ifunc="__ev_mhusi(0 eV eV [eV])"	/>
	    <inst name="evminbs"				ifunc="__ev_minbs(0 eV eV [eV])"	/>
	    <inst name="evminbu"				ifunc="__ev_minbu(0 eV eV [eV])"	/>
	    <inst name="evminhs"				ifunc="__ev_minhs(0 eV eV [eV])"	/>
	    <inst name="evminhu"				ifunc="__ev_minhu(0 eV eV [eV])"	/>
	    <inst name="evminws"				ifunc="__ev_minws(0 eV eV [eV])"	/>
	    <inst name="evminwu"				ifunc="__ev_minwu(0 eV eV [eV])"	/>
	</inst>
	<inst name="evmwhsmfaaw"	ref="acc" def="acc"	ifunc="__ev_mwhsmfaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmwhsmfanw"	traits="CH.PURE"	ifunc="__ev_mwhsmfanw(0 eV eV [eV])"	/>
	<inst name="evmwhsmfraaw"	ref="acc" def="acc"	ifunc="__ev_mwhsmfraaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmwhsmfra"		def="acc"		ifunc="__ev_mwhsmfra(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmwhsmfranw"	traits="CH.PURE"	ifunc="__ev_mwhsmfranw(0 eV eV [eV])"	/>
	<inst name="evmwhsmfr"		traits="CH.PURE"	ifunc="__ev_mwhsmfr(0 eV eV [eV])"	/>
	<inst name="evmwhssfaaw"	ref="acc" def="acc"	ifunc="__ev_mwhssfaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmwhssfanw"	traits="CH.PURE"	ifunc="__ev_mwhssfanw(0 eV eV [eV])"	/>
	<inst name="evmwhssfraaw"	ref="acc" def="acc"	ifunc="__ev_mwhssfraaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmwhssfra"		def="acc"		ifunc="__ev_mwhssfra(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmwhssfranw"	traits="CH.PURE"	ifunc="__ev_mwhssfranw(0 eV eV [eV])"	/>
	<inst name="evmwhssfr"		traits="CH.PURE"	ifunc="__ev_mwhssfr(0 eV eV [eV])"	/>
	<inst name="evmwssiaa"		ref="acc" def="acc"	ifunc="__ev_mwssiaa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evmwssian"		traits="CH.PURE"	ifunc="__ev_mwssian(0 eV eV [eV])"	/>
	<inst name="evmwssiw"		traits="CH.PURE"	ifunc="__ev_mwssiw(0 eV eV [eV])"	/>
	<inst name="evmwusiaa"		ref="acc" def="acc"	ifunc="__ev_mwusiaa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst traits="CH.PURE">
	    <inst name="evmwusian"				ifunc="__ev_mwusian(0 eV eV [eV])"	/>
	    <inst name="evmwusiw"				ifunc="__ev_mwusiw(0 eV eV [eV])"	/>
	    <inst name="evperm2"				ifunc="__ev_perm2(0 eV eV [eV])"	/>
	    <inst name="evperm3"				ifunc="__ev_perm3(0 eV eV [eV])"	/>
	    <inst name="evperm"					ifunc="__ev_perm(0 eV eV [eV])"	/>
	    <inst name="evpkshsbs"				ifunc="__ev_pkshsbs(0 eV eV [eV])"	/>
	    <inst name="evpkshubs"				ifunc="__ev_pkshubs(0 eV eV [eV])"	/>
	    <inst name="evpkswishs"				ifunc="__ev_pkswishs(0 eV eV [eV])"	/>
	    <inst name="evpkswshs"				ifunc="__ev_pkswshs(0 eV eV [eV])"	/>
	    <inst name="evpkswuhs"				ifunc="__ev_pkswuhs(0 eV eV [eV])"	/>
	    <inst name="evpkuhubs"				ifunc="__ev_pkuhubs(0 eV eV [eV])"	/>
	    <inst name="evpkuwuhs"				ifunc="__ev_pkuwuhs(0 eV eV [eV])"	/>
	    <inst name="evrlb"					ifunc="__ev_rlb(0 eV eV [eV])"	/>
	    <inst name="evrlh"					ifunc="__ev_rlh(0 eV eV [eV])"	/>
	</inst>
	<inst name="evsad2shaaw"	ref="acc" def="acc"	ifunc="__ev_sad2shaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsad2sha"		def="acc"		ifunc="__ev_sad2sha(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsad2sh"		traits="CH.PURE"	ifunc="__ev_sad2sh(0 eV eV [eV])"	/>
	<inst name="evsad2uhaaw"	ref="acc" def="acc"	ifunc="__ev_sad2uhaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsad2uha"		def="acc"		ifunc="__ev_sad2uha(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsad2uh"		traits="CH.PURE"	ifunc="__ev_sad2uh(0 eV eV [eV])"	/>
	<inst name="evsad4sbaaw"	ref="acc" def="acc"	ifunc="__ev_sad4sbaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsad4sba"		def="acc"		ifunc="__ev_sad4sba(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsad4sb"		traits="CH.PURE"	ifunc="__ev_sad4sb(0 eV eV [eV])"	/>
	<inst name="evsad4ubaaw"	ref="acc" def="acc"	ifunc="__ev_sad4ubaaw(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsad4uba"		def="acc"		ifunc="__ev_sad4uba(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsad4ub"		traits="CH.PURE"	ifunc="__ev_sad4ub(0 eV eV [eV])"	/>
	<inst name="evsadswaa"		ref="acc" def="acc"	ifunc="__ev_sadswaa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsadswa"		def="acc"		ifunc="__ev_sadswa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsadsw"		traits="CH.PURE"	ifunc="__ev_sadsw(0 eV eV [eV])"	/>
	<inst name="evsaduwaa"		ref="acc" def="acc"	ifunc="__ev_saduwaa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst name="evsaduwa"		def="acc"		ifunc="__ev_saduwa(2008 eV eV [eV])"	kind="K.NO_CSE"	/>
	<inst traits="CH.PURE">
	    <inst name="evsaduw"				ifunc="__ev_saduw(0 eV eV [eV])"	/>
	    <inst name="evselbit"				ifunc="__ev_selbit(0 eV eV [eV])"	/>
	    <inst name="evselbitm0"				ifunc="__ev_selbitm0(0 eV eV [eV])"	/>
	    <inst name="evselbitm1"				ifunc="__ev_selbitm1(0 eV eV [eV])"	/>
	    <inst name="evseteqb"				ifunc="__ev_seteqb(0 eV eV [eV])"	/>
	    <inst name="evseteqh"				ifunc="__ev_seteqh(0 eV eV [eV])"	/>
	    <inst name="evseteqw"				ifunc="__ev_seteqw(0 eV eV [eV])"	/>
	    <inst name="evsetgtbs"				ifunc="__ev_setgtbs(0 eV eV [eV])"	/>
	    <inst name="evsetgtbu"				ifunc="__ev_setgtbu(0 eV eV [eV])"	/>
	    <inst name="evsetgths"				ifunc="__ev_setgths(0 eV eV [eV])"	/>
	    <inst name="evsetgthu"				ifunc="__ev_setgthu(0 eV eV [eV])"	/>
	    <inst name="evsetgtws"				ifunc="__ev_setgtws(0 eV eV [eV])"	/>
	    <inst name="evsetgtwu"				ifunc="__ev_setgtwu(0 eV eV [eV])"	/>
	    <inst name="evsetltbs"				ifunc="__ev_setltbs(0 eV eV [eV])"	/>
	    <inst name="evsetltbu"				ifunc="__ev_setltbu(0 eV eV [eV])"	/>
	    <inst name="evsetlths"				ifunc="__ev_setlths(0 eV eV [eV])"	/>
	    <inst name="evsetlthu"				ifunc="__ev_setlthu(0 eV eV [eV])"	/>
	    <inst name="evsetltws"				ifunc="__ev_setltws(0 eV eV [eV])"	/>
	    <inst name="evsetltwu"				ifunc="__ev_setltwu(0 eV eV [eV])"	/>
	</inst>
	<inst def="cr1"	kind="K.NO_CSE">
	    <inst name="evseteqb."		/>
	    <inst name="evseteqh."		/>
	    <inst name="evseteqw."		/>
	    <inst name="evsetgtbs."		/>
	    <inst name="evsetgtbu."		/>
	    <inst name="evsetgths."		/>
	    <inst name="evsetgthu."		/>
	    <inst name="evsetgtws."		/>
	    <inst name="evsetgtwu."		/>
	    <inst name="evsetltbs."		/>
	    <inst name="evsetltbu."		/>
	    <inst name="evsetlths."		/>
	    <inst name="evsetlthu."		/>
	    <inst name="evsetltws."		/>
	    <inst name="evsetltwu."		/>
	</inst>
	<inst traits="CH.PURE">
	    <inst name="evslb"					ifunc="__ev_slb(0 eV eV [eV])"	/>
	    <inst name="evslh"					ifunc="__ev_slh(0 eV eV [eV])"	/>
	    <inst name="evsl"					ifunc="__ev_sl(0 eV eV [eV])"	/>
	    <inst name="evsrbs"					ifunc="__ev_srbs(0 eV eV [eV])"	/>
	    <inst name="evsrbu"					ifunc="__ev_srbu(0 eV eV [eV])"	/>
	    <inst name="evsrhs"					ifunc="__ev_srhs(0 eV eV [eV])"	/>
	    <inst name="evsrhu"					ifunc="__ev_srhu(0 eV eV [eV])"	/>
	    <inst name="evsrs"					ifunc="__ev_srs(0 eV eV [eV])"	/>
	    <inst name="evsru"					ifunc="__ev_sru(0 eV eV [eV])"	/>
	    <inst name="evsubf2add2h"				ifunc="__ev_subf2add2h(0 eV eV [eV])"	/>
	    <inst name="evsubf2add2hss"				ifunc="__ev_subf2add2hss(0 eV eV [eV])"	/>
	    <inst name="evsubf2add2hus"				ifunc="__ev_subf2add2hus(0 eV eV [eV])"	/>
	    <inst name="evsubfaddh"				ifunc="__ev_subfaddh(0 eV eV [eV])"	/>
	    <inst name="evsubfaddhss"				ifunc="__ev_subfaddhss(0 eV eV [eV])"	/>
	    <inst name="evsubfaddhus"				ifunc="__ev_subfaddhus(0 eV eV [eV])"	/>
	    <inst name="evsubfaddhx"				ifunc="__ev_subfaddhx(0 eV eV [eV])"	/>
	    <inst name="evsubfaddhxss"				ifunc="__ev_subfaddhxss(0 eV eV [eV])"	/>
	    <inst name="evsubfaddhxus"				ifunc="__ev_subfaddhxus(0 eV eV [eV])"	/>
	    <inst name="evsubfaddw"				ifunc="__ev_subfaddw(0 eV eV [eV])"	/>
	    <inst name="evsubfaddwss"				ifunc="__ev_subfaddwss(0 eV eV [eV])"	/>
	    <inst name="evsubfaddwus"				ifunc="__ev_subfaddwus(0 eV eV [eV])"	/>
	    <inst name="evsubfaddwx"				ifunc="__ev_subfaddwx(0 eV eV [eV])"	/>
	    <inst name="evsubfaddwxss"				ifunc="__ev_subfaddwxss(0 eV eV [eV])"	/>
	    <inst name="evsubfaddwxus"				ifunc="__ev_subfaddwxus(0 eV eV [eV])"	/>
	    <inst name="evsubfb"				ifunc="__ev_subfb(0 eV eV [eV])"	/>
	    <inst name="evsubfbss"				ifunc="__ev_subfbss(0 eV eV [eV])"	/>
	    <inst name="evsubfbus"				ifunc="__ev_subfbus(0 eV eV [eV])"	/>
	    <inst name="evsubfh"				ifunc="__ev_subfh(0 eV eV [eV])"	/>
	    <inst name="evsubfhss"				ifunc="__ev_subfhss(0 eV eV [eV])"	/>
	    <inst name="evsubfhus"				ifunc="__ev_subfhus(0 eV eV [eV])"	/>
	    <inst name="evsubfhx"				ifunc="__ev_subfhx(0 eV eV [eV])"	/>
	    <inst name="evsubfhxss"				ifunc="__ev_subfhxss(0 eV eV [eV])"	/>
	    <inst name="evsubfhxus"				ifunc="__ev_subfhxus(0 eV eV [eV])"	/>
	    <inst name="evsubfwss"				ifunc="__ev_subfwss(0 eV eV [eV])"	/>
	    <inst name="evsubfwus"				ifunc="__ev_subfwus(0 eV eV [eV])"	/>
	    <inst name="evsubfwx"				ifunc="__ev_subfwx(0 eV eV [eV])"	/>
	    <inst name="evsubfwxss"				ifunc="__ev_subfwxss(0 eV eV [eV])"	/>
	    <inst name="evsubfwxus"				ifunc="__ev_subfwxus(0 eV eV [eV])"	/>
	    <inst name="evswapbhilo"				ifunc="__ev_swapbhilo(0 eV eV [eV])"	/>
	    <inst name="evswapblohi"				ifunc="__ev_swapblohi(0 eV eV [eV])"	/>
	    <inst name="evswaphe"				ifunc="__ev_swaphe(0 eV eV [eV])"	/>
	    <inst name="evswaphhi"				ifunc="__ev_swaphhi(0 eV eV [eV])"	/>
	    <inst name="evswaphhilo"				ifunc="__ev_swaphhilo(0 eV eV [eV])"	/>
	    <inst name="evswaphlohi"				ifunc="__ev_swaphlohi(0 eV eV [eV])"	/>
	    <inst name="evswaphlo"				ifunc="__ev_swaphlo(0 eV eV [eV])"	/>
	    <inst name="evswapho"				ifunc="__ev_swapho(0 eV eV [eV])"	/>
	</inst>
    </inst>

    <inst cost="POC.MEM" flags="F.LD|F.R0IS0" parse="PpcParseClass.EV64UNARY2" pop="POP.LOADD" export="EXPORT.SPE2" ic="IC.LD" itype="LT.T_2OPC" key="KEY.PPCEV_LOAD" tflag="PTF.NOREMAT">
	<inst size="8" flags="F.SZ_EIGHT" tflag="PTF.EV64BY8">
	    <inst name="evldb"		traits="CH.PURE"	ifunc="__ev_ldb(2053 eVP C31 [eV])"	/>
	    <inst name="evldbu"		flags="F.UPDATE"   	ifunc="__ev_ldbu(2053 eVP C31 [eV])"	/>
	    <inst name="evlddu"		flags="F.UPDATE"   	ifunc="__ev_lddu(2053 eVP C31 [eV])"	/>
	    <inst name="evldhu"		flags="F.UPDATE"   	ifunc="__ev_ldhu(2053 eVP C31 [eV])"	/>
	    <inst name="evldwu"		flags="F.UPDATE"   	ifunc="__ev_ldwu(2053 eVP C31 [eV])"	/>
	</inst>
	<inst size="4" flags="F.SZ_FOUR" tflag="PTF.EV64BY4" traits="CH.PURE">
	    <inst name="evlwbe"					ifunc="__ev_lwbe(2053 eVP C31 [eV])"	/>
	    <inst name="evlwbos"				ifunc="__ev_lwbos(2053 eVP C31 [eV])"	/>
	</inst>
	<inst size="4" flags="F.SZ_FOUR|F.UPDATE" tflag="PTF.EV64BY4">
	    <inst name="evlwbeu"				ifunc="__ev_lwbeu(2053 eVP C31 [eV])"	/>
	    <inst name="evlwbosu"				ifunc="__ev_lwbosu(2053 eVP C31 [eV])"	/>
	    <inst name="evlwbou"				ifunc="__ev_lwbou(2053 eVP C31 [eV])"	/>
	    <inst name="evlwbouu"				ifunc="__ev_lwbouu(2053 eVP C31 [eV])"	/>
	    <inst name="evlwheu"				ifunc="__ev_lwheu(2053 eVP C31 [eV])"	/>
	    <inst name="evlwhosu"				ifunc="__ev_lwhosu(2053 eVP C31 [eV])"	/>
	    <inst name="evlwhouu"				ifunc="__ev_lwhouu(2053 eVP C31 [eV])"	/>
	</inst>
	<inst kind="K.NO_CSE" size="1" flags="F.SZ_ONE" tflag="PTF.EV64BY2">
	    <inst name="evlbbsplatb"	traits="CH.PURE"	ifunc="__ev_lbbsplatb(2053 eVP C31 [eV])"	/>
	    <inst name="evlbbsplatbu"	flags="F.UPDATE"	ifunc="__ev_lbbsplatbu(2053 eVP C31 [eV])"	/>
	</inst>
	<inst kind="K.NO_CSE" size="2" flags="F.SZ_TWO" tflag="PTF.EV64BY2">
	    <inst name="evlhhesplatu"	flags="F.UPDATE"	ifunc="__ev_lhhesplatu(2053 eVP C31 [eV])"	/>
	    <inst name="evlhhossplatu"	flags="F.UPDATE"	ifunc="__ev_lhhossplatu(2053 eVP C31 [eV])"	/>
	    <inst name="evlhhousplatu"	flags="F.UPDATE"	ifunc="__ev_lhhousplatu(2053 eVP C31 [eV])"	/>
	    <inst name="evlhhsplath"	traits="CH.PURE"	ifunc="__ev_lhhsplath(2053 eVP C31 [eV])"	/>
	    <inst name="evlhhsplathu"	flags="F.UPDATE"	ifunc="__ev_lhhsplathu(2053 eVP C31 [eV])"	/>
	</inst>
	<inst kind="K.NO_CSE" size="4" flags="F.SZ_FOUR" tflag="PTF.EV64BY4">
	    <inst name="evlwbsplatw"	traits="CH.PURE"	ifunc="__ev_lwbsplatw(2053 eVP C31 [eV])"	/>
	    <inst name="evlwbsplatwu"	flags="F.UPDATE"	ifunc="__ev_lwbsplatwu(2053 eVP C31 [eV])"	/>
	    <inst name="evlwhsplatu"	flags="F.UPDATE"	ifunc="__ev_lwhsplatu(2053 eVP C31 [eV])"	/>
	    <inst name="evlwhsplatw"	traits="CH.PURE"	ifunc="__ev_lwhsplatw(2053 eVP C31 [eV])"	/>
	    <inst name="evlwhsplatwu"	flags="F.UPDATE"	ifunc="__ev_lwhsplatwu(2053 eVP C31 [eV])"	/>
	    <inst name="evlwwsplatu"	flags="F.UPDATE"	ifunc="__ev_lwwsplatu(2053 eVP C31 [eV])"	/>
	</inst>
    </inst>

    <inst cost="POC.MEM" flags="F.LD|F.R0IS0" parse="PpcParseClass.EV64UNARY2" pop="POP.LOADD" export="EXPORT.SPE2" ic="IC.LD" itype="LT.T_3OP" key="KEY.PPCEV_LOAD" tflag="PTF.NOREMAT">
	<inst size="8" flags="F.SZ_EIGHT">
	    <inst name="evldbux"	flags="F.UPDATE"	ifunc="__ev_ldbux(2008 eVP i [eV])"	/>
	    <inst name="evldbx"		traits="CH.PURE"	ifunc="__ev_ldbx(2008 eVP i [eV])"	/>
	    <inst name="evlddux"	flags="F.UPDATE"	ifunc="__ev_lddux(2008 eVP i [eV])"	/>
	    <inst name="evldhux"	flags="F.UPDATE"	ifunc="__ev_ldhux(2008 eVP i [eV])"	/>
	    <inst name="evldwux"	flags="F.UPDATE"	ifunc="__ev_ldwux(2008 eVP i [eV])"	/>
	    <inst name="evlvsl"		traits="CH.PURE"	ifunc="__ev_lvsl(2008 eVP i [eV])"	/>
	    <inst name="evlvsr"		traits="CH.PURE"	ifunc="__ev_lvsr(2008 eVP i [eV])"	/>
	</inst>
	<inst size="4" flags="F.SZ_FOUR">
	    <inst name="evlwbeux"	flags="F.UPDATE"	ifunc="__ev_lwbeux(2008 eVP i [eV])"	/>
	    <inst name="evlwbex"	traits="CH.PURE"	ifunc="__ev_lwbex(2008 eVP i [eV])"	/>
	    <inst name="evlwbosux"	flags="F.UPDATE"	ifunc="__ev_lwbosux(2008 eVP i [eV])"	/>
	    <inst name="evlwbosx"	traits="CH.PURE"	ifunc="__ev_lwbosx(2008 eVP i [eV])"	/>
	    <inst name="evlwbouux"	flags="F.UPDATE"	ifunc="__ev_lwbouux(2008 eVP i [eV])"	/>
	    <inst name="evlwboux"	flags="F.UPDATE"	ifunc="__ev_lwboux(2008 eVP i [eV])"	/>
	    <inst name="evlwheux"	flags="F.UPDATE"	ifunc="__ev_lwheux(2008 eVP i [eV])"	/>
	    <inst name="evlwhosux"	flags="F.UPDATE"	ifunc="__ev_lwhosux(2008 eVP i [eV])"	/>
	    <inst name="evlwhouux"	flags="F.UPDATE"	ifunc="__ev_lwhouux(2008 eVP i [eV])"	/>
	</inst>
	<inst size="1" flags="F.SZ_ONE" kind="K.NO_CSE">
	    <inst name="evlbbsplatbux"	flags="F.UPDATE"	ifunc="__ev_lbbsplatbux(2008 eVP i [eV])"	/>
	    <inst name="evlbbsplatbx"	traits="CH.PURE"	ifunc="__ev_lbbsplatbx(2008 eVP i [eV])"	/>
	</inst>
	<inst size="2" flags="F.SZ_TWO" kind="K.NO_CSE">
	    <inst name="evlhhesplatux"	flags="F.UPDATE"	ifunc="__ev_lhhesplatux(2008 eVP i [eV])"	/>
	    <inst name="evlhhossplatux"	flags="F.UPDATE"	ifunc="__ev_lhhossplatux(2008 eVP i [eV])"	/>
	    <inst name="evlhhousplatux"	flags="F.UPDATE"	ifunc="__ev_lhhousplatux(2008 eVP i [eV])"	/>
	    <inst name="evlhhsplathux"	flags="F.UPDATE"	ifunc="__ev_lhhsplathux(2008 eVP i [eV])"	/>
	    <inst name="evlhhsplathx"				ifunc="__ev_lhhsplathx(2008 eVP i [eV])"	/>
	</inst>
	<inst size="4" flags="F.SZ_FOUR" kind="K.NO_CSE">
	    <inst name="evlwbsplatwux"	flags="F.UPDATE"	ifunc="__ev_lwbsplatwux(2008 eVP i [eV])"	/>
	    <inst name="evlwbsplatwx"	traits="CH.PURE"	ifunc="__ev_lwbsplatwx(2008 eVP i [eV])"	/>
	    <inst name="evlwhsplatux"	flags="F.UPDATE"	ifunc="__ev_lwhsplatux(2008 eVP i [eV])"	/>
	    <inst name="evlwhsplatwux"	flags="F.UPDATE"	ifunc="__ev_lwhsplatwux(2008 eVP i [eV])"	/>
	    <inst name="evlwhsplatwx"	traits="CH.PURE"	ifunc="__ev_lwhsplatwx(2008 eVP i [eV])"	/>
	    <inst name="evlwwsplatux"	flags="F.UPDATE"	ifunc="__ev_lwwsplatux(2008 eVP i [eV])"	/>
	</inst>
    </inst>

    <inst cost="POC.MEM" flags="F.ST|F.R0IS0" export="EXPORT.SPE2" parse="PpcParseClass.EV64STORE"   pop="POP.STORED" ic="IC.ST" itype="LT.T_U_TWO_C" key="KEY.PPCEV_STORE" tflag="PTF.NOREMAT">
	<inst size="8" flags="F.SZ_EIGHT" tflag="PTF.EV64BY8">
	    <inst name="evstdb"					ifunc="__ev_stdb(2025 eV eVP C31 [V])"	/>
	    <inst name="evstdbu"	flags="F.UPDATE"	ifunc="__ev_stdbu(2025 eV eVP C31 [V])"	/>
	    <inst name="evstddu"	flags="F.UPDATE"	ifunc="__ev_stddu(2025 eV eVP C31 [V])"	/>
	    <inst name="evstdhu"	flags="F.UPDATE"	ifunc="__ev_stdhu(2025 eV eVP C31 [V])"	/>
	    <inst name="evstdwu"	flags="F.UPDATE"	ifunc="__ev_stdwu(2025 eV eVP C31 [V])"	/>
	</inst>
	<inst size="2" flags="F.SZ_TWO" tflag="PTF.EV64BY2">
	    <inst name="evsthb"					ifunc="__ev_sthb(2025 eV eVP C31 [V])"	/>
	    <inst name="evsthbu"	flags="F.UPDATE"	ifunc="__ev_sthbu(2025 eV eVP C31 [V])"	/>
	</inst>
	<inst size="4" flags="F.SZ_FOUR" tflag="PTF.EV64BY4">
	    <inst name="evstwbe"				ifunc="__ev_stwbe(2025 eV eVP C31 [V])"	/>
	    <inst name="evstwbeu"	flags="F.UPDATE"	ifunc="__ev_stwbeu(2025 eV eVP C31 [V])"	/>
	    <inst name="evstwb"					ifunc="__ev_stwb(2025 eV eVP C31 [V])"	/>
	    <inst name="evstwbo"				ifunc="__ev_stwbo(2025 eV eVP C31 [V])"	/>
	    <inst name="evstwbou"	flags="F.UPDATE"	ifunc="__ev_stwbou(2025 eV eVP C31 [V])"	/>
	    <inst name="evstwbu"	flags="F.UPDATE"	ifunc="__ev_stwbu(2025 eV eVP C31 [V])"	/>
	    <inst name="evstwheu"	flags="F.UPDATE"	ifunc="__ev_stwheu(2025 eV eVP C31 [V])"	/>
	    <inst name="evstwhou"	flags="F.UPDATE"	ifunc="__ev_stwhou(2025 eV eVP C31 [V])"	/>
	    <inst name="evstwweu"	flags="F.UPDATE"	ifunc="__ev_stwweu(2025 eV eVP C31 [V])"	/>
	    <inst name="evstwwou"	flags="F.UPDATE"	ifunc="__ev_stwwou(2025 eV eVP C31 [V])"	/>
	</inst>
    </inst>

    <inst cost="POC.MEM" flags="F.ST|F.R0IS0" export="EXPORT.SPE2" parse="PpcParseClass.EV64STORE" ic="IC.ST" itype="LT.T_U_THREE" key="KEY.PPCEV_STORE" tflag="PTF.NOREMAT">
	<inst size="8" flags="F.SZ_EIGHT">
	    <inst name="evstdbux"	flags="F.UPDATE"	ifunc="__ev_stdbux(2026 eV eVP i [V])"	/>
	    <inst name="evstdbx"				ifunc="__ev_stdbx(2026 eV eVP i [V])"	/>
	    <inst name="evstddux"	flags="F.UPDATE"	ifunc="__ev_stddux(2026 eV eVP i [V])"	/>
	    <inst name="evstdhux"	flags="F.UPDATE"	ifunc="__ev_stdhux(2026 eV eVP i [V])"	/>
	    <inst name="evstdwux"	flags="F.UPDATE"	ifunc="__ev_stdwux(2026 eV eVP i [V])"	/>
	</inst>
	<inst size="2" flags="F.SZ_TWO">
	    <inst name="evsthbux"	flags="F.UPDATE"	ifunc="__ev_sthbux(2026 eV eVP i [V])"	/>
	    <inst name="evsthbx"				ifunc="__ev_sthbx(2026 eV eVP i [V])"	/>
	</inst>
	<inst size="4" flags="F.SZ_FOUR">
	    <inst name="evstwbeux"	flags="F.UPDATE"	ifunc="__ev_stwbeux(2026 eV eVP i [V])"	/>
	    <inst name="evstwbex"				ifunc="__ev_stwbex(2026 eV eVP i [V])"	/>
	    <inst name="evstwboux"	flags="F.UPDATE"	ifunc="__ev_stwboux(2026 eV eVP i [V])"	/>
	    <inst name="evstwbox"				ifunc="__ev_stwbox(2026 eV eVP i [V])"	/>
	    <inst name="evstwbux"	flags="F.UPDATE"	ifunc="__ev_stwbux(2026 eV eVP i [V])"	/>
	    <inst name="evstwbx"				ifunc="__ev_stwbx(2026 eV eVP i [V])"	/>
	    <inst name="evstwheux"	flags="F.UPDATE"	ifunc="__ev_stwheux(2026 eV eVP i [V])"	/>
	    <inst name="evstwhoux"	flags="F.UPDATE"	ifunc="__ev_stwhoux(2026 eV eVP i [V])"	/>
	    <inst name="evstwweux"	flags="F.UPDATE"	ifunc="__ev_stwweux(2026 eV eVP i [V])"	/>
	    <inst name="evstwwoux"	flags="F.UPDATE"	ifunc="__ev_stwwoux(2026 eV eVP i [V])"	/>
	</inst>
    </inst>

    <inst parse="PpcParseClass.EV64BINARY" cost="POC.FLOATOP" export="EXPORT.SPE2" ic="IC.SU1" itype="LT.T_2OP_CONST" traits="CH.PURE">
	<inst name="evaddih"				ifunc="__ev_addih(2001 eV C31 [eV])"	/>
	<inst name="evaddib"				ifunc="__ev_addib(2001 eV C31 [eV])"	/>
	<inst name="evsubifh"				ifunc="__ev_subifh(2085 C31 eV [eV])"	/>
	<inst name="evsubifb"				ifunc="__ev_subifb(2085 C31 eV [eV])"	/>
	<inst name="evsplath"				ifunc="__ev_splath(2001 eV C4 [eV])"	/>
	<inst name="evsplatb"				ifunc="__ev_splatb(2001 eV C8 [eV])"	/>
	<inst name="evsroiu"				ifunc="__ev_sroiu(2001 eV C8 [eV])"	/>
	<inst name="evsrois"				ifunc="__ev_srois(2001 eV C8 [eV])"	/>
	<inst name="evclrbe"				ifunc="__ev_clrbe(2001 eV C16 [eV])"	/>
	<inst name="evclrbo"				ifunc="__ev_clrbo(2001 eV C16 [eV])"	/>
	<inst name="evclrh"				ifunc="__ev_clrh(2001 eV C16 [eV])"	/>
	<inst name="evsloi"				ifunc="__ev_sloi(2001 eV C8 [eV])"	/>
    </inst>

    <inst parse="PpcParseClass.EV64BDBSI1I2" cost="POC.FLOATOP" export="EXPORT.SPE2" ic="IC.SU1" itype="LT.T_D_U_C_C">
	<inst name="evinsh"				ifunc="__ev_insh(2087 eV C4 C4 [eV])"	/>
	<inst name="evxtrh"	traits="CH.PURE"	ifunc="__ev_xtrh(2087 eV C4 C4 [eV])"	/>
	<inst name="evinsb"				ifunc="__ev_insb(2087 eV C8 C4 [eV])"	/>
	<inst name="evxtrb"	traits="CH.PURE"	ifunc="__ev_xtrb(2087 eV C8 C4 [eV])"	/>
    </inst>

    <inst parse="PpcParseClass.EV64UNARY" cost="POC.FLOATOP" export="EXPORT.SPE2" ic="IC.SU1" itype="LT.T_D_C" traits="CH.PURE">
	<inst name="evsplatib"				ifunc="__ev_splatib(2016 S32 [eV])"	/>
	<inst name="evsplatih"				ifunc="__ev_splatih(2016 S32 [eV])"	/>
	<inst name="evsplatfih"				ifunc="__ev_splatfih(2016 S32 [eV])"	/>
    </inst>

    <inst parse="PpcParseClass.EV64ISEL" cost="POC.FLOATOP" export="EXPORT.SPE2" ic="IC.SU1" itype="LT.T_D_U_U_C" traits="CH.PURE">
	<inst name="evxtrd"				ifunc="__ev_xtrd(2084 eV eV C8 [eV])"	/>
    </inst>
</cond>	<!-- SPE -->

	
	<!-- VLE smaller instruction encoding -->
<cond when="Processor.VLE">
    <inst cost="POC.ARITH" size="4" ic="IC.DEF">
      <inst tflag="PTF.NOREMAT">
	<inst name="se_add"	parse="PpcParseClass.MSRC12" pop="POP.ADD" />
	<inst name="e_add16i"	parse="PpcParseClass.BINARY" pop="POP.ADD" />
	<inst name="e_add2i."	parse="PpcParseClass.MSRC12" pop="POP.ADD" def="CA" />
	<inst name="e_add2is"	parse="PpcParseClass.MSRC12" pop="POP.ADDIS" />
	<inst name="se_addi"	parse="PpcParseClass.MSRC12" pop="POP.ADD" />
	<suffix name="PpcRc" flags="F.DOTPOS">
		<inst name="e_addi"	parse="PpcParseClass.BINARY" pop="POP.ADD" />
		<inst name="e_addic"	parse="PpcParseClass.BINARY"	def="CA" />
		<inst name="se_and"	parse="PpcParseClass.MSRC12" pop="POP.AND" />
		<inst name="e_andi"	parse="PpcParseClass.BINARY" pop="POP.AND" />
	</suffix>
	<inst name="e_and2i."		parse="PpcParseClass.MSRC12"	def="CA" />
      </inst>
	<inst name="e_and2is."		parse="PpcParseClass.MSRC12"	def="CA" />
	<inst name="se_andi"		parse="PpcParseClass.MSRC12" pop="POP.AND" />
	<inst name="se_andc"		parse="PpcParseClass.MSRC12" pop="POP.ANDC" />
	<inst name=".diab.bclri"	parse="PpcParseClass.MSRC12" />
	<inst name="se_bclri"		parse="PpcParseClass.MSRC12" />
	<inst name="se_bgeni"		parse="PpcParseClass.UNARY" tflag="PTF.RECOMPUTE" />
	<inst name="se_bmaski"		parse="PpcParseClass.UNARY" tflag="PTF.RECOMPUTE" />
	<inst name=".diab.bseti"	parse="PpcParseClass.MSRC12" pop="POP.BSETI" />
	<inst name="se_bseti"		parse="PpcParseClass.MSRC12" pop="POP.BSETI" />
    </inst>
    <inst cost="POC.BRANCH" flags="F.BRANCH">
	<inst name="e_b"	parse="PpcParseClass.BRANCH" flags="F.UBR|F.NOPASS" ic="IC.BR" />
	<inst name="e_bl"	parse="PpcParseClass.BRANCH" flags="F.BSR" def="lr" ic="IC.BR" />
	<inst name="se_b"	parse="PpcParseClass.BRANCH" flags="F.UBR|F.NOPASS" ic="IC.BR"/>
	<inst name="se_bl"	parse="PpcParseClass.BRANCH" flags="F.BSR" def="lr" ic="IC.BR" />
	<inst name="e_bc"	parse="PpcParseClass.SRC3"   flags="F.BCND|F.NOPASS|F.BOBI" tflag="PTF.BC" />
	<inst name="e_bcl"	parse="PpcParseClass.SRC3"   flags="F.BCND|F.NOPASS|F.BOBI" tflag="PTF.BC" ref="lr" />
	<inst name="se_bc"	parse="PpcParseClass.SRC3"   flags="F.BCND|F.NOPASS|F.BOBI" tflag="PTF.BC" ic="IC.BR" />
	<inst name="se_bctr"	parse="PpcParseClass.EMPTY"  flags="F.UBR|F.NOPASS" ref="ctr" />
	<inst name="se_bctrl"	parse="PpcParseClass.EMPTY"  flags="F.UBR|F.NOPASS|F.BSR" def="lr" ref="ctr" />
	<inst name="se_blr"	parse="PpcParseClass.EMPTY"  flags="F.RETURN|F.NOPASS" ref="lr" ic="IC.BR" />
	<inst name="se_blrl"	parse="PpcParseClass.EMPTY"  flags="F.UBR|F.NOPASS|F.BSR" def="lr" ref="lr" />
	<inst name="blr"	parse="PpcParseClass.EMPTY"  flags="F.RETURN|F.NOPASS" pop="POP.BLR" ref="lr" ic="IC.BR" />
	<inst name="bcctr"	parse="PpcParseClass.BCLR"   flags="F.BCND|F.NOPASS|F.BOBI" tflag="PTF.BC" ref="ctr" ic="IC.BR" />
	<inst name="bcctrl"	parse="PpcParseClass.BCLR"   flags="F.BCND|F.NOPASS|F.BOBI|F.BSR" tflag="PTF.BC" ref="ctr" ic="IC.BR" />
	<inst name="bclr"	parse="PpcParseClass.BCLR"   flags="F.BCND|F.NOPASS|F.BOBI|F.RETURN" ref="lr" tflag="PTF.BC" ic="IC.BR" />
	<inst name="bclrl"	parse="PpcParseClass.BCLR"   flags="F.BCND|F.NOPASS|F.BOBI|F.RETURN" ref="lr" tflag="PTF.BC" ic="IC.BR" />
    </inst>
    <inst parse="PpcParseClass.SRC2" cost="POC.ARITH" size="4" >
	<!-- diab.btsti is a macro that the assembler changes into a pure se_btsti or into a rlwinm which writes to r0 -->
	<inst name=".diab.btsti"	flags="F.UNSIGNED"	def="cr0,r0"	ref="CA"	pop="POP.DIAB_BTSTI" ic="IC.DEF" />
	<inst name="se_btsti"		flags="F.UNSIGNED"	def="cr0"	ref="CA" ic="IC.DEF" />
	<inst name="e_cmp16i"		flags="F.SIGNED"	def="cr0"	ref="CA" />
	<inst name="e_cmpi"		flags="F.SIGNED"	def="cr0"	ref="CA"	parse="PpcParseClass.SRC3" ic="IC.CMP" />
	<inst name="se_cmp"		flags="F.SIGNED"	def="cr0"	ref="CA" ic="IC.CMP" />
	<inst name="se_cmpi"		flags="F.SIGNED"	def="cr0"	ref="CA" ic="IC.CMP" />
	<inst size="2">
		<inst name="e_cmph"	flags="F.SIGNED"	def="cr0"	ref="CA"	parse="PpcParseClass.SRC3"  ic="IC.CMP" />
		<inst name="se_cmph"	flags="F.SIGNED"	def="cr0"	ref="CA" ic="IC.CMP" />
		<inst name="e_cmph16i"	flags="F.SIGNED"	def="cr0"	ref="CA" ic="IC.CMP" />
		<inst name="e_cmphl"	flags="F.UNSIGNED"	def="cr0"	ref="CA"	parse="PpcParseClass.SRC3" ic="IC.CMP" />
		<inst name="se_cmphl"	flags="F.UNSIGNED"	def="cr0"	ref="CA" ic="IC.CMP" />
		<inst name="e_cmphl16i"	flags="F.UNSIGNED"	def="cr0"	ref="CA" ic="IC.CMP" />
	</inst>
	<inst name="e_cmpl16i"	flags="F.UNSIGNED"	def="cr0"	ref="CA" />
	<inst name="e_cmpli"	flags="F.UNSIGNED"	def="cr0"	ref="CA"	parse="PpcParseClass.SRC3" ic="IC.CMP" />
	<inst name="se_cmpl"	flags="F.UNSIGNED"	def="cr0"	ref="CA" ic="IC.CMP" />
	<inst name="se_cmpli"	flags="F.UNSIGNED"	def="cr0"	ref="CA" ic="IC.CMP" />
    </inst>
    <inst parse="PpcParseClass.SRC3" cost="POC.ARITH" kind="K.NO_CSE" ic="IC.COND" >
	<inst name="e_crand"  tflag="PTF.CR3" />
	<inst name="e_crandc" tflag="PTF.CR3" />
	<inst name="e_creqv"  tflag="PTF.CR3" />
	<inst name="e_crnand" tflag="PTF.CR3" />
	<inst name="e_crnor"  tflag="PTF.CR3" />
	<inst name="e_cror"   tflag="PTF.CR3" />
	<inst name="e_crorc"  tflag="PTF.CR3" />
	<inst name="e_crxor"  tflag="PTF.CR3" />
    </inst>
    <inst cost="POC.ARITH" size="4" parse="PpcParseClass.MSRC1" ic="IC.DEF">
	<inst name="se_extsb"  flags="F.SZ_ONE|F.SIGNED"	kind="K.SEXT"	pop="POP.EXTSB" size="1" />
	<inst name="se_extsh"  flags="F.SZ_TWO|F.SIGNED"	kind="K.SEXT"	pop="POP.EXTSH" size="2" />
	<inst name="se_extzb"  flags="F.SZ_ONE"			kind="K.ZEXT"	pop="POP.EXTZB" size="1" />
	<inst name="se_extzh"  flags="F.SZ_TWO"			kind="K.ZEXT"	pop="POP.EXTZH" size="2" />
	<inst name="e_li"	parse="PpcParseClass.UNARY" pop="POP.LOADCONST" />
	<inst name="se_li"	parse="PpcParseClass.UNARY" pop="POP.LOADCONST" />
	<inst name="e_lis"	parse="PpcParseClass.UNARY" pop="POP.LIS" />
    </inst>
    <inst kind="K.NO_CSE" cost="POC.ARITH" parse="PpcParseClass.EMPTY" ic="IC.SU1" >
	<inst name="se_nop"	/>
    </inst>
    <inst parse="PpcParseClass.EMPTY" cost="POC.BRANCH" flags="F.NOPASS" kind="K.NO_CSE|K.NO_COPY|K.VOLATILE|K.MEM_REF|K.MEM_KILL" >
	<inst name="se_illegal" ref="msr,ivpr,ivor6" def="msr,srr0,srr1" />
	<inst name="se_isync" />
	<inst name="se_sc"	def="msr,srr0,srr1" ref="msr,ivpr,ivor8" />
    </inst>
    <inst cost="POC.MEM" flags="F.LD|F.R0IS0" ic="IC.LD" >
	<inst name="e_lbz"	parse="PpcParseClass.UNARY"  pop="POP.LOADB" size="1" flags="F.SZ_ONE" />
	<inst name="se_lbz"	parse="PpcParseClass.UNARY"  pop="POP.LOADB" size="1" flags="F.SZ_ONE" tflag="PTF.NOREMAT" />
	<inst name="e_lbzu"	parse="PpcParseClass.UNARY"  pop="POP.LOADB" size="1" flags="F.SZ_ONE|F.UPDATE" />

	<inst name="e_lha"	parse="PpcParseClass.UNARY"  pop="POP.LOADH" size="2" flags="F.SZ_TWO|F.SIGNED" />
	<inst name="e_lhau"	parse="PpcParseClass.UNARY"  pop="POP.LOADH" size="2" flags="F.SZ_TWO|F.SIGNED|F.UPDATE" />

	<inst name="e_lhz"	parse="PpcParseClass.UNARY"  pop="POP.LOADH" size="2" flags="F.SZ_TWO" />
	<inst name="se_lhz"	parse="PpcParseClass.UNARY"  pop="POP.LOADH" size="2" flags="F.SZ_TWO" tflag="PTF.NOREMAT" />
	<inst name="e_lhzu"	parse="PpcParseClass.UNARY"  pop="POP.LOADH" size="2" flags="F.SZ_TWO|F.UPDATE" />

	<inst name="e_lwz"	parse="PpcParseClass.UNARY"  pop="POP.LOADW" size="4" flags="F.SZ_FOUR" />
	<inst name="se_lwz"	parse="PpcParseClass.UNARY"  pop="POP.LOADW" size="4" flags="F.SZ_FOUR" tflag="PTF.NOREMAT" />
	<inst name="e_lwzu"	parse="PpcParseClass.UNARY"  pop="POP.LOADW" size="4" flags="F.SZ_FOUR|F.UPDATE" />
    </inst>
    <inst cost="POC.MEM" flags="F.R0IS0">
	<inst name="e_lmw"	parse="PpcParseClass.UNARY"	 size="4" flags="F.LM" kind="K.NO_CSE" ic="IC.LD" />
	<inst name="e_stmw"	parse="PpcParseClass.STORE"	 size="4" flags="F.SM" kind="K.NO_CSE" ic="IC.ST" />
    </inst>
    <inst parse="PpcParseClass.UNARY" cost="POC.ARITH">
	<inst name="e_mcrf"	tflag="PTF.CR2" pop="POP.REGCOPY" ic="IC.COND" />
	<inst name="mfapidi"	kind="K.NO_CSE" />
	<inst name="se_mfar"	kind="K.NO_CSE" />
	<inst name="se_mtar"	kind="K.NO_CSE" />
    </inst>
    <inst cost="POC.MUL" size="4" pop="POP.MUL"	>
	<inst name="e_mulli"	parse="PpcParseClass.BINARY" pop="POP.MUL" flags="F.COMMUTE" ic="IC.MULI" />
	<inst name="e_mull2i"	parse="PpcParseClass.MSRC12" pop="POP.MUL" ic="IC.MULI" />
	<inst name="se_mullw"	parse="PpcParseClass.MSRC12" pop="POP.MUL" ic="IC.MUL" earlyOut="1" />
    </inst>
    <inst cost="POC.ARITH" size="4" ic="IC.DEF">
	<inst name="se_neg"	parse="PpcParseClass.MSRC1"  pop="POP.NEGATE" />
	<inst name="se_not"	parse="PpcParseClass.MSRC1"  pop="POP.COMPLEMENT" />
	<inst name="se_or"	parse="PpcParseClass.MSRC12" pop="POP.OR" />
	<inst name="e_or2i"	parse="PpcParseClass.MSRC12" pop="POP.OR" />
	<inst name="e_or2is"	parse="PpcParseClass.MSRC12" />
	<suffix name="PpcRc" flags="F.DOTPOS">
		<inst name="e_ori"	parse="PpcParseClass.BINARY" pop="POP.OR" flags="F.COMMUTE" />
		<inst name="e_rlw"	parse="PpcParseClass.BINARY" />
		<inst name="e_rlwi"	parse="PpcParseClass.BINARY" />
	</suffix>
	<inst name="e_rlwinm"	parse="PpcParseClass.ROTATE" pop="POP.RLWINM" />
	<inst name="e_rlwimi"	parse="PpcParseClass.INSERT" />
    </inst>
    <inst cost="POC.BRANCH" parse="PpcParseClass.EMPTY" flags="F.BRANCH" ic="IC.BR" flags="F.RETURN|F.NOPASS" kind="K.NO_CSE|K.MEM_REF|K.MEM_KILL">
	<inst name="se_rfci" def="msr" ref="csrr0,csrr1" />
	<inst name="se_rfdi" def="msr" ref="dsrr0,dsrr1" />
	<inst name="se_rfi"  def="msr" ref="srr0,srr1" />
    </inst>
    <inst cost="POC.ARITH" size="4" ic="IC.DEF">
	<suffix name="PpcRc" flags="F.DOTPOS">
		<inst name="e_slwi"	parse="PpcParseClass.BINARY" pop="POP.SHL" />
	</suffix>
	<inst name="se_slw"	parse="PpcParseClass.MSRC12" pop="POP.SHL" />
	<inst name="se_slwi"	parse="PpcParseClass.MSRC12" pop="POP.SHL" />
	<inst name="se_sraw"	parse="PpcParseClass.MSRC12" pop="POP.SHRA" def="CA" />
	<inst name="se_srawi"	parse="PpcParseClass.MSRC12" pop="POP.SHRA" def="CA" />
	<suffix name="PpcRc" flags="F.DOTPOS">
		<inst name="e_srwi"	parse="PpcParseClass.BINARY"  pop="POP.SHRL" />
	</suffix>
	<inst name="se_srw"	parse="PpcParseClass.MSRC12" pop="POP.SHRL" />
	<inst name="se_srwi"	parse="PpcParseClass.MSRC12" pop="POP.SHRL" />
    </inst>
    <inst cost="POC.MEM" parse="PpcParseClass.STORE" flags="F.ST|F.R0IS0" ic="IC.ST" >
	<inst name="e_stb"	pop="POP.STOREB" size="1" flags="F.SZ_ONE"  />
	<inst name="se_stb"	pop="POP.STOREB" size="1" flags="F.SZ_ONE"  tflag="PTF.NOREMAT" />
	<inst name="e_stbu"	pop="POP.STOREB" size="1" flags="F.SZ_ONE|F.UPDATE" />

	<inst name="e_sth"	pop="POP.STOREH" size="2" flags="F.SZ_TWO" />
	<inst name="se_sth"	pop="POP.STOREH" size="2" flags="F.SZ_TWO" tflag="PTF.NOREMAT" />
	<inst name="e_sthu"	pop="POP.STOREH" size="2" flags="F.SZ_TWO|F.UPDATE" />

	<inst name="e_stw"	pop="POP.STOREW" size="4" flags="F.SZ_FOUR" />
	<inst name="se_stw"	pop="POP.STOREW" size="4" flags="F.SZ_FOUR" tflag="PTF.NOREMAT" />
	<inst name="e_stwu"	pop="POP.STOREW" size="4" flags="F.SZ_FOUR|F.UPDATE" />
    </inst>
    <inst cost="POC.ARITH" size="4" ic="IC.DEF">
	<inst name="se_sub"	parse="PpcParseClass.MSRC12" pop="POP.SUB" />
	<inst name="se_subf"	parse="PpcParseClass.MSRC12" pop="POP.SUBF" />
	<suffix name="PpcRc" flags="F.DOTPOS">
		<inst name="e_subfic"	parse="PpcParseClass.BINARY" def="CA" />
		<inst name="se_subi"	parse="PpcParseClass.MSRC12" pop="POP.SUB" />
		<inst name="e_xor"	parse="PpcParseClass.BINARY" pop="POP.XOR" flags="F.COMMUTE" />
	</suffix>
    </inst>
</cond>

	<!-- AltiVec SIMD -->
	<!-- Needed to compile frameinfo.h -->
<cond when="!Processor.VLE">
    <inst parse="PpcParseClass.STORE" cost="POC.VMEM" flags="F.ST|F.R0IS0" size="16" ic="IC.ST" >
	<inst name="stvx"	/>
    </inst>
    <inst parse="PpcParseClass.UNARY" cost="POC.VMEM" flags="F.LD|F.R0IS0" size="16" ic="IC.LD" >
	<inst name="lvx"	/>
    </inst>
</cond>
<cond when="Processor.AltiVec">
    <popmap ivalue="POP.REGCOPY" cost="POC.ARITH" rule="l=V && r=V : l(V) r(V) : .diab.vmr $1,$2" />
    <macro parse="PpcParseClass.VAFORM" ic="IC.VEC" >
	<macro name="vsldoi"	rule="l=V && r=V && r.r=r && r.r.r=0 : l(V) r(V) : .diab.vmr $1,$2" />
    </macro>
    <inst parse="PpcParseClass.VXFORMDS" cost="POC.ARITH" ic="IC.VEC" >
	<inst name=".diab.vmr"	pop="POP.REGCOPY"	/>
    </inst>
    <inst parse="PpcParseClass.VAFORM" cost="POC.ALTIVEC" ic="IC.VCI" >
	<inst name="vmhaddshs"	/>
	<inst name="vmhraddshs"	/>
	<inst name="vmladduhm"	/>
	<inst name="vmsumubm"	/>
	<inst name="vmsummbm"	/>
	<inst name="vmsumuhm"	/>
	<inst name="vmsumuhs"	/>
	<inst name="vmsumshm"	/>
	<inst name="vmsumshs"	/>
	<inst name="vsel"	ic="IC.VEC" />
	<inst name="vperm"	ic="IC.VEC" />
	<inst name="vmaddfp"	ic="IC.VFP" />
	<inst name="vnmsubfp"	/>
	<inst name="vsldoi"	ic="IC.VEC" />
    </inst>
    <inst parse="PpcParseClass.VXFORM" cost="POC.ALTIVEC" ic="IC.VEC">
	<inst name="vaddubm"	/>
	<inst name="vadduhm"	/>
	<inst name="vadduwm"	/>
	<inst name="vaddcuw"	/>
	<inst name="vaddubs"	/>
	<inst name="vadduhs"	/>
	<inst name="vadduws"	/>
	<inst name="vaddsbs"	/>
	<inst name="vaddshs"	/>
	<inst name="vaddsws"	/>
	<inst name="vsububm"	/>
	<inst name="vsubuhm"	/>
	<inst name="vsubuwm"	/>
	<inst name="vsubcuw"	/>
	<inst name="vsububs"	/>
	<inst name="vsubuhs"	/>
	<inst name="vsubuws"	/>
	<inst name="vsubsbs"	/>
	<inst name="vsubshs"	/>
	<inst name="vsubsws"	/>
	<inst name="vmaxub"	/>
	<inst name="vmaxuh"	/>
	<inst name="vmaxuw"	/>
	<inst name="vmaxsb"	/>
	<inst name="vmaxsh"	/>
	<inst name="vmaxsw"	/>
	<inst name="vminub"	/>
	<inst name="vminuh"	/>
	<inst name="vminuw"	/>
	<inst name="vminsb"	/>
	<inst name="vminsh"	/>
	<inst name="vminsw"	/>
	<inst name="vavgub"	/>
	<inst name="vavguh"	/>
	<inst name="vavguw"	/>
	<inst name="vavgsb"	/>
	<inst name="vavgsh"	/>
	<inst name="vavgsw"	/>
	<inst name="vrlb"	/>
	<inst name="vrlh"	/>
	<inst name="vrlw"	/>
	<inst name="vslb"	/>
	<inst name="vslh"	/>
	<inst name="vslw"	/>
	<inst name="vsl"	/>
	<inst name="vsrb"	/>
	<inst name="vsrh"	/>
	<inst name="vsrw"	/>
	<inst name="vsr"	/>
	<inst name="vsrab"	/>
	<inst name="vsrah"	/>
	<inst name="vsraw"	/>
	<inst name="vand"	/>
	<inst name="vandc"	/>
	<inst name="vor"	/>
	<inst name="vnor"	/>
	<inst name="mfvscr"	parse="PpcParseClass.VXFORMD"	/>
	<inst name="mtvscr"	parse="PpcParseClass.VXFORMS"	/>
	<inst name="vmuloub"	ic="IC.VCI" />
	<inst name="vmulouh"	ic="IC.VCI" />
	<inst name="vmulosb"	ic="IC.VCI" />
	<inst name="vmulosh"	ic="IC.VCI" />
	<inst name="vmuleub"	ic="IC.VCI" />
	<inst name="vmuleuh"	ic="IC.VCI" />
	<inst name="vmulesb"	ic="IC.VCI" />
	<inst name="vmulesh"	ic="IC.VCI" />
	<inst name="vsum4ubs"	ic="IC.VCI" />
	<inst name="vsum4sbs"	ic="IC.VCI" />
	<inst name="vsum4shs"	ic="IC.VCI" />
	<inst name="vsum2sws"	ic="IC.VCI" />
	<inst name="vsumsws"	ic="IC.VCI" />
	<inst name="vaddfp"	ic="IC.VFP" />
	<inst name="vsubfp"	ic="IC.VFP" />
	<inst name="vrefp"	ic="IC.VFP" parse="PpcParseClass.VXFORMDS"	/>
	<inst name="vrsqrtefp"	ic="IC.VFP" parse="PpcParseClass.VXFORMDS"	/>
	<inst name="vexptefp"	ic="IC.VFP" parse="PpcParseClass.VXFORMDS"	/>
	<inst name="vlogefp"	ic="IC.VFP" parse="PpcParseClass.VXFORMDS"	/>
	<inst name="vrfin"	ic="IC.VFP" parse="PpcParseClass.VXFORMDS"	/>
	<inst name="vrfiz"	ic="IC.VFP" parse="PpcParseClass.VXFORMDS"	/>
	<inst name="vrfip"	ic="IC.VFP" parse="PpcParseClass.VXFORMDS"	/>
	<inst name="vrfim"	ic="IC.VFP" parse="PpcParseClass.VXFORMDS"	/>
	<inst name="vcfux"	ic="IC.VFP" />
	<inst name="vcfsx"	ic="IC.VFP" />
	<inst name="vctuxs"	ic="IC.VFP" />
	<inst name="vctsxs"	ic="IC.VFP" />
	<inst name="vmaxfp"	/>
	<inst name="vminfp"	/>
	<inst name="vmrghb"	/>
	<inst name="vmrghh"	/>
	<inst name="vmrghw"	/>
	<inst name="vmrglb"	/>
	<inst name="vmrglh"	/>
	<inst name="vmrglw"	/>
	<inst name="vspltb"	/>
	<inst name="vsplth"	/>
	<inst name="vspltw"	/>
	<inst name="vspltisb"	parse="PpcParseClass.VXFORMDS"	/>
	<inst name="vspltish"	parse="PpcParseClass.VXFORMDS"	/>
	<inst name="vspltisw"	parse="PpcParseClass.VXFORMDS"	/>
	<inst name="vslo"	/>
	<inst name="vsro"	/>
	<inst name="vpkuhum"	/>
	<inst name="vpkuwum"	/>
	<inst name="vpkuhus"	/>
	<inst name="vpkuwus"	/>
	<inst name="vpkshus"	/>
	<inst name="vpkswus"	/>
	<inst name="vpkshss"	/>
	<inst name="vpkswss"	/>
	<inst name="vupkhsb"	parse="PpcParseClass.VXFORMDS"	/>
	<inst name="vupkhsh"	parse="PpcParseClass.VXFORMDS"	/>
	<inst name="vupklsb"	parse="PpcParseClass.VXFORMDS"	/>
	<inst name="vupklsh"	parse="PpcParseClass.VXFORMDS"	/>
	<inst name="vpkpx"	/>
	<inst name="vupkhpx"	parse="PpcParseClass.VXFORMDS"	/>
	<inst name="vupklpx"	parse="PpcParseClass.VXFORMDS"	/>
	<inst name="vxor"	/>
    </inst>
    <inst parse="PpcParseClass.XFORMS34" cost="POC.ALTIVEC" kind="K.VOLATILE|K.NO_CSE" ic="IC.VEC" >
	<inst name="dst"	/>
	<inst name="dstt"	/>
	<inst name="dstst"	/>
	<inst name="dststt"	/>
    </inst>
    <inst parse="PpcParseClass.XFORMS012" cost="POC.ALTIVEC" kind="K.VOLATILE|K.NO_CSE" ic="IC.VEC" >
	<inst name="dss"	/>
	<inst name="dssall"	/>
    </inst>
    <inst parse="PpcParseClass.UNARY" cost="POC.VMEM" flags="F.LD|F.R0IS0" size="16" ic="IC.LD" >
	<inst name="lvebx"	/>
	<inst name="lvehx"	/>
	<inst name="lvewx"	/>
	<inst name="lvsl"	/>
	<inst name="lvsr"	/>
	<inst name="lvxl"	/>
	<inst name="lvepx"	kind="K.VOLATILE" />
	<inst name="lvepxl"	kind="K.VOLATILE" />
    </inst>
    <inst parse="PpcParseClass.STORE" cost="POC.VMEM" flags="F.ST|F.R0IS0" size="16" ic="IC.ST" >
	<inst name="stvebx"	/>
	<inst name="stvehx"	/>
	<inst name="stvewx"	/>
	<inst name="stvxl"	/>
	<inst name="stvepx"	kind="K.VOLATILE" />
	<inst name="stvepxl"	kind="K.VOLATILE" />
    </inst>
    <inst parse="PpcParseClass.VXFORM" cost="POC.ALTIVEC" ic="IC.VEC" >
	<suffix name="PpcVrc">
	    <inst name="vcmpbfp"	/>
	    <inst name="vcmpeqfp"	/>
	    <inst name="vcmpequb"	/>
	    <inst name="vcmpequh"	/>
	    <inst name="vcmpequw"	/>
	    <inst name="vcmpgefp"	/>
	    <inst name="vcmpgtfp"	/>
	    <inst name="vcmpgtsb"	/>
	    <inst name="vcmpgtsh"	/>
	    <inst name="vcmpgtsw"	/>
	    <inst name="vcmpgtub"	/>
	    <inst name="vcmpgtuh"	/>
	    <inst name="vcmpgtuw"	/>
	</suffix>
    </inst>
</cond>

<peephole>
    <peephole name="PpcRlwinmExtsb">
	<i0	ivalue="POP.RLWINM"	rule="r.r.r<=r.r.r.r && r.r.r=[25:31] :: UNCHANGED" />
	<i1	ivalue="POP.EXTSB"	rule="l=R && r=i0.l : l(R) r(R) : mr $1,$2" />
    </peephole>

    <peephole name="PpcRlwinmExtsh">
	<i0	ivalue="POP.RLWINM"	rule="r.r.r<=r.r.r.r && r.r.r=[17:31] :: UNCHANGED" />
	<i1	ivalue="POP.EXTSH"	rule="l=R && r=i0.l : l(R) r(R) : mr $1,$2" />
    </peephole>

    <peephole name="PpcRlwinmRlwinm">
	<i0	ivalue="POP.RLWINM"	rule="r.r.r<=r.r.r.r :: UNCHANGED" />
	<i1	ivalue="POP.RLWINM"	rule="r=i0.l && r.r=0 && r.r.r<=i0.r.r.r && r.r.r.r>=i0.r.r.r.r : l(R) r(R) : mr $1,$2" />
    </peephole>

    <peephole name="PpcExtsbExtsh">
	<i0	ivalue="POP.EXTSB"	rule="l=R && r=R :: UNCHANGED" />
	<i1	ivalue="POP.EXTSH"	rule="l=R && r=i0.l : l(R) r(R) : mr $1,$2" />
    </peephole>

    <peephole name="PpcExtshExtsh">
	<i0	ivalue="POP.EXTSH"	rule="l=R && r=R :: UNCHANGED" />
	<i1	ivalue="POP.EXTSH"	rule="l=R && r=i0.l : l(R) r(R) : mr $1,$2" />
    </peephole>

    <peephole name="PpcFrspFrsp">
	<i0	ivalue="POP.FRSP"	rule="l=F && r=F ::  UNCHANGED" />
	<i1	ivalue="POP.FRSP"	rule="l=F && r=i0.l : l(F) r(F) : fmr $1,$2" />
    </peephole>

    <peephole name="PpcFrspFrsp">
	<i0	ivalue="POP.FRSP"	rule="l=F && r=F ::  UNCHANGED" />
	<i1	ivalue="POP.FRSP"	rule="l=F && r=i0.l : l(F) r(F) : fmr $1,$2" />
    </peephole>

    <peephole name="PpcHiLo" validUntil="LLOPT.POSTEXPAND" nostats="1">
	<i0	ivalue="POP.LIS"	rule="l=R && isHiadj(r) :: DELETE" />
	<i1	ivalue="POP.ADD"	rule="l=R && l=r && r=i0.l && isLow(r.r) && stripRel(i0.r)=stripRel(r.r) : l(R) stripRel(r.r) : diab.la.halo $1,$2" />
    </peephole>

    <peephole name="PpcLisAdd" validUntil="LLOPT.POSTEXPAND" nostats="1">
	<i0	ivalue="POP.LIS"	rule="l=R && r=CONST :: DELETE" />
	<i1	ivalue="POP.ADD"	rule="l=R && l=r && r=i0.l && r.r=CONST : l(R) const(i0.r) const(r.r) : li $1, ($2 << 16) + $3" />
    </peephole>

    <peephole name="PpcLisOr" validUntil="LLOPT.POSTEXPAND" nostats="1">
	<i0	ivalue="POP.LIS"	rule="l=R && r=CONST :: DELETE" />
	<i1	ivalue="POP.OR"		rule="l=R && l=r && r=i0.l && r.r=CONST : l(R) const(i0.r) const(r.r) : li $1, ($2 << 16) | $3" />
    </peephole>

    <peephole name="DeadSpeMove">
	<i0	ivalue="POP.EVMERGEHILO"	rule="l=R && l=r && r=r.r :: DELETE" />
    </peephole>

    <!-- TODO add hasside intrinsic that checks the specific instruction for side effects -->
    <!-- We currently do not skip instructions with side effects.  Thus CR0 updating forms are skipped by llpeephole.cc.	-->
    <!-- I want to change this.  Right now we cannot pass instruction through to the predicate eval routine.  Improve this.	-->
    <peephole name="DeadOr">
	<i0	ivalue="POP.OR"	rule="l=R && l=r && r.r=0 :: DELETE" />
    </peephole>
    <peephole name="DeadXor">
	<i0	ivalue="POP.XOR"	rule="l=R && l=r && r.r=0 :: DELETE" />
    </peephole>
    <peephole name="DeadOris">
	<i0	ivalue="POP.ORIS"	rule="l=R && l=r && r.r=0 :: DELETE" />
    </peephole>
    <peephole name="DeadXoris">
	<i0	ivalue="POP.XORIS"	rule="l=R && l=r && r.r=0 :: DELETE" />
    </peephole>

<cond when="Processor.VLE">
    <cond when="0">
        <!-- TODO -->
        <!-- This is not safe no matter whether the .diab.btsti replaces i0 or i1. Consider the case below where i0 is replaced and i1 deleted. -->
        <!-- i1 sets a CR and this definition reaches some later instruction (e.g. a conditional branch) that uses it. Call that instruction i2.-->
        <!-- When we do the peephole, the definition of CR gets moved up to i0. This only works if the definition continues to reach i2.        -->
        <!-- This is only the case if there are no intervening definitions of CR between i0 and i1.                                             -->
        <!-- On the other hand if we output the .diab.btsti at i1 we'll have the reverse problem. The definition of the input register i0.r     -->
        <!-- comes from some earlier instruction. Call that d0.                                                                                 -->
        <!-- For the transformation to be valid the definition at d0 has to reach all the way to i1. Again this only works if there are no      -->
        <!-- intervening definitions of i0.r between i0 and i1.                                                                                 -->
	<peephole name="VleBtsti" watch="0">
	    <i0	ivalue="POP.RLWINM"	rule="l=R && r=R && r.r=0 && r.r.r=CONST && r.r.r.r=r.r.r : r(R) const(r.r.r) : .diab.btsti $1,$2" />
	    <i1	ivalue="POP.CMPW"	rule="l=C && r=i0.l && dead(r) && r.r=0 :: DELETE" />
	</peephole>
    </cond>
    <peephole name="VleCmpHalf" watch="0">
	<i0	ivalue="POP.EXTSH"	rule="l=R && r=l:: DELETE" />
	<i1	ivalue="POP.CMP"	rule="r=i0.l && r.r=[-32768:32767] && dead(r): any(r) any(r.r): e_cmph16i $1,$2" />
    </peephole>
    <peephole name="VleCmpHalf2" watch="0">
	<i0	ivalue="POP.EXTSH"	rule="l=R && r=l:: DELETE" />
	<i1	ivalue="POP.EXTSH"	rule="l=R && r=l:: DELETE" />
	<i2	ivalue="POP.CMP"	rule="r=i0.l && r.r=i1.l && dead(r) && dead(r.r): any(r) any(r.r): e_cmph $1,$2" />
    </peephole>
    <peephole name="VleCmpHalf3" watch="0">
	<i0	ivalue="POP.EXTSH"	rule="l=R && r=l:: DELETE" />
	<i1	ivalue="POP.EXTSH"	rule="l=R && r=l:: DELETE" />
	<i2	ivalue="POP.CMP"	rule="r=i1.l && r.r=i0.l && dead(r) && dead(r.r): any(r) any(r.r): e_cmph $1,$2" />
    </peephole>
</cond>
</peephole>

</isa>
